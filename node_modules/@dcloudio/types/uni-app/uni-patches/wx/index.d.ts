declare namespace UniNamespace {
    /**
     * 需要基础库： `2.10.4`
     *
     * 网络请求过程中一些调试信息，[查看详细说明](https://developers.weixin.qq.com/miniprogram/dev/framework/performance/network.html)
     */
    interface RequestProfile {
        /**
         * SSL建立完成的时间,如果不是安全连接,则值为 0
         */
        SSLconnectionEnd: number;
        /**
         * SSL建立连接的时间,如果不是安全连接,则值为 0
         */
        SSLconnectionStart: number;
        /**
         * HTTP（TCP） 完成建立连接的时间（完成握手），如果是持久连接，则与 fetchStart 值相等。注意如果在传输层发生了错误且重新建立连接，则这里显示的是新建立的连接完成的时间。注意这里握手结束，包括安全连接建立完成、SOCKS 授权通过
         */
        connectEnd: number;
        /**
         * HTTP（TCP） 开始建立连接的时间，如果是持久连接，则与 fetchStart 值相等。注意如果在传输层发生了错误且重新建立连接，则这里显示的是新建立的连接开始的时间
         */
        connectStart: number;
        /**
         * DNS 域名查询完成的时间，如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 fetchStart 值相等
         */
        domainLookUpEnd: number;
        /**
         * DNS 域名查询开始的时间，如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 fetchStart 值相等
         */
        domainLookUpStart: number;
        /**
         * 评估当前网络下载的kbps
         */
        downstreamThroughputKbpsEstimate: number;
        /**
         * 评估的网络状态 unknown, offline, slow 2g, 2g, 3g, 4g, last/0, 1, 2, 3, 4, 5, 6
         */
        estimate_nettype: number;
        /**
         * 组件准备好使用 HTTP 请求抓取资源的时间，这发生在检查本地缓存之前
         */
        fetchStart: number;
        /**
         * 协议层根据多个请求评估当前网络的 rtt（仅供参考）
         */
        httpRttEstimate: number;
        /**
         * 当前请求的IP
         */
        peerIP: string;
        /**
         * 当前请求的端口
         */
        port: number;
        /**
         * 使用协议类型，有效值：http1.1, h2, quic, unknown
         */
        protocol: string;
        /**
         * 收到字节数
         */
        receivedBytedCount: number;
        /**
         * 最后一个 HTTP 重定向完成时的时间。有跳转且是同域名内部的重定向才算，否则值为 0
         */
        redirectEnd: number;
        /**
         * 第一个 HTTP 重定向发生时的时间。有跳转且是同域名内的重定向才算，否则值为 0
         */
        redirectStart: number;
        /**
         * HTTP请求读取真实文档结束的时间
         */
        requestEnd: number;
        /**
         * HTTP请求读取真实文档开始的时间（完成建立连接），包括从本地读取缓存。连接错误重连时，这里显示的也是新建立连接的时间
         */
        requestStart: number;
        /**
         * HTTP 响应全部接收完成的时间（获取到最后一个字节），包括从本地读取缓存
         */
        responseEnd: number;
        /**
         * HTTP 开始接收响应的时间（获取到第一个字节），包括从本地读取缓存
         */
        responseStart: number;
        /**
         * 当次请求连接过程中实时 rtt
         */
        rtt: number;
        /**
         * 发送的字节数
         */
        sendBytesCount: number;
        /**
         * 是否复用连接
         */
        socketReused: boolean;
        /**
         * 当前网络的实际下载kbps
         */
        throughputKbps: number;
        /**
         * 传输层根据多个请求评估的当前网络的 rtt（仅供参考）
         */
        transportRttEstimate: number;
        /**
         * 是否走到了高性能模式。基础库 v3.3.4 起支持。
         */
        usingHighPerformanceMode: boolean;
    }

    interface DownloadSuccessData {
        /** 用户文件路径 (本地路径)。传入 filePath 时会返回，跟传入的 filePath 一致 */
        filePath?: string;
        /**
         * 需要基础库： `2.10.4`
         *
         * 网络请求过程中一些调试信息，[查看详细说明](https://developers.weixin.qq.com/miniprogram/dev/framework/performance/network.html)
         */
        profile?: RequestProfile;
        errMsg?: string;
    }

    interface DownloadFileOption {
        /**
         * 需要基础库： `2.10.4`
         *
         * 是否开启 http2
         */
        enableHttp2?: boolean;
        /** 是否开启 profile，默认开启。开启后可在接口回调的 res.profile 中查看性能调试信息。 */
        enableProfile?: boolean;
        /**
         * 需要基础库： `2.10.4`
         *
         * 是否开启 Quic/h3 协议（iOS 微信目前使用 gQUIC-Q43；Android 微信在 v8.0.54 前使用 gQUIC-Q43，v8.0.54 开始使用 IETF QUIC，即 h3 协议；PC微信使用 IETF QUIC，即 h3 协议）
         */
        enableQuic?: boolean;
        /**
         * 需要基础库： `1.8.0`
         *
         * 指定文件下载后存储的路径 (本地路径)
         */
        filePath?: string;
        /**
         * 需要基础库： `3.4.1`
         *
         * 使用高性能模式，暂仅支持 Android，默认关闭。该模式下有更优的网络性能表现。
         */
        useHighPerformanceMode?: boolean;
    }

    /**
     * 本次请求底层失败信息，所有失败信息均符合Errno错误码
     */
    interface ExceptionReason {
        /**
         * 错误原因
         */
        errMsg: string;
        /**
         * 错误码
         */
        errno: string;
    }

    /**
     * 需要基础库： `3.0.0`
     *
     * 网络请求过程中的一些异常信息，例如httpdns重试等
     */
    interface RequestException {
        /**
         * 本次请求底层失败信息，所有失败信息均符合Errno错误码
         */
        reasons: ExceptionReason[];
        /**
         * 本次请求底层重试次数
         */
        retryCount: number;
    }

    interface RequestSuccessCallbackResult {
        /**
         * 需要基础库： `3.0.0`
         *
         * 网络请求过程中的一些异常信息，例如httpdns重试等
         */
        exception?: RequestException;
        /**
         * 需要基础库： `2.10.4`
         *
         * 网络请求过程中一些调试信息，[查看详细说明](https://developers.weixin.qq.com/miniprogram/dev/framework/performance/network.html)
         */
        profile?: RequestProfile;
        /**
         * 需要基础库： `3.4.10`
         *
         * 最终请求是否使用了HttpDNS（仅当enableHttpDNS传true时返回此字段）
         */
        useHttpDNS?: boolean;
        errMsg?: string;
    }

    interface RequestOptions {
        /** 是否开启 profile，默认开启。开启后可在接口回调的 res.profile 中查看性能调试信息。 */
        enableProfile?: boolean;
        /**
         * 需要基础库： `3.2.2`
         *
         * 重定向拦截策略。（目前安卓、iOS、开发者工具已支持，PC端将在后续支持）
         *
         * 可选值：
         * - 'follow': 不拦截重定向，即客户端自动处理重定向;
         * - 'manual': 拦截重定向。开启后，当 http 状态码为 3xx 时客户端不再自动重定向，而是触发 onHeadersReceived 回调，并结束本次 request 请求。可通过 onHeadersReceived 回调中的 header.Location 获取重定向的 url;
         */
        redirect?: "follow" | "manual";
        /**
         * 需要基础库： `3.3.3`
         *
         * 使用高性能模式，暂仅支持 Android，默认关闭。该模式下有更优的网络性能表现，更多信息请查看下方说明。
         */
        useHighPerformanceMode?: boolean;
    }

    interface RewardedVideoAdOptions {
        /**
         * 需要基础库： `3.7.1`
         *
         * 是否禁用分享页，默认为false
         */
        disableFallbackSharePage?: boolean;
        /**
         * 需要基础库： `2.8.0`
         *
         * 是否启用多例模式，默认为false
         */
        multiton?: boolean;
    }

    interface ConnectSocketOption {
        /**
         * 需要基础库： `2.29.0`
         *
         * 强制使用蜂窝网络发送请求
         */
        forceCellularNetwork?: boolean;
        /**
         * 需要基础库： `2.8.0`
         *
         * 是否开启压缩扩展
         */
        perMessageDeflate?: boolean;
        /**
         * 需要基础库： `2.4.0`
         *
         * 建立 TCP 连接的时候的 TCP_NODELAY 设置
         */
        tcpNoDelay?: boolean;
        /**
         * 需要基础库： `2.10.0`
         *
         * 超时时间，单位为毫秒
         */
        timeout?: number;
    }

    interface UploadFileSuccessCallbackResult {
        errMsg?: string;
    }

    interface UploadFileOption {
        /**
         * 需要基础库： `2.10.4`
         *
         * 是否开启 http2
         */
        enableHttp2?: boolean;
        /** 是否开启 profile，默认开启。开启后可在接口回调的 res.profile 中查看性能调试信息。目前仅 iOS 端支持。 */
        enableProfile?: boolean;
        /**
         * 需要基础库： `2.10.4`
         *
         * 是否开启 Quic/h3 协议（iOS 微信目前使用 gQUIC-Q43；Android 微信在 v8.0.54 前使用 gQUIC-Q43，v8.0.54 开始使用 IETF QUIC，即 h3 协议；PC微信使用 IETF QUIC，即 h3 协议）
         */
        enableQuic?: boolean;
        /**
         * 需要基础库： `3.4.1`
         *
         * 使用高性能模式，暂仅支持 Android，默认关闭。该模式下有更优的网络性能表现。
         */
        useHighPerformanceMode?: boolean;
    }

    interface CanvasToTempFilePathRes {
        errMsg?: string;
    }

    interface CanvasToTempFilePathOptions {
        /** 画布标识，传入 [canvas](https://developers.weixin.qq.com/miniprogram/dev/component/canvas.html) 组件实例 （canvas type="2d" 时使用该属性）。 */
        canvas?: any;
    }

    interface ChooseAddressRes {
        /** 新选择器详细收货地址信息 */
        detailInfoNew?: string;
        /** 国标收货地址第四级地址 */
        streetName?: string;
    }

    interface ChooseImageSuccessCallbackResult {
        errMsg?: string;
    }

    interface ChooseLocationSuccess {
        errMsg?: string;
    }

    interface ChooseVideoSuccess {
        errMsg?: string;
    }

    interface CompressImageSuccessResult {
        errMsg?: string;
    }

    interface CompressVideoSuccessData {
        errMsg?: string;
    }

    interface GetClipboardDataSuccessRes {
        errMsg?: string;
    }

    interface GetImageInfoSuccessData {
        errMsg?: string;
    }

    interface GetLocationSuccess {
        errMsg?: string;
    }

    interface GetNetworkTypeSuccess {
        /**
         * 需要基础库： `2.22.1`
         *
         * 设备是否使用了网络代理
         */
        hasSystemProxy?: boolean;
        /** 信号强弱，单位 dbm */
        signalStrength?: number;
        /**
         * 需要基础库： `3.5.3`
         *
         * 是否处于弱网环境
         */
        weakNet?: boolean;
        errMsg?: string;
    }

    interface GetScreenBrightnessSuccessRes {
        errMsg?: string;
    }

    interface GetSelectedTextRangeSuccessCallbackResult {
        errMsg?: string;
    }

    interface GetSettingSuccessResult {
        /**
         * [AuthSetting](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/setting/AuthSetting.html)
         *
         * 在插件中调用时，当前宿主小程序的用户授权结果
         */
        miniprogramAuthSetting?: AuthSetting;
        errMsg?: string;
    }

    interface GetStorageSuccess {
        errMsg?: string;
    }

    interface GetStorageOptions {
        /**
         * 需要基础库： `2.21.3`
         *
         * 是否开启加密存储。只有异步的 getStorage 接口支持开启加密存储。开启后，将会对 data 使用 AES128 解密，接口回调耗时将会增加。若开启加密存储，setStorage 和 getStorage 需要同时声明 encrypt 的值为 true
         */
        encrypt?: boolean;
    }

    interface GetStorageInfoSuccess {
        errMsg?: string;
    }

    interface GetSystemInfoResult {
        /**
         * 需要基础库： `1.8.0`
         *
         * 设备性能等级（仅 Android）。取值为：-2 或 0（该设备无法运行小游戏），-1（性能未知），>=1（设备性能值，该值越高，设备性能越好）<br> 注意：性能等级当前仅反馈真机机型，暂不支持 IDE 模拟器机型
         */
        benchmarkLevel?: number;
        /**
         * 需要基础库： `2.15.0`
         *
         * 是否已打开调试。可通过右上角菜单或 [wx.setEnableDebug](https://developers.weixin.qq.com/miniprogram/dev/api/base/debug/wx.setEnableDebug.html) 打开调试。
         */
        enableDebug?: boolean;
        /** `true` 表示模糊定位，`false` 表示精确定位，仅 iOS 支持 */
        locationReducedAccuracy?: boolean;
        /**
         * 需要基础库： `2.19.3`
         *
         * 允许微信使用日历的开关
         */
        phoneCalendarAuthorized?: boolean;
    }

    interface GetUserInfoRes {
        /**
         * 需要基础库： `2.7.0`
         *
         * 敏感数据对应的云 ID，开通[云开发](https://developers.weixin.qq.com/miniprogram/dev/wxcloudservice/wxcloud/basis/getting-started.html)的小程序才会返回，可通过云调用直接获取开放数据，详细见[云调用直接获取开放数据](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.html#method-cloud)
         */
        cloudID?: string;
    }

    interface GetUserProfileRes {
        /**
         * 需要基础库： `2.10.4`
         *
         * 敏感数据对应的云 ID，开通[云开发](https://developers.weixin.qq.com/miniprogram/dev/wxcloudservice/wxcloud/basis/getting-started.html)的小程序才会返回，可通过云调用直接获取开放数据，详细见[云调用直接获取开放数据](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.html#method-cloud)
         */
        cloudID?: string;
    }

    interface GetVideoInfoSuccessData {
        errMsg?: string;
    }

    interface HideShareMenuOptions {
        /**
         * 需要基础库： `2.11.3`
         *
         * 本接口为 Beta 版本，暂只在 Android 平台支持。需要隐藏的转发按钮名称列表，默认['shareAppMessage', 'shareTimeline']。按钮名称合法值包含 "shareAppMessage"、"shareTimeline" 两种
         */
        menus?: string[];
    }

    interface LoadFontFaceOptions {
        /** 字体作用范围，可选值为 webview / native / skyline，默认全选，设置 native 可在 Canvas 2D 下使用 */
        scopes?: any[];
    }

    interface NavigateToOptions {
        /** 3.4.0 自定义路由配置，相关文档 [自定义路由](https://developers.weixin.qq.com/miniprogram/dev/framework/runtime/skyline/custom-route.html) */
        routeConfig?: any;
        /** 3.4.0 自定义路由参数，相关文档 [自定义路由](https://developers.weixin.qq.com/miniprogram/dev/framework/runtime/skyline/custom-route.html) */
        routeOptions?: any;
        /** 2.29.2 自定义路由类型，相关文档 [自定义路由](https://developers.weixin.qq.com/miniprogram/dev/framework/runtime/skyline/custom-route.html) */
        routeType?: string;
    }

    interface NavigateToMiniProgramOptions {
        /**
         * 需要基础库： `2.24.0`
         *
         * 不reLaunch目标小程序，直接打开目标跳转的小程序退后台时的页面，需满足以下条件：1. 目标跳转的小程序生命周期未被销毁；2. 且目标当次启动的path、query与上次启动相同，apiCategory以wx.getApiCategory接口的返回结果为准。
         */
        noRelaunchIfPathUnchanged?: boolean;
        /**
         * 需要基础库： `2.18.1`
         *
         * 小程序链接，当传递该参数后，可以不传 appId 和 path。链接可以通过【小程序菜单】->【复制链接】获取。
         */
        shortLink?: string;
    }

    interface StopBluetoothDevicesDiscoverySuccess {
        /**
         * 错误码
         *
         * | 错误码 | 错误信息 | 说明 |
         * | - | - | - |
         * | 0 | ok | 正常 |
         * | -1 | already connect | 已连接 |
         * | 10000 | not init | 未初始化蓝牙适配器 |
         * | 10001 | not available | 当前蓝牙适配器不可用 |
         * | 10002 | no device | 没有找到指定设备 |
         * | 10003 | connection fail | 连接失败 |
         * | 10004 | no service | 没有找到指定服务 |
         * | 10005 | no characteristic | 没有找到指定特征 |
         * | 10006 | no connection | 当前连接已断开 |
         * | 10007 | property not support | 当前特征不支持此操作 |
         * | 10008 | system error | 其余所有系统上报的异常 |
         * | 10009 | system not support | Android 系统特有，系统版本低于 4.3 不支持 BLE |
         * | 10012 | operate time out | 连接超时 |
         * | 10013 | invalid_data | 连接 deviceId 为空或者是格式不正确 |
         */
        errCode?: number;
    }

    interface NotifyBLECharacteristicValueChangeOptions {
        /**
         * 需要基础库： `2.4.0`
         *
         * 设置特征订阅类型，有效值有 `notification` 和 `indication`
         */
        type?: string;
    }

    interface OpenBluetoothAdapterOptions {
        /**
         * 需要基础库： `2.10.0`
         *
         * 蓝牙模式，可作为主/从设备，仅 iOS 需要。
         *
         * 可选值：
         * - 'central': 主机模式;
         * - 'peripheral': 从机（外围设备）模式;
         */
        mode?: "central" | "peripheral";
    }

    interface OpenDocumentOptions {
        /**
         * 需要基础库： `2.11.0`
         *
         * 是否显示右上角菜单
         */
        showMenu?: boolean;
    }

    interface OpenVideoEditorSuccessData {
        errMsg?: string;
    }

    interface OpenVideoEditorOptions {
        /**
         * 需要基础库： `2.16.1`
         *
         * 视频裁剪的最大长度
         */
        maxDuration?: string;
        /**
         * 需要基础库： `2.16.1`
         *
         * 视频裁剪的最小长度
         */
        minDuration?: string;
    }

    interface PageScrollToOptions {
        /**
         * 需要基础库： `2.23.1`
         *
         * 偏移距离，需要和 selector 参数搭配使用，可以滚动到 selector 加偏移距离的位置，单位 px
         */
        offsetTop?: number;
    }

    interface PreviewImageOptions {
        /**
         * 需要基础库： `2.13.0`
         *
         * `origin`: 发送完整的referrer; `no-referrer`: 不发送。格式固定为 `https://servicewechat.com/{appid}/{version}/page-frame.html`，其中 {appid} 为小程序的 appid，{version} 为小程序的版本号，版本号为 0 表示为开发版、体验版以及审核版本，版本号为 devtools 表示为开发者工具，其余为正式版本；
         */
        referrerPolicy?: string;
        /**
         * 需要基础库： `2.13.0`
         *
         * 是否显示长按菜单。
         */
        showmenu?: boolean;
    }

    interface SaveImageToPhotosAlbumResult {
        /** 错误信息 */
        errMsg?: string;
    }

    interface ScanCodeSuccessRes {
        /** 原始数据，base64编码 */
        rawData?: string;
        errMsg?: string;
    }

    interface SetStorageOptions {
        /**
         * 需要基础库： `2.21.3`
         *
         * 是否开启加密存储。只有异步的 setStorage 接口支持开启加密存储。开启后，将会对 data 使用 AES128 加密，接口回调耗时将会增加。若开启加密存储，setStorage 和 getStorage 需要同时声明 encrypt 的值为 true。此外，由于加密后的数据会比原始数据膨胀1.4倍，因此开启 encrypt 的情况下，单个 key 允许存储的最大数据长度为 0.7MB，所有数据存储上限为 7.1MB
         */
        encrypt?: boolean;
    }

    interface ShowActionSheetRes {
        errMsg?: string;
    }

    interface ShowModalRes {
        errMsg?: string;
    }

    interface StartBeaconDiscoveryOptions {
        /** 是否校验蓝牙开关，仅在 iOS 下有效。iOS 11 起，控制面板里关掉蓝牙，还是能继续使用 Beacon 服务。 */
        ignoreBluetoothAvailable?: boolean;
    }

    interface StartBluetoothDevicesDiscoveryOptions {
        /**
         * 扫描模式，越高扫描越快，也越耗电。仅安卓微信客户端 7.0.12 及以上支持。
         *
         * 可选值：
         * - 'low': 低;
         * - 'medium': 中;
         * - 'high': 高;
         */
        powerLevel?: "low" | "medium" | "high";
    }

    interface VibrateShortOptions {
        /**
         * 需要基础库： `2.13.0`
         *
         * 震动强度类型，有效值为：heavy、medium、light
         */
        type?: string;
    }

    interface WriteBLECharacteristicValueOptions {
        /**
         * 蓝牙特征值的写模式设置，有两种模式，iOS 优先 write，安卓优先 writeNoResponse 。（基础库 2.22.0 开始支持）
         *
         * 可选值：
         * - 'write': 强制回复写，不支持时报错;
         * - 'writeNoResponse': 强制无回复写，不支持时报错;
         */
        writeType?: "write" | "writeNoResponse";
    }

    /**
     * 小程序账号信息
     */
    interface MiniProgram {
        /**
         * 小程序 appId
         */
        appId: string;
        /**
         * 需要基础库： `2.10.0`
         *
         * 小程序版本
         *
         * 可选值：
         * - 'develop': 开发版;
         * - 'trial': 体验版;
         * - 'release': 正式版;
         */
        envVersion: "develop" | "trial" | "release";
        /**
         * 需要基础库： `2.10.2`
         *
         * 线上小程序版本号
         */
        version: string;
    }

    /**
     * 插件账号信息（仅在插件中调用时包含这一项）
     */
    interface Plugin {
        /**
         * 插件 appId
         */
        appId: string;
        /**
         * 插件版本号
         */
        version: string;
    }

    /**
     * 账号信息
     */
    interface AccountInfo {
        /**
         * 小程序账号信息
         */
        miniProgram: MiniProgram;
        /**
         * 插件账号信息（仅在插件中调用时包含这一项）
         */
        plugin: Plugin;
    }

    interface GetBatteryInfoSyncResult {
        /**
         * 是否正在充电中
         */
        isCharging: boolean;
        /**
         * 需要基础库： `3.5.0`
         *
         * 是否处于省电模式
         */
        isLowPowerModeEnabled: boolean;
        /**
         * 设备电量，范围 1 - 100
         */
        level: number;
    }

    /**
     * 当前运行环境对于 [Skyline 渲染引擎](https://developers.weixin.qq.com/miniprogram/dev/framework/runtime/skyline/introduction.html) 的支持情况
     */
    interface SkylineInfo {
        /**
         * 当前运行环境是否支持 [Skyline 渲染引擎](https://developers.weixin.qq.com/miniprogram/dev/framework/runtime/skyline/introduction.html)
         */
        isSupported: boolean;
        /**
         * 当前运行环境 [Skyline 渲染引擎](https://developers.weixin.qq.com/miniprogram/dev/framework/runtime/skyline/introduction.html) 的版本号，形如 `0.9.7`
         */
        version: string;
        /**
         * 当前运行环境不支持 [Skyline 渲染引擎](https://developers.weixin.qq.com/miniprogram/dev/framework/runtime/skyline/introduction.html) 的原因，仅在 `isSupported` 为 `false` 时出现
         *
         * 可选值：
         * - 'client not supported': 当前微信客户端不支持 [Skyline 渲染引擎](https://developers.weixin.qq.com/miniprogram/dev/framework/runtime/skyline/introduction.html)，可以尝试通过升级微信客户端解决;
         * - 'baselib not supported': 当前基础库不支持 [Skyline 渲染引擎](https://developers.weixin.qq.com/miniprogram/dev/framework/runtime/skyline/introduction.html)，基础库会自动更新到当前客户端所能支持的最新的版本，基础库不支持时也可以尝试通过升级微信客户端解决;
         * - 'a-b test not enabled': 命中了 _We 分析_ 平台上的 AB 实验关闭的情况。详细可以查看 [Skyline 起步 > 配置 We 分析 AB 实验]((skyline/migration#%E9%85%8D%E7%BD%AE-We-%E5%88%86%E6%9E%90-AB-%E5%AE%9E%E9%AA%8C)) 一节;
         * - 'SwitchRender option set to webview': 本地调试的快捷切换入口被设置为了强制使用 Webview. 详情可以查看 [Skyline 起步 > 快捷切换入口](#) 一节;
         */
        reason?: "client not supported" | "baselib not supported" | "a-b test not enabled" | "SwitchRender option set to webview";
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type GetRendererUserAgentCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type GetRendererUserAgentFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type GetRendererUserAgentSuccessCallback = (
                /** UserAgent */
                userAgent: string
            ) => void;

    interface GetRendererUserAgentOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: GetRendererUserAgentCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: GetRendererUserAgentFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: GetRendererUserAgentSuccessCallback;
    }

    /**
     * 额外的缓存处理
     */
    interface ExtraOption {
        /**
         * 需要缓存的 wx api 接口，不传则表示支持缓存的接口全都做缓存处理。返回的如果是缓存数据，开发者可通过 fromCache 标记区分
         *
         * 可选值：
         * - 'wx.login': ;
         * - 'wx.checkSession': ;
         * - 'wx.getSetting': ;
         */
        apiList?: ("wx.login" | "wx.checkSession" | "wx.getSetting")[];
    }

    interface CreateCacheManagerOption {
        /**
         * 额外的缓存处理
         */
        extra?: ExtraOption;
        /**
         * 全局缓存有效时间，单位为毫秒，默认为 7 天，最长不超过 30 天
         */
        maxAge?: number;
        /**
         * 缓存模式
         *
         * 可选值：
         * - 'weakNetwork': 弱网/离线使用缓存返回;
         * - 'always': 总是使用缓存返回;
         * - 'none': 不开启，后续可手动开启/停止使用缓存返回;
         */
        mode?: "weakNetwork" | "always" | "none";
        /**
         * 全局 origin
         */
        origin?: string;
    }

    /**
     * 匹配到的缓存
     */
    interface MatchCache {
        /**
         * 缓存 id
         */
        cacheId: string;
        /**
         * 缓存创建时间
         */
        createTime: number;
        /**
         * 缓存内容，会带有 fromCache 标记，方便开发者区分内容是否来自缓存
         */
        data: any;
        /**
         * 缓存有效时间
         */
        maxAge: number;
        /**
         * 命中的规则 id
         */
        ruleId: string;
    }

    /**
     * 需要基础库： `2.24.0`
     *
     * 缓存管理器。全局只有唯一实例，一旦被创建出来即表示接入缓存管理器。其有以下几个能力：
     *
     * 1. 在网络通畅时，符合一定规则的用户网络请求（目前只包括普通 wx.request 请求）会被缓存。
     * 2. 在网络通畅时，某些 wx api 调用会被缓存。
     * 3. 进入弱网/离线状态时，会提供事件给用户，用户可以决定是否使用缓存返回。
     * 4. 提供进入和退出弱网/离线状态的事件。
     *
     * > 1. 缓存管理器中涉及的网络请求如无特指，均指普通的 wx.request 异步请求，参数和返回值中均不考虑涉及 ArrayBuffer 或 TypedArray 的情形。
     * > 2. 缓存管理器中的缓存不会占用 storage 空间，但是有大小限制，请勿在非必要的请求上使用缓存。
     */
    interface CacheManager {
        /**
         * 全局缓存有效时间
         */
        maxAge: number;
        /**
         * 当前缓存模式
         *
         * 可选值：
         * - 'weakNetwork': 默认值，弱网/离线使用缓存返回;
         * - 'always': 总是使用缓存返回;
         * - 'none': 不开启，后续可手动开启/停止使用缓存返回;
         */
        mode: "weakNetwork" | "always" | "none";
        /**
         * 全局 origin
         */
        origin: string;
        /**
         * 当前缓存管理器状态
         *
         * 可选值：
         * - 0: 不使用缓存返回;
         * - 1: 使用缓存返回;
         * - 2: 未知;
         */
        state: 0 | 1 | 2;
        /**
         *
         * 需要基础库： `2.24.0`
         *
         * 在插件中使用：不支持
         *
         * 批量添加规则，规则写法可参考 [CacheManager.addRule](https://developers.weixin.qq.com/miniprogram/dev/api/storage/cachemanager/CacheManager.addRule.html)。
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/storage/cachemanager/CacheManager.addRules.html](https://developers.weixin.qq.com/miniprogram/dev/api/storage/cachemanager/CacheManager.addRules.html)
         */
        addRules(rules: (string | RegExp | Record<string, any>)[]): string[];
        /**
         *
         * 需要基础库： `2.24.0`
         *
         * 在插件中使用：不支持
         *
         * 清空所有缓存。
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/storage/cachemanager/CacheManager.clearCaches.html](https://developers.weixin.qq.com/miniprogram/dev/api/storage/cachemanager/CacheManager.clearCaches.html)
         */
        clearCaches(): void;
        /**
         *
         * 需要基础库： `2.24.0`
         *
         * 在插件中使用：不支持
         *
         * 清空所有规则，同时会删除对应规则下所有缓存。
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/storage/cachemanager/CacheManager.clearRules.html](https://developers.weixin.qq.com/miniprogram/dev/api/storage/cachemanager/CacheManager.clearRules.html)
         */
        clearRules(): void;
        /**
         *
         * 需要基础库： `2.24.0`
         *
         * 在插件中使用：不支持
         *
         * 删除缓存。
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/storage/cachemanager/CacheManager.deleteCache.html](https://developers.weixin.qq.com/miniprogram/dev/api/storage/cachemanager/CacheManager.deleteCache.html)
         */
        deleteCache(id: string): void;
        /**
         *
         * 需要基础库： `2.24.0`
         *
         * 在插件中使用：不支持
         *
         * 批量删除缓存。
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/storage/cachemanager/CacheManager.deleteCaches.html](https://developers.weixin.qq.com/miniprogram/dev/api/storage/cachemanager/CacheManager.deleteCaches.html)
         */
        deleteCaches(ids: string[]): void;
        /**
         *
         * 需要基础库： `2.24.0`
         *
         * 在插件中使用：不支持
         *
         * 删除规则，同时会删除对应规则下所有缓存。
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/storage/cachemanager/CacheManager.deleteRule.html](https://developers.weixin.qq.com/miniprogram/dev/api/storage/cachemanager/CacheManager.deleteRule.html)
         */
        deleteRule(id: string): void;
        /**
         *
         * 需要基础库： `2.24.0`
         *
         * 在插件中使用：不支持
         *
         * 批量删除规则，同时会删除对应规则下所有缓存。
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/storage/cachemanager/CacheManager.deleteRules.html](https://developers.weixin.qq.com/miniprogram/dev/api/storage/cachemanager/CacheManager.deleteRules.html)
         */
        deleteRules(ids: string[]): void;
        /**
         *
         * 需要基础库： `2.24.0`
         *
         * 在插件中使用：不支持
         *
         * 取消事件监听。
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/storage/cachemanager/CacheManager.off.html](https://developers.weixin.qq.com/miniprogram/dev/api/storage/cachemanager/CacheManager.off.html)
         */
        off(eventName: string, handler: (...args: any[]) => any): void;
        /**
         *
         * 需要基础库： `2.24.0`
         *
         * 在插件中使用：不支持
         *
         * 监听事件。
         *
         * ****
         *
         * 这里 request 事件会提供 request 事件对象，用于做后续的处理；在 request 事件中需要返回一个 promise，用来生成 wx.request 请求的返回内容。
         * 这次 request 所返回的请求结果默认不会写入缓存中。如需写入缓存，可以传入参数 `request({ needUpdateCache: true })`
         *
         * #### 示例代码
         *
         * ```js
         * async function handler(evt) {
         * // evt.url - 请求 url
         * // evt.data - 请求参数
         * // evt.method - 请求方法
         * // evt.request - 原始 request 方法，返回一个 promise
         *
         * // if (evt.url === '/xxx') {
         * //   // 如果有些请求仍然希望走到网络，则可以如下处理
         * //   const res = await evt.request()
         * //   // res 即为网络请求返回
         * // }
         *
         * return new Promsie((resolve, reject) => {
         * // do sth
         * if (data) {
         * // 这里 resolve 的 data 就会作为 wx.request 的 success 回调结果返回
         * resolve(data)
         * } else {
         * // 这里 reject 的错误信息就会作为 wx.request 的 fail 回调结果返回
         * reject('no data')
         * }
         * })
         * }
         * cacheManager.on('request', handler)
         * ```
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/storage/cachemanager/CacheManager.on.html](https://developers.weixin.qq.com/miniprogram/dev/api/storage/cachemanager/CacheManager.on.html)
         */
        on(eventName: "request" | "enterWeakNetwork" | "exitWeakNetwork", handler: (...args: any[]) => any): void;
        /**
         *
         * 需要基础库： `2.24.0`
         *
         * 在插件中使用：不支持
         *
         * 开启缓存，仅在 mode 为 none 时生效，调用后缓存管理器的 state 会置为 1。
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/storage/cachemanager/CacheManager.start.html](https://developers.weixin.qq.com/miniprogram/dev/api/storage/cachemanager/CacheManager.start.html)
         */
        start(): void;
        /**
         *
         * 需要基础库： `2.24.0`
         *
         * 在插件中使用：不支持
         *
         * 关闭缓存，仅在 mode 为 none 时生效，调用后缓存管理器的 state 会置为 0。
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/storage/cachemanager/CacheManager.stop.html](https://developers.weixin.qq.com/miniprogram/dev/api/storage/cachemanager/CacheManager.stop.html)
         */
        stop(): void;
        /**
         *
         * 需要基础库： `2.24.0`
         *
         * 在插件中使用：不支持
         *
         * 匹配命中的缓存规则，一般需要和 request 事件搭配使用。
         *
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/storage/cachemanager/CacheManager.match.html](https://developers.weixin.qq.com/miniprogram/dev/api/storage/cachemanager/CacheManager.match.html)
         */
        match(evt: any): MatchCache;
        /**
         *
         * 需要基础库： `2.24.0`
         *
         * 在插件中使用：不支持
         *
         * 添加规则。
         *
         * **规则说明**
         *
         * 支持的规则写法有字符串、正则和对象三种：
         *
         * ### 字符串写法
         *
         * 1. `addRule('/abc')`：纯 uri 串。
         * 2. `addRule('GET /abc')：带方法的 uri 串，除了匹配 uri 外，还会匹配请求方法。如例子中必须是 GET 方法请求才会被匹配。
         * 3. `addRule('/abc/:id')：带可变部分的 uri 串，id 可以是任意符合标准的字符串，表示这一段可以动态变化。比如 `/abc/123` 和 `/abc/321` 都会被匹配，而 `/abc/123/xxx` 因为多了一段，就不会被匹配。
         * 4. `addRule('/abc?aa')：带 query 参数的 uri 串，包含 aa 参数，值可以为任意值。比如 `/abc?aa=haha` 会被匹配，但是 `/abc` 就不会被匹配，因为缺少规则中声明的 aa 参数；不过如果请求是 `/abc?aa=haha&bb=123`，虽然多带了 bb 参数，但是因为包含了 aa 参数，所以也可以被匹配。
         * 5. `addRule('/abc?dd=haha')：带 query 参数的 uri 串，包含 dd 参数且值为 haha。比如 `/abc?dd=haha` 和 `/abc?dd=haha&bb=123` 会被匹配，而 `/abc?dd=123` 就不会被匹配，因为规则要求了 dd 参数的值。
         *
         * > 以上写法中的 uri 串如果只有 path 部分，则会取全局 origin 进行补全。比如全局 origin 是 `https://weixin.qq.com`，而规则是 `/abc`，则会补全为 `https://weixin.qq.com/abc`。因此在前面例子中 `addRule('/abc')` 和 `addRule('https://weixin.qq.com/abc')` 的写法效果一致。所以一般情况下如果需要匹配的请求 origin 和全局 origin 一致，则规则中可忽略不写 orign。
         *
         * ### 正则写法
         *
         * 1. `addRule(/\/(abc|cba)$/ig)`：直接正则匹配请求的 uri，同时会比对请求 origin 和全局 origin 是否一致。
         * 2. `addRule(/^https:\/\/weixin.qq.com\/(abc|cba)$/ig)`：带有 orign 部分的正则表达式，则只匹配 uri，不再比对 origin。
         *
         * ### 对象写法
         *
         * 使用规则对象，可以更为详细的描述规则内容。（一般使用规则对象，是为了匹配请求参数）
         *
         * #### 规则对象：
         *
         * | 属性名 | 类型 | 默认值 | 备注 |
         * |---|---|---|---|
         * | id | string | | 规则 id，如果不填则会由基础库生成 |
         * | method | string | | 请求方法，可选值 GET/POST/PATCH/PUT/DELETE，如果为空则表示前面提到的所有方法都能被匹配到 |
         * | url | any | 必填 | uri 匹配规则，可参考规则字符串写法和正则写法 |
         * | maxAge | number | 7 * 24 * 60 * 60 * 1000 | 缓存有效时间，单位为 ms，不填则默认取缓存管理器全局的缓存有效时间 |
         * | dataSchema | Array\<DataRule\> | | 匹配请求参数 |
         *
         * 其中，dataSchema 用来匹配对象类型的请求参数（比如 wx.request 的 data），默认可以不填，即不做参数匹配。
         *
         * dataSchema 的类型是一个 DataRule 对象数组，一个 DataRule 对象描述一个参数，比如一个 wx.request 请求的 data 是 `{a: 123, b: 'haha', c: true}`，你想要用一条规则来匹配其中的 a 和 b 参数，如果 a 是数字且 b 是字符串就能命中该规则，那么就需要在 dataSchema 中补充两个 DataRule 对象，即 `[{name: 'a', schema: {type: 'number'}}, {name: 'b', schema: {type: 'string'}}]`。
         *
         * #### DataRule 对象：
         *
         * | 属性名 | 类型 | 默认值 | 备注 |
         * |---|---|---|---|
         * | name | string | | 需要匹配的参数名 |
         * | schema | DataSchema/Array\<DataSchema\> | 需要匹配的参数模式，支持数组，表示该参数值有多种模式 |
         *
         * name 表示要匹配的参数名，schema 为 DataSchema 对象，用来描述该参数的类型和值。
         *
         * 一个 DataRule 对象也可以匹配可能拥有多种类型的参数，所以 schema 也支持为 DataSchema 对象数组。比如上述例子中，希望匹配的 a 参数必须是数值或者字符串，那么可以这么写：`{name: 'a', schema: [{type: 'number'}, {type: 'string'}]}`。
         *
         * #### DataSchema 对象：
         *
         * | 属性名 | 类型 | 默认值 | 备注 |
         * |---|---|---|---|
         * | type | string | | 需要匹配的 data 对象的参数类型，string、number、boolean、null、object、any（表示任意类型），同时支持数组模式（数组模式则在类型后面加 []，如 string[] 表示字符串数组） |
         * | value | string/regexp/function/Array\<DataRule\> | | 需要匹配的 data 对象的参数值，当 type 为基本类型时，可以用 string/regexp 来匹配固定的值，也可以通过 function 来确定值是否匹配，如果传入的 type 是 object，那么表示需要嵌套匹配值是否正确，可以传入 Array<DataRule> |
         *
         * type 参数表示要匹配的参数类型，value 表示要匹配的参数值。其中 value 支持多种写法，不同写法有如下匹配方式：
         *
         * 1. 字符串写法：直接判值的字符串形式是否和给定字符串一样，比如 value 值为 `123`，就要求参数值必须为 123 才能与之匹配。
         * 2. 正则写法：直接判值的字符串形式是否能被正则匹配，比如 value 值为 `/\d+/ig`，就要求参数值必须为数字，如果参数值为 `abc` 则不会被匹配。
         * 3. 函数写法：在匹配时会调用用户传入的函数，交由用户判断是否匹配。
         * 4. DataRule 数组写法：当参数类型为对象时，那么字符串写法和正则写法就无法使用，需要传入 DataRule 数组来进行匹配，即通过嵌套 DataRule 数组的方式来匹配嵌套的对象。
         *
         * ### 示例代码
         *
         * ```js
         * const ruleId = cacheManager.addRule({
         * id: 'haha-rule',
         * method: 'GET',
         * url: '/haha',
         * maxAge: 123455,
         * dataSchema: [
         * // data 字段的匹配，默认为空，表示不匹配
         * // 类型可以是：string、number、boolean、null、object、any（表示任意类型均可），以及这些类型的数组表示方式
         * {name: 'aaa', schema: {type: 'string'}}, // 类型为 string
         * {name: 'bbb', schema: [{type: 'number'}, {type: 'string'}]}, // 类型为 number, string
         * {name: 'ccc', schema: {type: 'string', value: 'abc'}}, // 值为 abc
         * {name: 'ddd', schema: {type: 'string', value: /(abc|cba)/ig}}, // 值符合该正则匹配，如果该值不是字符串类型，则会被尝试转成字符串后再进行比较
         * {name: 'ddd', schema: {type: 'string', value: val => val === '123'}}, // 传入函数来校验值
         * {name: 'eee', schema: {type: 'object', value: [{ // 类型为对象，则通过嵌套的方式来逐层校验
         * name: 'aaa', schema: {type: 'string'},
         * // ...
         * // 嵌套 dataSchema，同上面的方式一样来匹配嵌套的对象
         * }]}},
         * {name: 'fff', schema: {type: 'string[]'}}, // 类型为 string 数组
         * {name: 'ggg', schema: {type: 'any'}}, // 类型为任意类型
         * {name: 'hhh', schema: {type: 'any[]'}}, // 类型为任意类型的数组
         * }],
         * })
         * ```
         *
         * ### 补充说明
         *
         * 用户可以添加多条规则，每条规则都会去解析网络请求，然后判断是否命中规则。假设有多条规则命中，则取第一条命中的规则。
         *
         * ### 缓存覆盖
         *
         * 不同的网络请求也可能命中同一条规则，所以每条规则可能对应多个缓存。每条规则会有一个规则 id，每个缓存会有一个缓存 id，一个规则 id 可能对应多个缓存 id，而缓存管理器的缓存存储是基于缓存 id 标识的，如果两个不同的请求生成了同样的缓存 id，那么后发生的请求结果缓存会覆盖前者。因此使用时需要思考缓存的覆盖情况，目前缓存 id 生成方式如下：
         *
         * 1. 规则使用字符串写法：那么按 method + url + 规则中声明的 query 参数来生成缓存 id。
         *
         * > 需要注意的是这里不使用真实请求中的 query 参数来生成缓存 id，而是使用规则中匹配到的 query 来生成缓存 id。比如规则是 `/abc?aa=123`，请求是 GET 方法的 `/abc?aa=123&bb=123`，那么就会基于 `GET /abc?aa=123` 来生成缓存 id。而规则里没有声明 `bb=123`，所以 bb 参数不会被纳入缓存 id 的生成基准。
         *
         * 2. 规则使用正则写法：那么只按 method + url 生成缓存 id，不考虑 query 参数。
         * 3. 规则使用对象写法：如果规则对象中的 url 是字符串写法，那么按 method + url + 规则中声明的 query 参数 + 规则中 dataSchema 声明的请求参数来生成缓存 id；如果规则对象中的 url 是正则写法，那么按 method + url + 规则中 dataSchema 声明的请求参数来生成缓存 id。
         *
         * > 生成缓存 id 时没有使用请求中完整的 query 参数或者请求参数来作为基准，是考虑到很多请求可能会带上 token 或时间戳等参数。因为此参数存在不确定性，会导致每次请求生成的缓存 id 都不同，进而导致缓存命中率下降，故采取规则中声明的 query 参数和 dataSchema 声明的请求参数来作为生成缓存 id 的基准。
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/storage/cachemanager/CacheManager.addRule.html](https://developers.weixin.qq.com/miniprogram/dev/api/storage/cachemanager/CacheManager.addRule.html)
         */
        addRule(rule: string | RegExp | Record<string, any>): string;
    }

    interface ReadCompressedFileSyncOption {
        /**
         * 文件压缩类型，目前仅支持 'br'。
         *
         * 可选值：
         * - 'br': brotli压缩文件;
         */
        compressionAlgorithm: "br";
        /**
         * 要读取的文件的路径 (本地用户文件或代码包文件)
         */
        filePath: string;
    }

    interface FileError {
        /**
         * 错误信息
         *
         * | 错误码 | 错误信息 | 说明 |
         * | - | - | - |
         * | 1300001 | operation not permitted | 操作不被允许（例如，filePath 预期传入一个文件而实际传入一个目录） |
         * | 1300002 | no such file or directory ${path} | 文件/目录不存在，或者目标文件路径的上层目录不存在 |
         * | 1300005 | Input/output error | 输入输出流不可用 |
         * | 1300009 | bad file descriptor | 无效的文件描述符 |
         * | 1300013 | permission denied | 权限错误，文件是只读或只写 |
         * | 1300014 | Path permission denied | 传入的路径没有权限 |
         * | 1300020 | not a directory | dirPath 指定路径不是目录，常见于指定的写入路径的上级路径为一个文件的情况 |
         * | 1300021 | Is a directory | 指定路径是一个目录 |
         * | 1300022 | Invalid argument | 无效参数，可以检查length或offset是否越界 |
         * | 1300036 | File name too long | 文件名过长 |
         * | 1300066 | directory not empty | 目录不为空 |
         * | 1300201 | system error | 系统接口调用失败 |
         * | 1300202 | the maximum size of the file storage limit is exceeded | 存储空间不足，或文件大小超出上限（上限100M） |
         * | 1300203 | base64 encode error | 字符编码转换失败（例如 base64 格式错误） |
         * | 1300300 | sdcard not mounted | android sdcard 挂载失败 |
         * | 1300301 | unable to open as fileType | 无法以fileType打开文件 |
         * | 1301000 | permission denied, cannot access file path | 目标路径无访问权限（usr目录） |
         * | 1301002 | data to write is empty | 写入数据为空 |
         * | 1301003 | illegal operation on a directory | 不可对目录进行此操作（例如，指定的 filePath 是一个已经存在的目录） |
         * | 1301004 | illegal operation on a package directory | 不可对代码包目录进行此操作 |
         * | 1301005 | file already exists ${dirPath} | 已有同名文件或目录 |
         * | 1301006 | value of length is out of range | 传入的 length 不合法 |
         * | 1301007 | value of offset is out of range | 传入的 offset 不合法 |
         * | 1301009 | value of position is out of range | position值越界 |
         * | 1301100 | store directory is empty | store目录为空 |
         * | 1301102 | unzip open file fail | 压缩文件打开失败 |
         * | 1301103 | unzip entry fail | 解压单个文件失败 |
         * | 1301104 | unzip fail | 解压失败 |
         * | 1301111 | brotli decompress fail | brotli解压失败（例如，指定的 compressionAlgorithm 与文件实际压缩格式不符） |
         * | 1301112 | tempFilePath file not exist | 指定的 tempFilePath 找不到文件 |
         * | 1302001 | fail permission denied | 指定的 fd 路径没有读权限/没有写权限 |
         * | 1302002 | excced max concurrent fd limit | fd数量已达上限 |
         * | 1302003 | invalid flag | 无效的flag |
         * | 1302004 | permission denied when open using flag | 无法使用flag标志打开文件 |
         * | 1302005 | array buffer does not exist | 未传入arrayBuffer |
         * | 1302100 | array buffer is readonly | arrayBuffer只读 |
         */
        errMsg: string;
        /**
         * 错误码
         *
         * | 错误码 | 错误信息 | 说明 |
         * | - | - | - |
         * | 1300001 | operation not permitted | 操作不被允许（例如，filePath 预期传入一个文件而实际传入一个目录） |
         * | 1300002 | no such file or directory ${path} | 文件/目录不存在，或者目标文件路径的上层目录不存在 |
         * | 1300005 | Input/output error | 输入输出流不可用 |
         * | 1300009 | bad file descriptor | 无效的文件描述符 |
         * | 1300013 | permission denied | 权限错误，文件是只读或只写 |
         * | 1300014 | Path permission denied | 传入的路径没有权限 |
         * | 1300020 | not a directory | dirPath 指定路径不是目录，常见于指定的写入路径的上级路径为一个文件的情况 |
         * | 1300021 | Is a directory | 指定路径是一个目录 |
         * | 1300022 | Invalid argument | 无效参数，可以检查length或offset是否越界 |
         * | 1300036 | File name too long | 文件名过长 |
         * | 1300066 | directory not empty | 目录不为空 |
         * | 1300201 | system error | 系统接口调用失败 |
         * | 1300202 | the maximum size of the file storage limit is exceeded | 存储空间不足，或文件大小超出上限（上限100M） |
         * | 1300203 | base64 encode error | 字符编码转换失败（例如 base64 格式错误） |
         * | 1300300 | sdcard not mounted | android sdcard 挂载失败 |
         * | 1300301 | unable to open as fileType | 无法以fileType打开文件 |
         * | 1301000 | permission denied, cannot access file path | 目标路径无访问权限（usr目录） |
         * | 1301002 | data to write is empty | 写入数据为空 |
         * | 1301003 | illegal operation on a directory | 不可对目录进行此操作（例如，指定的 filePath 是一个已经存在的目录） |
         * | 1301004 | illegal operation on a package directory | 不可对代码包目录进行此操作 |
         * | 1301005 | file already exists ${dirPath} | 已有同名文件或目录 |
         * | 1301006 | value of length is out of range | 传入的 length 不合法 |
         * | 1301007 | value of offset is out of range | 传入的 offset 不合法 |
         * | 1301009 | value of position is out of range | position值越界 |
         * | 1301100 | store directory is empty | store目录为空 |
         * | 1301102 | unzip open file fail | 压缩文件打开失败 |
         * | 1301103 | unzip entry fail | 解压单个文件失败 |
         * | 1301104 | unzip fail | 解压失败 |
         * | 1301111 | brotli decompress fail | brotli解压失败（例如，指定的 compressionAlgorithm 与文件实际压缩格式不符） |
         * | 1301112 | tempFilePath file not exist | 指定的 tempFilePath 找不到文件 |
         * | 1302001 | fail permission denied | 指定的 fd 路径没有读权限/没有写权限 |
         * | 1302002 | excced max concurrent fd limit | fd数量已达上限 |
         * | 1302003 | invalid flag | 无效的flag |
         * | 1302004 | permission denied when open using flag | 无法使用flag标志打开文件 |
         * | 1302005 | array buffer does not exist | 未传入arrayBuffer |
         * | 1302100 | array buffer is readonly | arrayBuffer只读 |
         */
        errCode: number;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type AccessCompleteCallback = (res: FileError) => void;
    /**
     * 接口调用失败的回调函数
     */
    type AccessFailCallback = (res: FileError) => void;
    /**
     * 接口调用成功的回调函数
     */
    type AccessSuccessCallback = (res: FileError) => void;

    interface AccessOption {
        /**
         * 要判断是否存在的文件/目录路径 (本地路径)
         */
        path: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: AccessCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: AccessFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: AccessSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type AppendFileCompleteCallback = (res: FileError) => void;
    /**
     * 接口调用失败的回调函数
     */
    type AppendFileFailCallback = (res: FileError) => void;
    /**
     * 接口调用成功的回调函数
     */
    type AppendFileSuccessCallback = (res: FileError) => void;

    interface AppendFileOption {
        /**
         * 要追加的文本或二进制数据
         */
        data: string | ArrayBuffer;
        /**
         * 要追加内容的文件路径 (本地路径)
         */
        filePath: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: AppendFileCompleteCallback;
        /**
         * 指定写入文件的字符编码
         *
         * 可选值：
         * - 'ascii': ;
         * - 'base64': ;
         * - 'binary': ;
         * - 'hex': ;
         * - 'ucs2': 以小端序读取;
         * - 'ucs-2': 以小端序读取;
         * - 'utf16le': 以小端序读取;
         * - 'utf-16le': 以小端序读取;
         * - 'utf-8': ;
         * - 'utf8': ;
         * - 'latin1': ;
         */
        encoding?: "ascii" | "base64" | "binary" | "hex" | "ucs2" | "ucs-2" | "utf16le" | "utf-16le" | "utf-8" | "utf8" | "latin1";
        /**
         * 接口调用失败的回调函数
         */
        fail?: AppendFileFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: AppendFileSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type FileSystemManagerCloseCompleteCallback = (res: FileError) => void;
    /**
     * 接口调用失败的回调函数
     */
    type FileSystemManagerCloseFailCallback = (res: FileError) => void;
    /**
     * 接口调用成功的回调函数
     */
    type FileSystemManagerCloseSuccessCallback = (res: FileError) => void;

    interface FileSystemManagerCloseOption {
        /**
         * 需要被关闭的文件描述符。fd 通过 [FileSystemManager.open](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.open.html) 或 [FileSystemManager.openSync](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.openSync.html) 接口获得
         */
        fd: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: FileSystemManagerCloseCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: FileSystemManagerCloseFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: FileSystemManagerCloseSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type CopyFileCompleteCallback = (res: FileError) => void;
    /**
     * 接口调用失败的回调函数
     */
    type CopyFileFailCallback = (res: FileError) => void;
    /**
     * 接口调用成功的回调函数
     */
    type CopyFileSuccessCallback = (res: FileError) => void;

    interface CopyFileOption {
        /**
         * 目标文件路径，支持本地路径
         */
        destPath: string;
        /**
         * 源文件路径，支持本地路径
         */
        srcPath: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: CopyFileCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: CopyFileFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: CopyFileSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type FstatCompleteCallback = (res: FileError) => void;
    /**
     * 接口调用失败的回调函数
     */
    type FstatFailCallback = (res: FileError) => void;

    /**
     * 描述文件状态的对象
     */
    interface Stats {
        /**
         * 文件最近一次被存取或被执行的时间，UNIX 时间戳，对应 POSIX stat.st_atime
         */
        lastAccessedTime: number;
        /**
         * 文件最后一次被修改的时间，UNIX 时间戳，对应 POSIX stat.st_mtime
         */
        lastModifiedTime: number;
        /**
         * 文件的类型和存取的权限，对应 POSIX stat.st_mode
         */
        mode: number;
        /**
         * 文件大小，单位：B，对应 POSIX stat.st_size
         */
        size: number;
        /**
         *
         * 在插件中使用：需要基础库 `2.19.2`
         *
         * 判断当前文件是否一个目录
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/file/Stats.isDirectory.html](https://developers.weixin.qq.com/miniprogram/dev/api/file/Stats.isDirectory.html)
         */
        isDirectory(): boolean;
        /**
         *
         * 在插件中使用：需要基础库 `2.19.2`
         *
         * 判断当前文件是否一个普通文件
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/file/Stats.isFile.html](https://developers.weixin.qq.com/miniprogram/dev/api/file/Stats.isFile.html)
         */
        isFile(): boolean;
    }

    interface FstatSuccessCallbackResult {
        /**
         *
         * Stats 对象，包含了文件的状态信息
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/file/Stats.html](https://developers.weixin.qq.com/miniprogram/dev/api/file/Stats.html)
         */
        stats: Stats;
        errMsg: string;
    }

    /**
     * 接口调用成功的回调函数
     */
    type FstatSuccessCallback = (result: FstatSuccessCallbackResult) => void;

    interface FstatOption {
        /**
         * 文件描述符。fd 通过 [FileSystemManager.open](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.open.html) 或 [FileSystemManager.openSync](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.openSync.html) 接口获得
         */
        fd: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: FstatCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: FstatFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: FstatSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type FtruncateCompleteCallback = (res: FileError) => void;
    /**
     * 接口调用失败的回调函数
     */
    type FtruncateFailCallback = (res: FileError) => void;
    /**
     * 接口调用成功的回调函数
     */
    type FtruncateSuccessCallback = (res: FileError) => void;

    interface FtruncateOption {
        /**
         * 文件描述符。fd 通过 [FileSystemManager.open](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.open.html) 或 [FileSystemManager.openSync](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.openSync.html) 接口获得
         */
        fd: string;
        /**
         * 截断位置，默认0。如果 length 小于文件长度（单位：字节），则只有前面 length 个字节会保留在文件中，其余内容会被删除；如果 length 大于文件长度，则会对其进行扩展，并且扩展部分将填充空字节（'\0'）
         */
        length: number;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: FtruncateCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: FtruncateFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: FtruncateSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type GetFileInfoCompleteCallback = (res: FileError) => void;
    /**
     * 接口调用失败的回调函数
     */
    type GetFileInfoFailCallback = (res: FileError) => void;

    interface GetFileInfoSuccessCallbackResult {
        /**
         * 按照传入的 digestAlgorithm 计算得出的的文件摘要
         */
        digest: string;
        /**
         * 文件大小，以字节为单位
         */
        size: number;
        errMsg: string;
    }

    /**
     * 接口调用成功的回调函数
     */
    type GetFileInfoSuccessCallback = (
                result: GetFileInfoSuccessCallbackResult
            ) => void;

    interface GetFileInfoOption {
        /**
         * 要读取的文件路径 (本地路径)
         */
        filePath: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: GetFileInfoCompleteCallback;
        /**
         * 计算文件摘要的算法
         *
         * 可选值：
         * - 'md5': md5 算法;
         * - 'sha1': sha1 算法;
         * - 'sha256': sha256 算法;
         */
        digestAlgorithm?: "md5" | "sha1" | "sha256";
        /**
         * 接口调用失败的回调函数
         */
        fail?: GetFileInfoFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: GetFileInfoSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type GetSavedFileListCompleteCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用失败的回调函数
     */
    type GetSavedFileListFailCallback = (res: GeneralCallbackResult) => void;

    /**
     * 文件数组
     */
    interface FileItem {
        /**
         * 文件保存时的时间戳，从1970/01/01 08:00:00 到当前时间的秒数
         */
        createTime: number;
        /**
         * 文件路径 (本地路径)
         */
        filePath: string;
        /**
         * 本地文件大小，以字节为单位
         */
        size: number;
    }

    interface GetSavedFileListSuccessCallbackResult {
        /**
         * 文件数组
         */
        fileList: FileItem[];
        errMsg: string;
    }

    /**
     * 接口调用成功的回调函数
     */
    type GetSavedFileListSuccessCallback = (
                result: GetSavedFileListSuccessCallbackResult
            ) => void;

    interface GetSavedFileListOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: GetSavedFileListCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: GetSavedFileListFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: GetSavedFileListSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type MkdirCompleteCallback = (res: FileError) => void;
    /**
     * 接口调用失败的回调函数
     */
    type MkdirFailCallback = (res: FileError) => void;
    /**
     * 接口调用成功的回调函数
     */
    type MkdirSuccessCallback = (res: FileError) => void;

    interface MkdirOption {
        /**
         * 创建的目录路径 (本地路径)
         */
        dirPath: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: MkdirCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: MkdirFailCallback;
        /**
         * 需要基础库： `2.3.0`
         *
         * 是否在递归创建该目录的上级目录后再创建该目录。如果对应的上级目录已经存在，则不创建该上级目录。如 dirPath 为 a/b/c/d 且 recursive 为 true，将创建 a 目录，再在 a 目录下创建 b 目录，以此类推直至创建 a/b/c 目录下的 d 目录。
         */
        recursive?: boolean;
        /**
         * 接口调用成功的回调函数
         */
        success?: MkdirSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type OpenCompleteCallback = (res: FileError) => void;
    /**
     * 接口调用失败的回调函数
     */
    type OpenFailCallback = (res: FileError) => void;

    interface OpenSuccessCallbackResult {
        /**
         * 文件描述符
         */
        fd: string;
        errMsg: string;
    }

    /**
     * 接口调用成功的回调函数
     */
    type OpenSuccessCallback = (result: OpenSuccessCallbackResult) => void;

    interface OpenOption {
        /**
         * 文件路径 (本地路径)
         */
        filePath: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: OpenCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: OpenFailCallback;
        /**
         * 文件系统标志，默认值: 'r'
         *
         * 可选值：
         * - 'a': 打开文件用于追加。 如果文件不存在，则创建该文件;
         * - 'ax': 类似于 'a'，但如果路径存在，则失败;
         * - 'a+': 打开文件用于读取和追加。 如果文件不存在，则创建该文件;
         * - 'ax+': 类似于 'a+'，但如果路径存在，则失败;
         * - 'as': 打开文件用于追加（在同步模式中）。 如果文件不存在，则创建该文件;
         * - 'as+': 打开文件用于读取和追加（在同步模式中）。 如果文件不存在，则创建该文件;
         * - 'r': 打开文件用于读取。 如果文件不存在，则会发生异常;
         * - 'r+': 打开文件用于读取和写入。 如果文件不存在，则会发生异常;
         * - 'w': 打开文件用于写入。 如果文件不存在则创建文件，如果文件存在则截断文件;
         * - 'wx': 类似于 'w'，但如果路径存在，则失败;
         * - 'w+': 打开文件用于读取和写入。 如果文件不存在则创建文件，如果文件存在则截断文件;
         * - 'wx+': 类似于 'w+'，但如果路径存在，则失败;
         */
        flag?: "a" | "ax" | "a+" | "ax+" | "as" | "as+" | "r" | "r+" | "w" | "wx" | "w+" | "wx+";
        /**
         * 接口调用成功的回调函数
         */
        success?: OpenSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type ReadCompleteCallback = (res: FileError) => void;
    /**
     * 接口调用失败的回调函数
     */
    type ReadFailCallback = (res: FileError) => void;

    interface ReadSuccessCallbackResult {
        /**
         * 被写入的缓存区的对象，即接口入参的 arrayBuffer
         */
        arrayBuffer: ArrayBuffer;
        /**
         * 实际读取的字节数
         */
        bytesRead: number;
        errMsg: string;
    }

    /**
     * 接口调用成功的回调函数
     */
    type ReadSuccessCallback = (result: ReadSuccessCallbackResult) => void;

    interface ReadOption {
        /**
         * 数据写入的缓冲区，必须是 ArrayBuffer 实例
         */
        arrayBuffer: ArrayBuffer;
        /**
         * 文件描述符。fd 通过 [FileSystemManager.open](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.open.html) 或 [FileSystemManager.openSync](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.openSync.html) 接口获得
         */
        fd: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: ReadCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: ReadFailCallback;
        /**
         * 要从文件中读取的字节数，默认0
         */
        length?: number;
        /**
         * 缓冲区中的写入偏移量，默认0
         */
        offset?: number;
        /**
         * 文件读取的起始位置，如不传或传 null，则会从当前文件指针的位置读取。如果 position 是正整数，则文件指针位置会保持不变并从 position 读取文件。
         */
        position?: number;
        /**
         * 接口调用成功的回调函数
         */
        success?: ReadSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type ReadCompressedFileCompleteCallback = (res: FileError) => void;
    /**
     * 接口调用失败的回调函数
     */
    type ReadCompressedFileFailCallback = (res: FileError) => void;

    interface ReadCompressedFileSuccessCallbackResult {
        /**
         * 文件内容
         */
        data: ArrayBuffer;
        errMsg: string;
    }

    /**
     * 接口调用成功的回调函数
     */
    type ReadCompressedFileSuccessCallback = (
                result: ReadCompressedFileSuccessCallbackResult
            ) => void;

    interface ReadCompressedFileOption {
        /**
         * 文件压缩类型，目前仅支持 'br'。
         *
         * 可选值：
         * - 'br': brotli压缩文件;
         */
        compressionAlgorithm: "br";
        /**
         * 要读取的文件的路径 (本地用户文件或代码包文件)
         */
        filePath: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: ReadCompressedFileCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: ReadCompressedFileFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: ReadCompressedFileSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type ReadFileCompleteCallback = (res: FileError) => void;
    /**
     * 接口调用失败的回调函数
     */
    type ReadFileFailCallback = (res: FileError) => void;

    interface ReadFileSuccessCallbackResult {
        /**
         * 文件内容
         */
        data: string | ArrayBuffer;
        errMsg: string;
    }

    /**
     * 接口调用成功的回调函数
     */
    type ReadFileSuccessCallback = (
                result: ReadFileSuccessCallbackResult
            ) => void;

    interface ReadFileOption {
        /**
         * 要读取的文件的路径 (本地路径)
         */
        filePath: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: ReadFileCompleteCallback;
        /**
         * 指定读取文件的字符编码，如果不传 encoding，则以 ArrayBuffer 格式读取文件的二进制内容
         *
         * 可选值：
         * - 'ascii': ;
         * - 'base64': ;
         * - 'binary': ;
         * - 'hex': ;
         * - 'ucs2': 以小端序读取;
         * - 'ucs-2': 以小端序读取;
         * - 'utf16le': 以小端序读取;
         * - 'utf-16le': 以小端序读取;
         * - 'utf-8': ;
         * - 'utf8': ;
         * - 'latin1': ;
         */
        encoding?: "ascii" | "base64" | "binary" | "hex" | "ucs2" | "ucs-2" | "utf16le" | "utf-16le" | "utf-8" | "utf8" | "latin1";
        /**
         * 接口调用失败的回调函数
         */
        fail?: ReadFileFailCallback;
        /**
         * 需要基础库： `2.10.0`
         *
         * 指定文件的长度，如果不指定，则读到文件末尾。有效范围：[1, fileLength]。单位：byte
         */
        length?: number;
        /**
         * 需要基础库： `2.10.0`
         *
         * 从文件指定位置开始读，如果不指定，则从文件头开始读。读取的范围应该是左闭右开区间 [position, position+length)。有效范围：[0, fileLength - 1]。单位：byte
         */
        position?: number;
        /**
         * 接口调用成功的回调函数
         */
        success?: ReadFileSuccessCallback;
    }

    /**
     * 要读取的压缩包内的文件列表（当传入"all" 时表示读取压缩包内所有文件）
     */
    interface EntryItem {
        /**
         * 压缩包内文件路径
         */
        path: string;
        /**
         * 指定读取文件的字符编码，如果不传 encoding，则以 ArrayBuffer 格式读取文件的二进制内容
         *
         * 可选值：
         * - 'ascii': ;
         * - 'base64': ;
         * - 'binary': ;
         * - 'hex': ;
         * - 'ucs2': 以小端序读取;
         * - 'ucs-2': 以小端序读取;
         * - 'utf16le': 以小端序读取;
         * - 'utf-16le': 以小端序读取;
         * - 'utf-8': ;
         * - 'utf8': ;
         * - 'latin1': ;
         */
        encoding?: "ascii" | "base64" | "binary" | "hex" | "ucs2" | "ucs-2" | "utf16le" | "utf-16le" | "utf-8" | "utf8" | "latin1";
        /**
         * 指定文件的长度，如果不指定，则读到文件末尾。有效范围：[1, fileLength]。单位：byte
         */
        length?: number;
        /**
         * 从文件指定位置开始读，如果不指定，则从文件头开始读。读取的范围应该是左闭右开区间 [position, position+length)。有效范围：[0, fileLength - 1]。单位：byte
         */
        position?: number;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type ReadZipEntryCompleteCallback = (res: FileError) => void;
    /**
     * 接口调用失败的回调函数
     */
    type ReadZipEntryFailCallback = (res: FileError) => void;

    /**
     * 文件读取结果。res.entries 是一个对象，key是文件路径，value是一个对象 FileItem ，表示该文件的读取结果。每个 FileItem 包含 data （文件内容） 和 errMsg （错误信息） 属性。
     */
    interface EntriesResult {
    }

    interface ReadZipEntrySuccessCallbackResult {
        /**
         * 文件读取结果。res.entries 是一个对象，key是文件路径，value是一个对象 FileItem ，表示该文件的读取结果。每个 FileItem 包含 data （文件内容） 和 errMsg （错误信息） 属性。
         */
        entries: EntriesResult;
        errMsg: string;
    }

    /**
     * 接口调用成功的回调函数
     */
    type ReadZipEntrySuccessCallback = (
                result: ReadZipEntrySuccessCallbackResult
            ) => void;

    interface ReadZipEntryOption {
        /**
         * 要读取的压缩包内的文件列表（当传入"all" 时表示读取压缩包内所有文件）
         */
        entries: EntryItem[] | "all";
        /**
         * 要读取的压缩包的路径 (本地路径)
         */
        filePath: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: ReadZipEntryCompleteCallback;
        /**
         * 统一指定读取文件的字符编码，只在 entries 值为"all"时有效。如果 entries 值为"all"且不传 encoding，则以 ArrayBuffer 格式读取文件的二进制内容
         *
         * 可选值：
         * - 'ascii': ;
         * - 'base64': ;
         * - 'binary': ;
         * - 'hex': ;
         * - 'ucs2': 以小端序读取;
         * - 'ucs-2': 以小端序读取;
         * - 'utf16le': 以小端序读取;
         * - 'utf-16le': 以小端序读取;
         * - 'utf-8': ;
         * - 'utf8': ;
         * - 'latin1': ;
         */
        encoding?: "ascii" | "base64" | "binary" | "hex" | "ucs2" | "ucs-2" | "utf16le" | "utf-16le" | "utf-8" | "utf8" | "latin1";
        /**
         * 接口调用失败的回调函数
         */
        fail?: ReadZipEntryFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: ReadZipEntrySuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type ReaddirCompleteCallback = (res: FileError) => void;
    /**
     * 接口调用失败的回调函数
     */
    type ReaddirFailCallback = (res: FileError) => void;

    interface ReaddirSuccessCallbackResult {
        /**
         * 指定目录下的文件名数组。
         */
        files: string[];
        errMsg: string;
    }

    /**
     * 接口调用成功的回调函数
     */
    type ReaddirSuccessCallback = (result: ReaddirSuccessCallbackResult) => void;

    interface ReaddirOption {
        /**
         * 要读取的目录路径 (本地路径)
         */
        dirPath: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: ReaddirCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: ReaddirFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: ReaddirSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type RemoveSavedFileCompleteCallback = (res: FileError) => void;
    /**
     * 接口调用失败的回调函数
     */
    type RemoveSavedFileFailCallback = (res: FileError) => void;
    /**
     * 接口调用成功的回调函数
     */
    type RemoveSavedFileSuccessCallback = (res: FileError) => void;

    interface RemoveSavedFileOption {
        /**
         * 需要删除的文件路径 (本地路径)
         */
        filePath: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: RemoveSavedFileCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: RemoveSavedFileFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: RemoveSavedFileSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type RenameCompleteCallback = (res: FileError) => void;
    /**
     * 接口调用失败的回调函数
     */
    type RenameFailCallback = (res: FileError) => void;
    /**
     * 接口调用成功的回调函数
     */
    type RenameSuccessCallback = (res: FileError) => void;

    interface RenameOption {
        /**
         * 新文件路径，支持本地路径
         */
        newPath: string;
        /**
         * 源文件路径，支持本地路径
         */
        oldPath: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: RenameCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: RenameFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: RenameSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type RmdirCompleteCallback = (res: FileError) => void;
    /**
     * 接口调用失败的回调函数
     */
    type RmdirFailCallback = (res: FileError) => void;
    /**
     * 接口调用成功的回调函数
     */
    type RmdirSuccessCallback = (res: FileError) => void;

    interface RmdirOption {
        /**
         * 要删除的目录路径 (本地路径)
         */
        dirPath: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: RmdirCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: RmdirFailCallback;
        /**
         * 需要基础库： `2.3.0`
         *
         * 是否递归删除目录。如果为 true，则删除该目录和该目录下的所有子目录以及文件。
         */
        recursive?: boolean;
        /**
         * 接口调用成功的回调函数
         */
        success?: RmdirSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type SaveFileCompleteCallback = (res: FileError) => void;
    /**
     * 接口调用失败的回调函数
     */
    type SaveFileFailCallback = (res: FileError) => void;

    interface SaveFileSuccessCallbackResult {
        /**
         * 存储后的文件路径 (本地路径)
         */
        savedFilePath: string;
        errMsg: string;
    }

    /**
     * 接口调用成功的回调函数
     */
    type SaveFileSuccessCallback = (
                result: SaveFileSuccessCallbackResult
            ) => void;

    interface SaveFileOption {
        /**
         * 临时存储文件路径 (本地路径)
         */
        tempFilePath: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: SaveFileCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: SaveFileFailCallback;
        /**
         * 要存储的文件路径 (本地路径)
         */
        filePath?: string;
        /**
         * 接口调用成功的回调函数
         */
        success?: SaveFileSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type StatCompleteCallback = (res: FileError) => void;
    /**
     * 接口调用失败的回调函数
     */
    type StatFailCallback = (res: FileError) => void;

    /**
     * 每个 FileStats 对象包含 path 和 Stats
     */
    interface FileStats {
        /**
         * 文件/目录路径
         */
        path: string;
        /**
         *
         * Stats 对象，即描述文件状态的对象
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/file/Stats.html](https://developers.weixin.qq.com/miniprogram/dev/api/file/Stats.html)
         */
        stats: Stats;
    }

    interface StatSuccessCallbackResult {
        /**
         * [Stats](https://developers.weixin.qq.com/miniprogram/dev/api/file/Stats.html)|Array.&lt;[FileStats](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileStats.html)&gt;
         *
         * 当 recursive 为 false 时，res.stats 是一个 Stats 对象。当 recursive 为 true 且 path 是一个目录的路径时，res.stats 是一个 Array，数组的每一项是一个对象，每个对象包含 path 和 stats。
         */
        stats: Stats | FileStats[];
        errMsg: string;
    }

    /**
     * 接口调用成功的回调函数
     */
    type StatSuccessCallback = (result: StatSuccessCallbackResult) => void;

    interface StatOption {
        /**
         * 文件/目录路径 (本地路径)
         */
        path: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: StatCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: StatFailCallback;
        /**
         * 需要基础库： `2.3.0`
         *
         * 是否递归获取目录下的每个文件的 Stats 信息
         */
        recursive?: boolean;
        /**
         * 接口调用成功的回调函数
         */
        success?: StatSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type TruncateCompleteCallback = (res: FileError) => void;
    /**
     * 接口调用失败的回调函数
     */
    type TruncateFailCallback = (res: FileError) => void;
    /**
     * 接口调用成功的回调函数
     */
    type TruncateSuccessCallback = (res: FileError) => void;

    interface TruncateOption {
        /**
         * 要截断的文件路径 (本地路径)
         */
        filePath: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: TruncateCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: TruncateFailCallback;
        /**
         * 截断位置，默认0。如果 length 小于文件长度（字节），则只有前面 length 个字节会保留在文件中，其余内容会被删除；如果 length 大于文件长度，则会对其进行扩展，并且扩展部分将填充空字节（'\0'）
         */
        length?: number;
        /**
         * 接口调用成功的回调函数
         */
        success?: TruncateSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type UnlinkCompleteCallback = (res: FileError) => void;
    /**
     * 接口调用失败的回调函数
     */
    type UnlinkFailCallback = (res: FileError) => void;
    /**
     * 接口调用成功的回调函数
     */
    type UnlinkSuccessCallback = (res: FileError) => void;

    interface UnlinkOption {
        /**
         * 要删除的文件路径 (本地路径)
         */
        filePath: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: UnlinkCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: UnlinkFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: UnlinkSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type UnzipCompleteCallback = (res: FileError) => void;
    /**
     * 接口调用失败的回调函数
     */
    type UnzipFailCallback = (res: FileError) => void;
    /**
     * 接口调用成功的回调函数
     */
    type UnzipSuccessCallback = (res: FileError) => void;

    interface UnzipOption {
        /**
         * 目标目录路径, 支持本地路径
         */
        targetPath: string;
        /**
         * 源文件路径，支持本地路径, 只可以是 zip 压缩文件
         */
        zipFilePath: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: UnzipCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: UnzipFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: UnzipSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type WriteCompleteCallback = (res: FileError) => void;
    /**
     * 接口调用失败的回调函数
     */
    type WriteFailCallback = (res: FileError) => void;

    interface WriteSuccessCallbackResult {
        /**
         * 实际被写入到文件中的字节数（注意，被写入的字节数不一定与被写入的字符串字符数相同）
         */
        bytesWritten: number;
        errMsg: string;
    }

    /**
     * 接口调用成功的回调函数
     */
    type WriteSuccessCallback = (result: WriteSuccessCallbackResult) => void;

    interface WriteOption {
        /**
         * 写入的内容，类型为 String 或 ArrayBuffer
         */
        data: string | ArrayBuffer;
        /**
         * 文件描述符。fd 通过 [FileSystemManager.open](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.open.html) 或 [FileSystemManager.openSync](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.openSync.html) 接口获得
         */
        fd: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: WriteCompleteCallback;
        /**
         * 只在 data 类型是 String 时有效，指定写入文件的字符编码，默认为 utf8
         *
         * 可选值：
         * - 'ascii': ;
         * - 'base64': ;
         * - 'binary': ;
         * - 'hex': ;
         * - 'ucs2': 以小端序读取;
         * - 'ucs-2': 以小端序读取;
         * - 'utf16le': 以小端序读取;
         * - 'utf-16le': 以小端序读取;
         * - 'utf-8': ;
         * - 'utf8': ;
         * - 'latin1': ;
         */
        encoding?: "ascii" | "base64" | "binary" | "hex" | "ucs2" | "ucs-2" | "utf16le" | "utf-16le" | "utf-8" | "utf8" | "latin1";
        /**
         * 接口调用失败的回调函数
         */
        fail?: WriteFailCallback;
        /**
         * 只在 data 类型是 ArrayBuffer 时有效，指定要写入的字节数，默认为 ArrayBuffer 从0开始偏移 offset 个字节后剩余的字节数
         */
        length?: number;
        /**
         * 只在 data 类型是 ArrayBuffer 时有效，决定 ArrayBuffer 中要被写入的部位，即 ArrayBuffer 中的索引，默认0
         */
        offset?: number;
        /**
         * 指定文件开头的偏移量，即数据要被写入的位置。当 position 不传或者传入非 Number 类型的值时，数据会被写入当前指针所在位置。
         */
        position?: number;
        /**
         * 接口调用成功的回调函数
         */
        success?: WriteSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type WriteFileCompleteCallback = (res: FileError) => void;
    /**
     * 接口调用失败的回调函数
     */
    type WriteFileFailCallback = (res: FileError) => void;
    /**
     * 接口调用成功的回调函数
     */
    type WriteFileSuccessCallback = (res: FileError) => void;

    interface WriteFileOption {
        /**
         * 要写入的文本或二进制数据
         */
        data: string | ArrayBuffer;
        /**
         * 要写入的文件路径 (本地路径)
         */
        filePath: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: WriteFileCompleteCallback;
        /**
         * 指定写入文件的字符编码
         *
         * 可选值：
         * - 'ascii': ;
         * - 'base64': （注意，选择 base64 编码，data 只需要传 base64 内容本身，不要传 Data URI 前缀，否则会报 fail base64 encode error 错误。例如，传 aGVsbG8= 而不是传 data:image/png;base64,aGVsbG8= ）;
         * - 'binary': ;
         * - 'hex': ;
         * - 'ucs2': 以小端序读取;
         * - 'ucs-2': 以小端序读取;
         * - 'utf16le': 以小端序读取;
         * - 'utf-16le': 以小端序读取;
         * - 'utf-8': ;
         * - 'utf8': ;
         * - 'latin1': ;
         */
        encoding?: "ascii" | "base64" | "binary" | "hex" | "ucs2" | "ucs-2" | "utf16le" | "utf-16le" | "utf-8" | "utf8" | "latin1";
        /**
         * 接口调用失败的回调函数
         */
        fail?: WriteFileFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: WriteFileSuccessCallback;
    }

    interface ReadSyncOption {
        /**
         * 数据写入的缓冲区，必须是 ArrayBuffer 实例
         */
        arrayBuffer: ArrayBuffer;
        /**
         * 文件描述符。fd 通过 [FileSystemManager.open](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.open.html) 或 [FileSystemManager.openSync](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.openSync.html) 接口获得
         */
        fd: string;
        /**
         * 要从文件中读取的字节数，默认0
         */
        length?: number;
        /**
         * 缓冲区中的写入偏移量，默认0
         */
        offset?: number;
        /**
         * 文件读取的起始位置，如不传或传 null，则会从当前文件指针的位置读取。如果 position 是正整数，则文件指针位置会保持不变并从 position 读取文件。
         */
        position?: number;
    }

    /**
     * 文件读取结果。 通过 [FileSystemManager.readSync](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.readSync.html) 接口返回
     */
    interface ReadResult {
        /**
         * 被写入的缓存区的对象，即接口入参的 arrayBuffer
         */
        arrayBuffer: ArrayBuffer;
        /**
         * 实际读取的字节数
         */
        bytesRead: number;
    }

    interface FstatSyncOption {
        /**
         * 文件描述符。fd 通过 [FileSystemManager.open](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.open.html) 或 [FileSystemManager.openSync](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.openSync.html) 接口获得
         */
        fd: string;
    }

    interface WriteSyncOption {
        /**
         * 写入的内容，类型为 String 或 ArrayBuffer
         */
        data: string | ArrayBuffer;
        /**
         * 文件描述符。fd 通过 [FileSystemManager.open](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.open.html) 或 [FileSystemManager.openSync](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.openSync.html) 接口获得
         */
        fd: string;
        /**
         * 只在 data 类型是 String 时有效，指定写入文件的字符编码，默认为 utf8
         *
         * 可选值：
         * - 'ascii': ;
         * - 'base64': ;
         * - 'binary': ;
         * - 'hex': ;
         * - 'ucs2': 以小端序读取;
         * - 'ucs-2': 以小端序读取;
         * - 'utf16le': 以小端序读取;
         * - 'utf-16le': 以小端序读取;
         * - 'utf-8': ;
         * - 'utf8': ;
         * - 'latin1': ;
         */
        encoding?: "ascii" | "base64" | "binary" | "hex" | "ucs2" | "ucs-2" | "utf16le" | "utf-16le" | "utf-8" | "utf8" | "latin1";
        /**
         * 只在 data 类型是 ArrayBuffer 时有效，指定要写入的字节数，默认为 ArrayBuffer 从0开始偏移 offset 个字节后剩余的字节数
         */
        length?: number;
        /**
         * 只在 data 类型是 ArrayBuffer 时有效，决定 ArrayBuffer 中要被写入的部位，即 ArrayBuffer 中的索引，默认0
         */
        offset?: number;
        /**
         * 指定文件开头的偏移量，即数据要被写入的位置。当 position 不传或者传入非 Number 类型的值时，数据会被写入当前指针所在位置。
         */
        position?: number;
    }

    /**
     * 文件写入结果。 通过 [FileSystemManager.writeSync](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.writeSync.html) 接口返回
     */
    interface WriteResult {
        /**
         * 实际被写入到文件中的字节数（注意，被写入的字节数不一定与被写入的字符串字符数相同）
         */
        bytesWritten: number;
    }

    interface OpenSyncOption {
        /**
         * 文件路径 (本地路径)
         */
        filePath: string;
        /**
         * 文件系统标志，默认值: 'r'
         *
         * 可选值：
         * - 'a': 打开文件用于追加。 如果文件不存在，则创建该文件;
         * - 'ax': 类似于 'a'，但如果路径存在，则失败;
         * - 'a+': 打开文件用于读取和追加。 如果文件不存在，则创建该文件;
         * - 'ax+': 类似于 'a+'，但如果路径存在，则失败;
         * - 'as': 打开文件用于追加（在同步模式中）。 如果文件不存在，则创建该文件;
         * - 'as+': 打开文件用于读取和追加（在同步模式中）。 如果文件不存在，则创建该文件;
         * - 'r': 打开文件用于读取。 如果文件不存在，则会发生异常;
         * - 'r+': 打开文件用于读取和写入。 如果文件不存在，则会发生异常;
         * - 'w': 打开文件用于写入。 如果文件不存在则创建文件，如果文件存在则截断文件;
         * - 'wx': 类似于 'w'，但如果路径存在，则失败;
         * - 'w+': 打开文件用于读取和写入。 如果文件不存在则创建文件，如果文件存在则截断文件;
         * - 'wx+': 类似于 'w+'，但如果路径存在，则失败;
         */
        flag?: "a" | "ax" | "a+" | "ax+" | "as" | "as+" | "r" | "r+" | "w" | "wx" | "w+" | "wx+";
    }

    interface CloseSyncOption {
        /**
         * 需要被关闭的文件描述符。fd 通过 [FileSystemManager.open](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.open.html) 或 [FileSystemManager.openSync](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.openSync.html) 接口获得
         */
        fd: string;
    }

    interface FtruncateSyncOption {
        /**
         * 文件描述符。fd 通过 [FileSystemManager.open](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.open.html) 或 [FileSystemManager.openSync](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.openSync.html) 接口获得
         */
        fd: string;
        /**
         * 截断位置，默认0。如果 length 小于文件长度（单位：字节），则只有前面 length 个字节会保留在文件中，其余内容会被删除；如果 length 大于文件长度，则会对其进行扩展，并且扩展部分将填充空字节（'\0'）
         */
        length: number;
    }

    interface TruncateSyncOption {
        /**
         * 要截断的文件路径 (本地路径)
         */
        filePath: string;
        /**
         * 截断位置，默认0。如果 length 小于文件长度（字节），则只有前面 length 个字节会保留在文件中，其余内容会被删除；如果 length 大于文件长度，则会对其进行扩展，并且扩展部分将填充空字节（'\0'）
         */
        length?: number;
    }

    interface FileSystemManager {
        /**
         *
         * 在插件中使用：需要基础库 `2.19.2`
         *
         * [FileSystemManager.readdir](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.readdir.html) 的同步版本
         *
         * **注意事项**
         *
         * - readdir接口无法访问文件系统根路径(wxfile://)。
         *
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.readdirSync.html](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.readdirSync.html)
         */
        readdirSync(dirPath: string): string[];
        /**
         *
         * 需要基础库： `2.21.1`
         *
         * 在插件中使用：不支持
         *
         * 同步读取指定压缩类型的本地文件内容
         *
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.readCompressedFileSync.html](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.readCompressedFileSync.html)
         */
        readCompressedFileSync(option: ReadCompressedFileSyncOption): ArrayBuffer;
        /**
         *
         * 在插件中使用：需要基础库 `2.19.2`
         *
         * 判断文件/目录是否存在
         *
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.access.html](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.access.html)
         */
        access(option: AccessOption): void;
        /**
         *
         * 在插件中使用：需要基础库 `2.19.2`
         *
         * [FileSystemManager.access](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.access.html) 的同步版本
         *
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.accessSync.html](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.accessSync.html)
         */
        accessSync(path: string): void;
        /**
         *
         * 需要基础库： `2.1.0`
         *
         * 在插件中使用：需要基础库 `2.19.2`
         *
         * 在文件结尾追加内容
         *
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.appendFile.html](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.appendFile.html)
         */
        appendFile(option: AppendFileOption): void;
        /**
         *
         * 需要基础库： `2.1.0`
         *
         * 在插件中使用：需要基础库 `2.19.2`
         *
         * [FileSystemManager.appendFile](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.appendFile.html) 的同步版本
         *
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.appendFileSync.html](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.appendFileSync.html)
         */
        appendFileSync(filePath: string, data: string | ArrayBuffer, encoding?: "ascii" | "base64" | "binary" | "hex" | "ucs2" | "ucs-2" | "utf16le" | "utf-16le" | "utf-8" | "utf8" | "latin1"): void;
        /**
         *
         * 需要基础库： `2.16.1`
         *
         * 在插件中使用：需要基础库 `2.19.2`
         *
         * 关闭文件
         *
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.close.html](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.close.html)
         */
        close(option: FileSystemManagerCloseOption): void;
        /**
         *
         * 在插件中使用：需要基础库 `2.19.2`
         *
         * 复制文件
         *
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.copyFile.html](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.copyFile.html)
         */
        copyFile(option: CopyFileOption): void;
        /**
         *
         * 在插件中使用：需要基础库 `2.19.2`
         *
         * [FileSystemManager.copyFile](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.copyFile.html) 的同步版本
         *
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.copyFileSync.html](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.copyFileSync.html)
         */
        copyFileSync(srcPath: string, destPath: string): void;
        /**
         *
         * 需要基础库： `2.16.1`
         *
         * 在插件中使用：需要基础库 `2.19.2`
         *
         * 获取文件的状态信息
         *
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.fstat.html](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.fstat.html)
         */
        fstat(option: FstatOption): void;
        /**
         *
         * 需要基础库： `2.16.1`
         *
         * 在插件中使用：需要基础库 `2.19.2`
         *
         * 对文件内容进行截断操作
         *
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.ftruncate.html](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.ftruncate.html)
         */
        ftruncate(option: FtruncateOption): void;
        /**
         *
         * 在插件中使用：不支持
         *
         * 获取该小程序下的 本地临时文件 或 本地缓存文件 信息
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.getFileInfo.html](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.getFileInfo.html)
         */
        getFileInfo(option: GetFileInfoOption): void;
        /**
         *
         * 在插件中使用：不支持
         *
         * 获取该小程序下已保存的本地缓存文件列表
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.getSavedFileList.html](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.getSavedFileList.html)
         */
        getSavedFileList(option?: GetSavedFileListOption): void;
        /**
         *
         * 在插件中使用：需要基础库 `2.19.2`
         *
         * 创建目录
         *
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.mkdir.html](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.mkdir.html)
         */
        mkdir(option: MkdirOption): void;
        /**
         *
         * 在插件中使用：需要基础库 `2.19.2`
         *
         * [FileSystemManager.mkdir](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.mkdir.html) 的同步版本
         *
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.mkdirSync.html](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.mkdirSync.html)
         */
        mkdirSync(dirPath: string, recursive?: boolean): void;
        /**
         *
         * 需要基础库： `2.16.1`
         *
         * 在插件中使用：需要基础库 `2.19.2`
         *
         * 打开文件，返回文件描述符
         *
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.open.html](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.open.html)
         */
        open(option: OpenOption): void;
        /**
         *
         * 需要基础库： `2.16.1`
         *
         * 在插件中使用：需要基础库 `2.19.2`
         *
         * 读文件
         *
         * ## 注意事项
         * - 小游戏 iOS 高性能模式（iOSHighPerformance）暂不支持 FileSystemManager.read 接口，请使用 FileSystemManager.readFile 接口代替
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.read.html](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.read.html)
         */
        read(option: ReadOption): void;
        /**
         *
         * 需要基础库： `2.21.1`
         *
         * 在插件中使用：不支持
         *
         * 读取指定压缩类型的本地文件内容
         *
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.readCompressedFile.html](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.readCompressedFile.html)
         */
        readCompressedFile(option: ReadCompressedFileOption): void;
        /**
         *
         * 在插件中使用：需要基础库 `2.19.2`
         *
         * 读取本地文件内容。单个文件大小上限为100M。
         *
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.readFile.html](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.readFile.html)
         */
        readFile(option: ReadFileOption): void;
        /**
         *
         * 需要基础库： `2.17.3`
         *
         * 在插件中使用：需要基础库 `2.19.2`
         *
         * 读取压缩包内的文件
         *
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.readZipEntry.html](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.readZipEntry.html)
         */
        readZipEntry(option: ReadZipEntryOption): void;
        /**
         *
         * 在插件中使用：需要基础库 `2.19.2`
         *
         * 读取目录内文件列表
         *
         * **注意事项**
         *
         * - readdir接口无法访问文件系统根路径(wxfile://)。
         *
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.readdir.html](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.readdir.html)
         */
        readdir(option: ReaddirOption): void;
        /**
         *
         * 在插件中使用：不支持
         *
         * 删除该小程序下已保存的本地缓存文件
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.removeSavedFile.html](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.removeSavedFile.html)
         */
        removeSavedFile(option: RemoveSavedFileOption): void;
        /**
         *
         * 在插件中使用：需要基础库 `2.19.2`
         *
         * 重命名文件。可以把文件从 oldPath 移动到 newPath
         *
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.rename.html](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.rename.html)
         */
        rename(option: RenameOption): void;
        /**
         *
         * 在插件中使用：需要基础库 `2.19.2`
         *
         * [FileSystemManager.rename](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.rename.html) 的同步版本
         *
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.renameSync.html](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.renameSync.html)
         */
        renameSync(oldPath: string, newPath: string): void;
        /**
         *
         * 在插件中使用：需要基础库 `2.19.2`
         *
         * 删除目录
         *
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.rmdir.html](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.rmdir.html)
         */
        rmdir(option: RmdirOption): void;
        /**
         *
         * 在插件中使用：需要基础库 `2.19.2`
         *
         * [FileSystemManager.rmdir](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.rmdir.html) 的同步版本
         *
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.rmdirSync.html](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.rmdirSync.html)
         */
        rmdirSync(dirPath: string, recursive?: boolean): void;
        /**
         *
         * 在插件中使用：不支持
         *
         * 保存临时文件到本地。此接口会移动临时文件，因此调用成功后，tempFilePath 将不可用。
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.saveFile.html](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.saveFile.html)
         */
        saveFile(option: SaveFileOption): void;
        /**
         *
         * 在插件中使用：需要基础库 `2.19.2`
         *
         * 获取文件 Stats 对象
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.stat.html](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.stat.html)
         */
        stat(option: StatOption): void;
        /**
         *
         * 需要基础库： `2.16.1`
         *
         * 在插件中使用：需要基础库 `2.19.2`
         *
         * 对文件内容进行截断操作
         *
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.truncate.html](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.truncate.html)
         */
        truncate(option: TruncateOption): void;
        /**
         *
         * 在插件中使用：需要基础库 `2.19.2`
         *
         * 删除文件
         *
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.unlink.html](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.unlink.html)
         */
        unlink(option: UnlinkOption): void;
        /**
         *
         * 在插件中使用：需要基础库 `2.19.2`
         *
         * [FileSystemManager.unlink](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.unlink.html) 的同步版本
         *
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.unlinkSync.html](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.unlinkSync.html)
         */
        unlinkSync(filePath: string): void;
        /**
         *
         * 在插件中使用：需要基础库 `2.19.2`
         *
         * 解压文件
         *
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.unzip.html](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.unzip.html)
         */
        unzip(option: UnzipOption): void;
        /**
         *
         * 需要基础库： `2.16.1`
         *
         * 在插件中使用：需要基础库 `2.19.2`
         *
         * 写入文件
         *
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.write.html](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.write.html)
         */
        write(option: WriteOption): void;
        /**
         *
         * 在插件中使用：需要基础库 `2.19.2`
         *
         * 写文件
         *
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.writeFile.html](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.writeFile.html)
         */
        writeFile(option: WriteFileOption): void;
        /**
         *
         * 在插件中使用：需要基础库 `2.19.2`
         *
         * [FileSystemManager.writeFile](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.writeFile.html) 的同步版本
         *
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.writeFileSync.html](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.writeFileSync.html)
         */
        writeFileSync(filePath: string, data: string | ArrayBuffer, encoding?: "ascii" | "base64" | "binary" | "hex" | "ucs2" | "ucs-2" | "utf16le" | "utf-16le" | "utf-8" | "utf8" | "latin1"): void;
        /**
         *
         * 需要基础库： `2.16.1`
         *
         * 在插件中使用：需要基础库 `2.19.2`
         *
         * 读文件
         *
         * ## 注意事项
         * - 小游戏 iOS 高性能模式（iOSHighPerformance）暂不支持 FileSystemManager.readSync 接口，请使用 FileSystemManager.readFileSync 接口代替
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.readSync.html](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.readSync.html)
         */
        readSync(option: ReadSyncOption): ReadResult;
        /**
         *
         * 需要基础库： `2.16.1`
         *
         * 在插件中使用：需要基础库 `2.19.2`
         *
         * 同步获取文件的状态信息
         *
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.fstatSync.html](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.fstatSync.html)
         */
        fstatSync(option: FstatSyncOption): Stats;
        /**
         *
         * 在插件中使用：需要基础库 `2.19.2`
         *
         * [FileSystemManager.stat](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.stat.html) 的同步版本
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.statSync.html](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.statSync.html)
         */
        statSync(path: string, recursive?: boolean): Stats | FileStats[];
        /**
         *
         * 需要基础库： `2.16.1`
         *
         * 在插件中使用：需要基础库 `2.19.2`
         *
         * 同步写入文件
         *
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.writeSync.html](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.writeSync.html)
         */
        writeSync(option: WriteSyncOption): WriteResult;
        /**
         *
         * 需要基础库： `2.16.1`
         *
         * 在插件中使用：需要基础库 `2.19.2`
         *
         * 同步打开文件，返回文件描述符
         *
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.openSync.html](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.openSync.html)
         */
        openSync(option: OpenSyncOption): string;
        /**
         *
         * 在插件中使用：不支持
         *
         * [FileSystemManager.saveFile](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.saveFile.html) 的同步版本
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.saveFileSync.html](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.saveFileSync.html)
         */
        saveFileSync(tempFilePath: string, filePath?: string): string;
        /**
         *
         * 在插件中使用：需要基础库 `2.19.2`
         *
         * [FileSystemManager.readFile](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.readFile.html) 的同步版本
         *
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.readFileSync.html](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.readFileSync.html)
         */
        readFileSync(filePath: string, encoding?: "ascii" | "base64" | "binary" | "hex" | "ucs2" | "ucs-2" | "utf16le" | "utf-16le" | "utf-8" | "utf8" | "latin1", position?: number, length?: number): string | ArrayBuffer;
        /**
         *
         * 需要基础库： `2.16.1`
         *
         * 在插件中使用：需要基础库 `2.19.2`
         *
         * 同步关闭文件
         *
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.closeSync.html](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.closeSync.html)
         */
        closeSync(option: CloseSyncOption): undefined;
        /**
         *
         * 需要基础库： `2.16.1`
         *
         * 在插件中使用：需要基础库 `2.19.2`
         *
         * 对文件内容进行截断操作
         *
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.ftruncateSync.html](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.ftruncateSync.html)
         */
        ftruncateSync(option: FtruncateSyncOption): undefined;
        /**
         *
         * 需要基础库： `2.16.1`
         *
         * 在插件中使用：需要基础库 `2.19.2`
         *
         * 对文件内容进行截断操作 (truncate 的同步版本)
         *
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.truncateSync.html](https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.truncateSync.html)
         */
        truncateSync(option: TruncateSyncOption): undefined;
    }

    interface CreateInferenceSessionOption {
        /**
         * 模型文件路径，目前只执行后缀为.onnx格式(支持代码包路径，和本地文件系统路径）
         */
        model: string;
        /**
         * 是否使用NPU推理，仅对IOS有效
         */
        allowNPU?: boolean;
        /**
         * 是否生成量化模型推理
         */
        allowQuantize?: boolean;
        /**
         * 推理精度，有效值为 0 - 4。一般来说，使用的precisionLevel等级越低，推理速度越快，但可能会损失精度。推荐开发者在开发时，在效果满足需求时优先使用更低精度以提高推理速度，节约能耗。
         *
         * 可选值：
         * - 0: 使用fp16 存储浮点，fp16计算，Winograd 算法也采取fp16 计算，开启近似math计算;
         * - 1: 使用fp16 存储浮点，fp16计算，禁用 Winograd 算法，开启近似math计算;
         * - 2: 使用fp16 存储浮点，fp32计算，开启 Winograd，开启近似math计算;
         * - 3: 使用fp32 存储浮点，fp32计算，开启 Winograd，开启近似math计算;
         * - 4: 使用fp32 存储浮点，fp32计算，开启 Winograd，关闭近似math计算;
         */
        precisionLevel?: 0 | 1 | 2 | 3 | 4;
        /**
         * 输入典型分辨率
         */
        typicalShape?: any;
    }

    /**
     * 需要基础库： `2.30.0`
     *
     * 在插件中使用：需要基础库 `2.30.0`
     *
     * Tensors 是 key-value 形式的对象，对象的 key 会作为 input/output name，对象的 value 则是 Tensor。 Tensor 结构如下。
     *
     * ****
     *
     * ```js
     * session.run({
     * input1: {
     * type: 'float32',
     * data: new Float32Array(3 * 224 * 224).buffer,
     * shape: [1, 3, 224, 224] // NCHW 顺序
     * },
     * input2: {
     * type: 'uint8',
     * data: new Uint8Array(224 * 224).buffer,
     * shape: [1, 1, 224, 224]
     * },
     * }).then(res => {
     * console.log(res.output0)
     * // output0 结构如下：
     * // {
     * //   type: 'uint8',
     * //   data: new Uint8Array(224 * 224).buffer,
     * //   shape: [1, 1, 224, 224]
     * // }
     * })
     * ```
     */
    interface Tensors {
    }

    interface InferenceSession {
        /**
         *
         * 需要基础库： `2.30.0`
         *
         * 在插件中使用：需要基础库 `2.30.0`
         *
         * 销毁 InferenceSession 实例
         *
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/ai/inference/InferenceSession.destroy.html](https://developers.weixin.qq.com/miniprogram/dev/api/ai/inference/InferenceSession.destroy.html)
         */
        destroy(): void;
        /**
         *
         * 需要基础库： `2.30.0`
         *
         * 在插件中使用：需要基础库 `2.30.0`
         *
         * 取消监听模型加载失败事件
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/ai/inference/InferenceSession.offError.html](https://developers.weixin.qq.com/miniprogram/dev/api/ai/inference/InferenceSession.offError.html)
         */
        offError(callback: (...args: any[]) => any): void;
        /**
         *
         * 需要基础库： `2.30.0`
         *
         * 在插件中使用：需要基础库 `2.30.0`
         *
         * 取消监听模型加载完成事件
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/ai/inference/InferenceSession.offLoad.html](https://developers.weixin.qq.com/miniprogram/dev/api/ai/inference/InferenceSession.offLoad.html)
         */
        offLoad(callback: (...args: any[]) => any): void;
        /**
         *
         * 需要基础库： `2.30.0`
         *
         * 在插件中使用：需要基础库 `2.30.0`
         *
         * 监听模型加载失败事件
         *
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/ai/inference/InferenceSession.onError.html](https://developers.weixin.qq.com/miniprogram/dev/api/ai/inference/InferenceSession.onError.html)
         */
        onError(callback: (...args: any[]) => any): void;
        /**
         *
         * 需要基础库： `2.30.0`
         *
         * 在插件中使用：需要基础库 `2.30.0`
         *
         * 监听模型加载完成事件
         *
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/ai/inference/InferenceSession.onLoad.html](https://developers.weixin.qq.com/miniprogram/dev/api/ai/inference/InferenceSession.onLoad.html)
         */
        onLoad(callback: (...args: any[]) => any): void;
        /**
         *
         * 需要基础库： `2.30.0`
         *
         * 在插件中使用：需要基础库 `2.30.0`
         *
         * 运行推断。需要在 session.onLoad 回调后使用。接口参数为 Tensors 对象，返回 Promise。一个 InferenceSession 被创建完成后可以重复多次调用 InferenceSession.run(), 直到调用 session.destroy() 进行销毁。
         *
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/ai/inference/InferenceSession.run.html](https://developers.weixin.qq.com/miniprogram/dev/api/ai/inference/InferenceSession.run.html)
         */
        run(tensors: Tensors): Promise<Tensors>;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type ExitCastingCompleteCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用失败的回调函数
     */
    type ExitCastingFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type ExitCastingSuccessCallback = (res: GeneralCallbackResult) => void;

    interface ExitCastingOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: ExitCastingCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: ExitCastingFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: ExitCastingSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type ExitFullScreenCompleteCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用失败的回调函数
     */
    type ExitFullScreenFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type ExitFullScreenSuccessCallback = (res: GeneralCallbackResult) => void;

    interface ExitFullScreenOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: ExitFullScreenCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: ExitFullScreenFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: ExitFullScreenSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type ExitPictureInPictureCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type ExitPictureInPictureFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type ExitPictureInPictureSuccessCallback = (
                res: GeneralCallbackResult
            ) => void;

    interface ExitPictureInPictureOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: ExitPictureInPictureCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: ExitPictureInPictureFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: ExitPictureInPictureSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type MuteCompleteCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用失败的回调函数
     */
    type MuteFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type MuteSuccessCallback = (res: GeneralCallbackResult) => void;

    interface MuteOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: MuteCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: MuteFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: MuteSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type PauseCompleteCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用失败的回调函数
     */
    type PauseFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type PauseSuccessCallback = (res: GeneralCallbackResult) => void;

    interface PauseOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: PauseCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: PauseFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: PauseSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type PlayCompleteCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用失败的回调函数
     */
    type PlayFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type PlaySuccessCallback = (res: GeneralCallbackResult) => void;

    interface PlayOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: PlayCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: PlayFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: PlaySuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type ReconnectCastingCompleteCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用失败的回调函数
     */
    type ReconnectCastingFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type ReconnectCastingSuccessCallback = (res: GeneralCallbackResult) => void;

    interface ReconnectCastingOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: ReconnectCastingCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: ReconnectCastingFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: ReconnectCastingSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type RequestFullScreenCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type RequestFullScreenFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type RequestFullScreenSuccessCallback = (res: GeneralCallbackResult) => void;

    interface LivePlayerContextRequestFullScreenOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: RequestFullScreenCompleteCallback;
        /**
         * 设置全屏时的方向
         *
         * 可选值：
         * - 0: 正常竖向;
         * - 90: 屏幕逆时针90度;
         * - -90: 屏幕顺时针90度;
         */
        direction?: 0 | 90 | -90;
        /**
         * 接口调用失败的回调函数
         */
        fail?: RequestFullScreenFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: RequestFullScreenSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type RequestPictureInPictureCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type RequestPictureInPictureFailCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用成功的回调函数
     */
    type RequestPictureInPictureSuccessCallback = (
                res: GeneralCallbackResult
            ) => void;

    interface RequestPictureInPictureOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: RequestPictureInPictureCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: RequestPictureInPictureFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: RequestPictureInPictureSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type ResumeCompleteCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用失败的回调函数
     */
    type ResumeFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type ResumeSuccessCallback = (res: GeneralCallbackResult) => void;

    interface ResumeOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: ResumeCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: ResumeFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: ResumeSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type SnapshotCompleteCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用失败的回调函数
     */
    type SnapshotFailCallback = (res: GeneralCallbackResult) => void;

    interface LivePlayerContextSnapshotSuccessCallbackResult {
        /**
         * 图片的高度
         */
        height: string;
        /**
         * 图片文件的临时路径 (本地路径)
         */
        tempImagePath: string;
        /**
         * 图片的宽度
         */
        width: string;
        errMsg: string;
    }

    /**
     * 接口调用成功的回调函数
     */
    type LivePlayerContextSnapshotSuccessCallback = (
                result: LivePlayerContextSnapshotSuccessCallbackResult
            ) => void;

    interface LivePlayerContextSnapshotOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: SnapshotCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: SnapshotFailCallback;
        /**
         * 需要基础库： `2.10.0`
         *
         * 图片的质量
         *
         * 可选值：
         * - 'raw': 原图;
         * - 'compressed': 压缩图;
         */
        quality?: "raw" | "compressed";
        /**
         * 需要基础库： `2.25.0`
         *
         * 截取的源类型
         *
         * 可选值：
         * - 'stream': 截取视频源;
         * - 'view': 截取渲染后的画面;
         */
        sourceType?: "stream" | "view";
        /**
         * 接口调用成功的回调函数
         */
        success?: LivePlayerContextSnapshotSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type StartCastingCompleteCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用失败的回调函数
     */
    type StartCastingFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type StartCastingSuccessCallback = (res: GeneralCallbackResult) => void;

    interface StartCastingOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: StartCastingCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: StartCastingFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: StartCastingSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type StopCompleteCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用失败的回调函数
     */
    type StopFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type StopSuccessCallback = (res: GeneralCallbackResult) => void;

    interface StopOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: StopCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: StopFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: StopSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type SwitchCastingCompleteCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用失败的回调函数
     */
    type SwitchCastingFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type SwitchCastingSuccessCallback = (res: GeneralCallbackResult) => void;

    interface SwitchCastingOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: SwitchCastingCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: SwitchCastingFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: SwitchCastingSuccessCallback;
    }

    interface LivePlayerContext {
        /**
         *
         * 需要基础库： `2.14.3`
         *
         * 在插件中使用：支持
         *
         * 退出后台音频播放模式。
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/live/LivePlayerContext.exitBackgroundPlayback.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/live/LivePlayerContext.exitBackgroundPlayback.html)
         */
        exitBackgroundPlayback(): void;
        /**
         *
         * 需要基础库： `2.32.0`
         *
         * 在插件中使用：支持
         *
         * 退出投屏。仅支持在 tap 事件回调内调用。
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/live/LivePlayerContext.exitCasting.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/live/LivePlayerContext.exitCasting.html)
         */
        exitCasting(option?: ExitCastingOption): void;
        /**
         *
         * 在插件中使用：支持
         *
         * 退出全屏
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/live/LivePlayerContext.exitFullScreen.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/live/LivePlayerContext.exitFullScreen.html)
         */
        exitFullScreen(option?: ExitFullScreenOption): void;
        /**
         *
         * 在插件中使用：支持
         *
         * 退出小窗，该方法可在任意页面调用
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/live/LivePlayerContext.exitPictureInPicture.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/live/LivePlayerContext.exitPictureInPicture.html)
         */
        exitPictureInPicture(option?: ExitPictureInPictureOption): void;
        /**
         *
         * 在插件中使用：支持
         *
         * 静音
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/live/LivePlayerContext.mute.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/live/LivePlayerContext.mute.html)
         */
        mute(option?: MuteOption): void;
        /**
         *
         * 需要基础库： `1.9.90`
         *
         * 在插件中使用：支持
         *
         * 暂停
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/live/LivePlayerContext.pause.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/live/LivePlayerContext.pause.html)
         */
        pause(option?: PauseOption): void;
        /**
         *
         * 在插件中使用：支持
         *
         * 播放
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/live/LivePlayerContext.play.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/live/LivePlayerContext.play.html)
         */
        play(option?: PlayOption): void;
        /**
         *
         * 需要基础库： `2.32.0`
         *
         * 在插件中使用：支持
         *
         * 重连投屏设备。仅支持在 tap 事件回调内调用。
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/live/LivePlayerContext.reconnectCasting.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/live/LivePlayerContext.reconnectCasting.html)
         */
        reconnectCasting(option?: ReconnectCastingOption): void;
        /**
         *
         * 需要基础库： `2.14.3`
         *
         * 在插件中使用：支持
         *
         * 进入后台音频播放模式。
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/live/LivePlayerContext.requestBackgroundPlayback.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/live/LivePlayerContext.requestBackgroundPlayback.html)
         */
        requestBackgroundPlayback(): void;
        /**
         *
         * 在插件中使用：支持
         *
         * 进入全屏
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/live/LivePlayerContext.requestFullScreen.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/live/LivePlayerContext.requestFullScreen.html)
         */
        requestFullScreen(option: LivePlayerContextRequestFullScreenOption): void;
        /**
         *
         * 需要基础库： `2.15.0`
         *
         * 在插件中使用：支持
         *
         * 进入小窗
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/live/LivePlayerContext.requestPictureInPicture.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/live/LivePlayerContext.requestPictureInPicture.html)
         */
        requestPictureInPicture(option?: RequestPictureInPictureOption): void;
        /**
         *
         * 需要基础库： `1.9.90`
         *
         * 在插件中使用：支持
         *
         * 恢复
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/live/LivePlayerContext.resume.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/live/LivePlayerContext.resume.html)
         */
        resume(option?: ResumeOption): void;
        /**
         *
         * 需要基础库： `2.7.1`
         *
         * 在插件中使用：支持
         *
         * 截图
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/live/LivePlayerContext.snapshot.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/live/LivePlayerContext.snapshot.html)
         */
        snapshot(option: LivePlayerContextSnapshotOption): void;
        /**
         *
         * 需要基础库： `2.32.0`
         *
         * 在插件中使用：支持
         *
         * 开始投屏, 拉起半屏搜索设备。仅支持在 tap 事件回调内调用。
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/live/LivePlayerContext.startCasting.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/live/LivePlayerContext.startCasting.html)
         */
        startCasting(option?: StartCastingOption): void;
        /**
         *
         * 在插件中使用：支持
         *
         * 停止
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/live/LivePlayerContext.stop.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/live/LivePlayerContext.stop.html)
         */
        stop(option?: StopOption): void;
        /**
         *
         * 需要基础库： `2.32.0`
         *
         * 在插件中使用：支持
         *
         * 切换投屏设备。仅支持在 tap 事件回调内调用。
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/live/LivePlayerContext.switchCasting.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/live/LivePlayerContext.switchCasting.html)
         */
        switchCasting(option?: SwitchCastingOption): void;
    }

    interface GetLogManagerOption {
        /**
         * 需要基础库： `2.3.2`
         *
         * 取值为0/1，取值为0表示会把 `App`、`Page` 的生命周期函数和 uni 命名空间下的函数调用写入日志，取值为1则不会。默认值是 0
         */
        level?: number;
    }

    interface LogManager {
        /**
         *
         * 在插件中使用：不支持
         *
         * 写 debug 日志
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/debug/LogManager.debug.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/debug/LogManager.debug.html)
         */
        debug(args: any[]): void;
        /**
         *
         * 在插件中使用：不支持
         *
         * 写 info 日志
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/debug/LogManager.info.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/debug/LogManager.info.html)
         */
        info(args: any[]): void;
        /**
         *
         * 在插件中使用：不支持
         *
         * 写 log 日志
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/debug/LogManager.log.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/debug/LogManager.log.html)
         */
        log(args: any[]): void;
        /**
         *
         * 在插件中使用：不支持
         *
         * 写 warn 日志
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/debug/LogManager.warn.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/debug/LogManager.warn.html)
         */
        warn(args: any[]): void;
    }

    /**
     * 视频帧数据，若取不到则返回 null。当缓冲区为空的时候可能暂停取不到数据。
     */
    interface FrameDataOptions {
        /**
         * 帧数据
         */
        data: ArrayBuffer;
        /**
         * 帧数据高度
         */
        height: number;
        /**
         * 帧原始 dts
         */
        pkDts: number;
        /**
         * 帧原始 pts
         */
        pkPts: number;
        /**
         * 帧数据宽度
         */
        width: number;
    }

    interface VideoDecoderStartOption {
        /**
         * 需要解码的视频源文件。基础库 2.13.0 以下的版本只支持本地路径。 2.13.0 开始支持 http:// 和 https:// 协议的远程路径。
         */
        source: string;
        /**
         * 需要基础库： `2.15.0`
         *
         * 是否不需要音频轨道
         */
        abortAudio?: boolean;
        /**
         * 需要基础库： `2.15.0`
         *
         * 是否不需要视频轨道
         */
        abortVideo?: boolean;
        /**
         * 解码模式。0：按 pts 解码；1：以最快速度解码
         */
        mode?: number;
    }

    interface VideoDecoder {
        /**
         *
         * 需要基础库： `2.11.0`
         *
         * 在插件中使用：支持
         *
         * 获取下一帧的解码数据
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/video-decoder/VideoDecoder.getFrameData.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/video-decoder/VideoDecoder.getFrameData.html)
         */
        getFrameData(): FrameDataOptions;
        /**
         *
         * 需要基础库： `2.11.0`
         *
         * 在插件中使用：支持
         *
         * 移除解码器
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/video-decoder/VideoDecoder.remove.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/video-decoder/VideoDecoder.remove.html)
         */
        remove(): Promise<any>;
        /**
         *
         * 需要基础库： `2.11.0`
         *
         * 在插件中使用：支持
         *
         * 跳到某个时间点解码
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/video-decoder/VideoDecoder.seek.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/video-decoder/VideoDecoder.seek.html)
         */
        seek(position: number): Promise<any>;
        /**
         *
         * 需要基础库： `2.11.0`
         *
         * 在插件中使用：支持
         *
         * 开始解码
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/video-decoder/VideoDecoder.start.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/video-decoder/VideoDecoder.start.html)
         */
        start(option: VideoDecoderStartOption): Promise<any>;
        /**
         *
         * 需要基础库： `2.11.0`
         *
         * 在插件中使用：支持
         *
         * 停止解码
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/video-decoder/VideoDecoder.stop.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/video-decoder/VideoDecoder.stop.html)
         */
        stop(): Promise<any>;
        /**
         *
         * 需要基础库： `2.11.0`
         *
         * 在插件中使用：支持
         *
         * 取消监听录制事件。当对应事件触发时，该回调函数不再执行
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/video-decoder/VideoDecoder.off.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/video-decoder/VideoDecoder.off.html)
         */
        off(eventName: string, callback: (...args: any[]) => any): void;
        /**
         *
         * 需要基础库： `2.11.0`
         *
         * 在插件中使用：支持
         *
         * 注册监听录制事件的回调函数。当对应事件触发时，回调函数会被执行
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/video-decoder/VideoDecoder.on.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/video-decoder/VideoDecoder.on.html)
         */
        on(eventName: "start" | "stop" | "seek" | "bufferchange" | "ended", callback: (...args: any[]) => any): void;
    }

    /**
     * MediaAudioPlayer 实例，可通过 [uni.createMediaAudioPlayer](https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/wx.createMediaAudioPlayer.html) 接口获取实例。
     */
    interface MediaAudioPlayer {
        /**
         * 音量。范围 0~1。默认为 1
         */
        volume: number;
        /**
         *
         * 在插件中使用：支持
         *
         * 添加音频源
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/MediaAudioPlayer.addAudioSource.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/MediaAudioPlayer.addAudioSource.html)
         */
        addAudioSource(source: VideoDecoder): Promise<any>;
        /**
         *
         * 在插件中使用：支持
         *
         * 销毁播放器
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/MediaAudioPlayer.destroy.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/MediaAudioPlayer.destroy.html)
         */
        destroy(): Promise<any>;
        /**
         *
         * 在插件中使用：支持
         *
         * 移除音频源
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/MediaAudioPlayer.removeAudioSource.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/MediaAudioPlayer.removeAudioSource.html)
         */
        removeAudioSource(source: VideoDecoder): Promise<any>;
        /**
         *
         * 在插件中使用：支持
         *
         * 启动播放器
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/MediaAudioPlayer.start.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/MediaAudioPlayer.start.html)
         */
        start(): Promise<any>;
        /**
         *
         * 在插件中使用：支持
         *
         * 停止播放器
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/MediaAudioPlayer.stop.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/MediaAudioPlayer.stop.html)
         */
        stop(): Promise<any>;
    }

    /**
     * 需要基础库： `2.9.0`
     *
     * 可通过 [MediaContainer.extractDataSource](https://developers.weixin.qq.com/miniprogram/dev/api/media/video-processing/MediaContainer.extractDataSource.html) 返回。
     *
     * [MediaTrack](https://developers.weixin.qq.com/miniprogram/dev/api/media/video-processing/MediaTrack.html) 音频或视频轨道，可以对轨道进行一些操作
     */
    interface MediaTrack {
        /**
         * 轨道长度，只读
         */
        duration: number;
        /**
         * 轨道类型，只读
         *
         * 可选值：
         * - 'audio': 音频轨道;
         * - 'video': 视频轨道;
         */
        kind: "audio" | "video";
        /**
         * 音量，音频轨道下有效，可写
         */
        volume: number;
    }

    interface ExtractDataSourceOption {
        /**
         * 视频源地址，只支持本地文件
         */
        source: string;
    }

    interface MediaContainer {
        /**
         *
         * 需要基础库： `2.9.0`
         *
         * 在插件中使用：支持
         *
         * 将音频或视频轨道添加到容器
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/video-processing/MediaContainer.addTrack.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/video-processing/MediaContainer.addTrack.html)
         */
        addTrack(track: MediaTrack): void;
        /**
         *
         * 需要基础库： `2.9.0`
         *
         * 在插件中使用：支持
         *
         * 将容器销毁，释放资源
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/video-processing/MediaContainer.destroy.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/video-processing/MediaContainer.destroy.html)
         */
        destroy(): void;
        /**
         *
         * 需要基础库： `2.9.0`
         *
         * 在插件中使用：支持
         *
         * 将容器内的轨道合并并导出视频文件
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/video-processing/MediaContainer.export.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/video-processing/MediaContainer.export.html)
         */
        export(): void;
        /**
         *
         * 需要基础库： `2.9.0`
         *
         * 在插件中使用：支持
         *
         * 将传入的视频源分离轨道。不会自动将轨道添加到待合成的容器里。
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/video-processing/MediaContainer.extractDataSource.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/video-processing/MediaContainer.extractDataSource.html)
         */
        extractDataSource(option: ExtractDataSourceOption): void;
        /**
         *
         * 需要基础库： `2.9.0`
         *
         * 在插件中使用：支持
         *
         * 将音频或视频轨道从容器中移除
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/video-processing/MediaContainer.removeTrack.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/video-processing/MediaContainer.removeTrack.html)
         */
        removeTrack(track: MediaTrack): void;
    }

    interface CreateMediaRecorderOption {
        /**
         * 指定录制的时长（s)，到达自动停止。最大 7200，最小 5
         */
        duration?: number;
        /**
         * 视频 fps
         */
        fps?: number;
        /**
         * 视频关键帧间隔
         */
        gop?: number;
        /**
         * 画布录制高度
         */
        height?: number;
        /**
         * 视频比特率（kbps），最小值 600，最大值 3000
         */
        videoBitsPerSecond?: number;
        /**
         * 画布录制宽度
         */
        width?: number;
    }

    interface MediaRecorder {
        /**
         *
         * 需要基础库： `2.11.0`
         *
         * 在插件中使用：支持
         *
         * 取消监听录制事件。当对应事件触发时，该回调函数不再执行。
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/media-recorder/MediaRecorder.off.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/media-recorder/MediaRecorder.off.html)
         */
        off(eventName: string, callback: (...args: any[]) => any): void;
        /**
         *
         * 需要基础库： `2.11.0`
         *
         * 在插件中使用：支持
         *
         * 注册监听录制事件的回调函数。当对应事件触发时，回调函数会被执行。
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/media-recorder/MediaRecorder.on.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/media-recorder/MediaRecorder.on.html)
         */
        on(eventName: "start" | "stop" | "pause" | "resume" | "timeupdate", callback: (...args: any[]) => any): void;
        /**
         *
         * 需要基础库： `2.11.0`
         *
         * 在插件中使用：支持
         *
         * 销毁录制器
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/media-recorder/MediaRecorder.destroy.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/media-recorder/MediaRecorder.destroy.html)
         */
        destroy(): Promise<any>;
        /**
         *
         * 需要基础库： `2.11.0`
         *
         * 在插件中使用：支持
         *
         * 暂停录制
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/media-recorder/MediaRecorder.pause.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/media-recorder/MediaRecorder.pause.html)
         */
        pause(): Promise<any>;
        /**
         *
         * 需要基础库： `2.11.0`
         *
         * 在插件中使用：支持
         *
         * 请求下一帧录制，在 callback 里完成一帧渲染后开始录制当前帧
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/media-recorder/MediaRecorder.requestFrame.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/media-recorder/MediaRecorder.requestFrame.html)
         */
        requestFrame(callback: (...args: any[]) => any): Promise<any>;
        /**
         *
         * 需要基础库： `2.11.0`
         *
         * 在插件中使用：支持
         *
         * 恢复录制
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/media-recorder/MediaRecorder.resume.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/media-recorder/MediaRecorder.resume.html)
         */
        resume(): Promise<any>;
        /**
         *
         * 需要基础库： `2.11.0`
         *
         * 在插件中使用：支持
         *
         * 开始录制
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/media-recorder/MediaRecorder.start.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/media-recorder/MediaRecorder.start.html)
         */
        start(): Promise<any>;
        /**
         *
         * 需要基础库： `2.11.0`
         *
         * 在插件中使用：支持
         *
         * 结束录制
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/media-recorder/MediaRecorder.stop.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/media-recorder/MediaRecorder.stop.html)
         */
        stop(): Promise<any>;
    }

    /**
     * 标签类型枚举
     */
    interface TechType {
        /**
         * 对应IsoDep实例，实例支持ISO-DEP (ISO 14443-4)标准的读写
         */
        isoDep: string;
        /**
         * 对应MifareClassic实例，实例支持MIFARE Classic标签的读写
         */
        mifareClassic: string;
        /**
         * 对应MifareUltralight实例，实例支持MIFARE Ultralight标签的读写
         */
        mifareUltralight: string;
        /**
         * 对应Ndef实例，实例支持对NDEF格式的NFC标签上的NDEF数据的读写
         */
        ndef: string;
        /**
         * 对应NfcA实例，实例支持NFC-A (ISO 14443-3A)标准的读写
         */
        nfcA: string;
        /**
         * 对应NfcB实例，实例支持NFC-B (ISO 14443-3B)标准的读写
         */
        nfcB: string;
        /**
         * 对应NfcF实例，实例支持NFC-F (JIS 6319-4)标准的读写
         */
        nfcF: string;
        /**
         * 对应NfcV实例，实例支持NFC-V (ISO 15693)标准的读写
         */
        nfcV: string;
    }

    interface OnDiscoveredListenerResult {
        id: ArrayBuffer;
        /**
         * 可选，NdefMessage 数组，消息格式为 {id: ArrayBuffer, type: ArrayBuffer, payload: ArrayBuffer}
         */
        messages: any[];
        /**
         * tech 数组，用于匹配NFC卡片具体可以使用什么标准（NfcA等实例）处理
         */
        techs: any[];
    }

    /**
     * onDiscovered 传入的监听函数。不传此参数则移除所有监听函数。
     */
    type OffDiscoveredCallback = (result: OnDiscoveredListenerResult) => void;
    /**
     * 的监听函数
     */
    type OnDiscoveredCallback = (result: OnDiscoveredListenerResult) => void;

    interface Nfcrwerror {
        /**
         * 错误信息
         *
         * | 错误码 | 错误信息 | 说明 |
         * | - | - | - |
         * | 13000 | 设备不支持NFC |  |
         * | 13001 | 系统NFC开关未打开 |  |
         * | 13010 | 未知错误 |  |
         * | 13019 | user is not authorized | 用户未授权 |
         * | 13011 | invalid parameter | 参数无效 |
         * | 13012 | parse NdefMessage failed | 将参数解析为NdefMessage失败 |
         * | 13021 | NFC discovery already started | 已经开始NFC扫描 |
         * | 13018 | NFC discovery has not started | 尝试在未开始NFC扫描时停止NFC扫描 |
         * | 13022 | Tech already connected | 标签已经连接 |
         * | 13023 | Tech has not connected | 尝试在未连接标签时断开连接 |
         * | 13013 | NFC tag has not been discovered | 未扫描到NFC标签 |
         * | 13014 | invalid tech | 无效的标签技术 |
         * | 13015 | unavailable tech | 从标签上获取对应技术失败 |
         * | 13024 | function not support | 当前标签技术不支持该功能 |
         * | 13017 | system internal error | 相关读写操作失败 |
         * | 13016 | connect fail | 连接失败 |
         */
        errMsg: string;
        /**
         * 错误码
         *
         * | 错误码 | 错误信息 | 说明 |
         * | - | - | - |
         * | 13000 | 设备不支持NFC |  |
         * | 13001 | 系统NFC开关未打开 |  |
         * | 13010 | 未知错误 |  |
         * | 13019 | user is not authorized | 用户未授权 |
         * | 13011 | invalid parameter | 参数无效 |
         * | 13012 | parse NdefMessage failed | 将参数解析为NdefMessage失败 |
         * | 13021 | NFC discovery already started | 已经开始NFC扫描 |
         * | 13018 | NFC discovery has not started | 尝试在未开始NFC扫描时停止NFC扫描 |
         * | 13022 | Tech already connected | 标签已经连接 |
         * | 13023 | Tech has not connected | 尝试在未连接标签时断开连接 |
         * | 13013 | NFC tag has not been discovered | 未扫描到NFC标签 |
         * | 13014 | invalid tech | 无效的标签技术 |
         * | 13015 | unavailable tech | 从标签上获取对应技术失败 |
         * | 13024 | function not support | 当前标签技术不支持该功能 |
         * | 13017 | system internal error | 相关读写操作失败 |
         * | 13016 | connect fail | 连接失败 |
         */
        errCode: number;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type StartDiscoveryCompleteCallback = (res: Nfcrwerror) => void;
    /**
     * 接口调用失败的回调函数
     */
    type StartDiscoveryFailCallback = (res: Nfcrwerror) => void;
    /**
     * 接口调用成功的回调函数
     */
    type StartDiscoverySuccessCallback = (res: Nfcrwerror) => void;

    interface StartDiscoveryOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: StartDiscoveryCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: StartDiscoveryFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: StartDiscoverySuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type StopDiscoveryCompleteCallback = (res: Nfcrwerror) => void;
    /**
     * 接口调用失败的回调函数
     */
    type StopDiscoveryFailCallback = (res: Nfcrwerror) => void;
    /**
     * 接口调用成功的回调函数
     */
    type StopDiscoverySuccessCallback = (res: Nfcrwerror) => void;

    interface StopDiscoveryOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: StopDiscoveryCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: StopDiscoveryFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: StopDiscoverySuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type NdefCloseCompleteCallback = (res: Nfcrwerror) => void;
    /**
     * 接口调用失败的回调函数
     */
    type NdefCloseFailCallback = (res: Nfcrwerror) => void;
    /**
     * 接口调用成功的回调函数
     */
    type NdefCloseSuccessCallback = (res: Nfcrwerror) => void;

    interface NdefCloseOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: NdefCloseCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: NdefCloseFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: NdefCloseSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type ConnectCompleteCallback = (res: Nfcrwerror) => void;
    /**
     * 接口调用失败的回调函数
     */
    type ConnectFailCallback = (res: Nfcrwerror) => void;
    /**
     * 接口调用成功的回调函数
     */
    type ConnectSuccessCallback = (res: Nfcrwerror) => void;

    interface NdefConnectOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: ConnectCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: ConnectFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: ConnectSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type GetHistoricalBytesCompleteCallback = (res: Nfcrwerror) => void;
    /**
     * 接口调用失败的回调函数
     */
    type GetHistoricalBytesFailCallback = (res: Nfcrwerror) => void;

    interface GetHistoricalBytesSuccessCallbackResult {
        /**
         * 返回历史二进制数据
         */
        histBytes: ArrayBuffer;
        errMsg: string;
    }

    /**
     * 接口调用成功的回调函数
     */
    type GetHistoricalBytesSuccessCallback = (
                result: GetHistoricalBytesSuccessCallbackResult
            ) => void;

    interface GetHistoricalBytesOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: GetHistoricalBytesCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: GetHistoricalBytesFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: GetHistoricalBytesSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type GetMaxTransceiveLengthCompleteCallback = (res: Nfcrwerror) => void;
    /**
     * 接口调用失败的回调函数
     */
    type GetMaxTransceiveLengthFailCallback = (res: Nfcrwerror) => void;

    interface GetMaxTransceiveLengthSuccessCallbackResult {
        /**
         * 最大传输长度
         */
        length: number;
        errMsg: string;
    }

    /**
     * 接口调用成功的回调函数
     */
    type GetMaxTransceiveLengthSuccessCallback = (
                result: GetMaxTransceiveLengthSuccessCallbackResult
            ) => void;

    interface GetMaxTransceiveLengthOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: GetMaxTransceiveLengthCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: GetMaxTransceiveLengthFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: GetMaxTransceiveLengthSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type IsConnectedCompleteCallback = (res: Nfcrwerror) => void;
    /**
     * 接口调用失败的回调函数
     */
    type IsConnectedFailCallback = (res: Nfcrwerror) => void;
    /**
     * 接口调用成功的回调函数
     */
    type IsConnectedSuccessCallback = (res: Nfcrwerror) => void;

    interface IsConnectedOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: IsConnectedCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: IsConnectedFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: IsConnectedSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type SetTimeoutCompleteCallback = (res: Nfcrwerror) => void;
    /**
     * 接口调用失败的回调函数
     */
    type SetTimeoutFailCallback = (res: Nfcrwerror) => void;
    /**
     * 接口调用成功的回调函数
     */
    type SetTimeoutSuccessCallback = (res: Nfcrwerror) => void;

    interface SetTimeoutOption {
        /**
         * 设置超时时间 (ms)
         */
        timeout: number;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: SetTimeoutCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: SetTimeoutFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: SetTimeoutSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type TransceiveCompleteCallback = (res: Nfcrwerror) => void;
    /**
     * 接口调用失败的回调函数
     */
    type TransceiveFailCallback = (res: Nfcrwerror) => void;

    interface TransceiveSuccessCallbackResult {
        data: ArrayBuffer;
        errMsg: string;
    }

    /**
     * 接口调用成功的回调函数
     */
    type TransceiveSuccessCallback = (
                result: TransceiveSuccessCallbackResult
            ) => void;

    interface TransceiveOption {
        /**
         * 需要传递的二进制数据
         */
        data: ArrayBuffer;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: TransceiveCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: TransceiveFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: TransceiveSuccessCallback;
    }

    interface IsoDep {
        /**
         *
         * 需要基础库： `2.11.2`
         *
         * 在插件中使用：支持
         *
         * 断开连接
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/IsoDep.close.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/IsoDep.close.html)
         */
        close(option?: NdefCloseOption): void;
        /**
         *
         * 需要基础库： `2.11.2`
         *
         * 在插件中使用：支持
         *
         * 连接 NFC 标签
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/IsoDep.connect.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/IsoDep.connect.html)
         */
        connect(option?: NdefConnectOption): void;
        /**
         *
         * 需要基础库： `2.11.2`
         *
         * 在插件中使用：支持
         *
         * 获取复位信息
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/IsoDep.getHistoricalBytes.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/IsoDep.getHistoricalBytes.html)
         */
        getHistoricalBytes(option?: GetHistoricalBytesOption): void;
        /**
         *
         * 需要基础库： `2.11.2`
         *
         * 在插件中使用：支持
         *
         * 获取最大传输长度
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/IsoDep.getMaxTransceiveLength.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/IsoDep.getMaxTransceiveLength.html)
         */
        getMaxTransceiveLength(option?: GetMaxTransceiveLengthOption): void;
        /**
         *
         * 需要基础库： `2.11.2`
         *
         * 在插件中使用：支持
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/IsoDep.isConnected.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/IsoDep.isConnected.html)
         */
        isConnected(option?: IsConnectedOption): void;
        /**
         *
         * 需要基础库： `2.11.2`
         *
         * 在插件中使用：支持
         *
         * 设置超时时间
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/IsoDep.setTimeout.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/IsoDep.setTimeout.html)
         */
        setTimeout(option: SetTimeoutOption): void;
        /**
         *
         * 需要基础库： `2.11.2`
         *
         * 在插件中使用：支持
         *
         * 发送数据
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/IsoDep.transceive.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/IsoDep.transceive.html)
         */
        transceive(option: TransceiveOption): void;
    }

    interface MifareClassic {
        /**
         *
         * 需要基础库： `2.11.2`
         *
         * 在插件中使用：支持
         *
         * 断开连接
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/MifareClassic.close.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/MifareClassic.close.html)
         */
        close(option?: NdefCloseOption): void;
        /**
         *
         * 需要基础库： `2.11.2`
         *
         * 在插件中使用：支持
         *
         * 连接 NFC 标签
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/MifareClassic.connect.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/MifareClassic.connect.html)
         */
        connect(option?: NdefConnectOption): void;
        /**
         *
         * 需要基础库： `2.11.2`
         *
         * 在插件中使用：支持
         *
         * 获取最大传输长度
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/MifareClassic.getMaxTransceiveLength.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/MifareClassic.getMaxTransceiveLength.html)
         */
        getMaxTransceiveLength(option?: GetMaxTransceiveLengthOption): void;
        /**
         *
         * 需要基础库： `2.11.2`
         *
         * 在插件中使用：支持
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/MifareClassic.isConnected.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/MifareClassic.isConnected.html)
         */
        isConnected(option?: IsConnectedOption): void;
        /**
         *
         * 需要基础库： `2.11.2`
         *
         * 在插件中使用：支持
         *
         * 设置超时时间
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/MifareClassic.setTimeout.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/MifareClassic.setTimeout.html)
         */
        setTimeout(option: SetTimeoutOption): void;
        /**
         *
         * 需要基础库： `2.11.2`
         *
         * 在插件中使用：支持
         *
         * 发送数据
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/MifareClassic.transceive.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/MifareClassic.transceive.html)
         */
        transceive(option: TransceiveOption): void;
    }

    interface MifareUltralight {
        /**
         *
         * 需要基础库： `2.11.2`
         *
         * 在插件中使用：支持
         *
         * 断开连接
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/MifareUltralight.close.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/MifareUltralight.close.html)
         */
        close(option?: NdefCloseOption): void;
        /**
         *
         * 需要基础库： `2.11.2`
         *
         * 在插件中使用：支持
         *
         * 连接 NFC 标签
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/MifareUltralight.connect.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/MifareUltralight.connect.html)
         */
        connect(option?: NdefConnectOption): void;
        /**
         *
         * 需要基础库： `2.11.2`
         *
         * 在插件中使用：支持
         *
         * 获取最大传输长度
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/MifareUltralight.getMaxTransceiveLength.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/MifareUltralight.getMaxTransceiveLength.html)
         */
        getMaxTransceiveLength(option?: GetMaxTransceiveLengthOption): void;
        /**
         *
         * 需要基础库： `2.11.2`
         *
         * 在插件中使用：支持
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/MifareUltralight.isConnected.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/MifareUltralight.isConnected.html)
         */
        isConnected(option?: IsConnectedOption): void;
        /**
         *
         * 需要基础库： `2.11.2`
         *
         * 在插件中使用：支持
         *
         * 设置超时时间
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/MifareUltralight.setTimeout.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/MifareUltralight.setTimeout.html)
         */
        setTimeout(option: SetTimeoutOption): void;
        /**
         *
         * 需要基础库： `2.11.2`
         *
         * 在插件中使用：支持
         *
         * 发送数据
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/MifareUltralight.transceive.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/MifareUltralight.transceive.html)
         */
        transceive(option: TransceiveOption): void;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type WriteNdefMessageCompleteCallback = (res: Nfcrwerror) => void;
    /**
     * 接口调用失败的回调函数
     */
    type WriteNdefMessageFailCallback = (res: Nfcrwerror) => void;
    /**
     * 接口调用成功的回调函数
     */
    type WriteNdefMessageSuccessCallback = (res: Nfcrwerror) => void;

    interface WriteNdefMessageOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: WriteNdefMessageCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: WriteNdefMessageFailCallback;
        /**
         * 二进制对象数组, 需要指明 id, type 以及 payload (均为 ArrayBuffer 类型)
         */
        records?: any[];
        /**
         * 接口调用成功的回调函数
         */
        success?: WriteNdefMessageSuccessCallback;
        /**
         * text 数组
         */
        texts?: any[];
        /**
         * uri 数组
         */
        uris?: any[];
    }

    interface Ndef {
        /**
         *
         * 需要基础库： `2.11.2`
         *
         * 在插件中使用：支持
         *
         * 断开连接
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/Ndef.close.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/Ndef.close.html)
         */
        close(option?: NdefCloseOption): void;
        /**
         *
         * 需要基础库： `2.11.2`
         *
         * 在插件中使用：支持
         *
         * 连接 NFC 标签
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/Ndef.connect.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/Ndef.connect.html)
         */
        connect(option?: NdefConnectOption): void;
        /**
         *
         * 需要基础库： `2.11.2`
         *
         * 在插件中使用：支持
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/Ndef.isConnected.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/Ndef.isConnected.html)
         */
        isConnected(option?: IsConnectedOption): void;
        /**
         *
         * 需要基础库： `2.11.2`
         *
         * 在插件中使用：支持
         *
         * 取消监听 Ndef 消息
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/Ndef.offNdefMessage.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/Ndef.offNdefMessage.html)
         */
        offNdefMessage(callback: (...args: any[]) => any): void;
        /**
         *
         * 需要基础库： `2.11.2`
         *
         * 在插件中使用：支持
         *
         * 监听 Ndef 消息
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/Ndef.onNdefMessage.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/Ndef.onNdefMessage.html)
         */
        onNdefMessage(callback: (...args: any[]) => any): void;
        /**
         *
         * 需要基础库： `2.11.2`
         *
         * 在插件中使用：支持
         *
         * 设置超时时间
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/Ndef.setTimeout.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/Ndef.setTimeout.html)
         */
        setTimeout(option: SetTimeoutOption): void;
        /**
         *
         * 需要基础库： `2.11.2`
         *
         * 在插件中使用：支持
         *
         * 重写 Ndef 标签内容
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/Ndef.writeNdefMessage.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/Ndef.writeNdefMessage.html)
         */
        writeNdefMessage(option: WriteNdefMessageOption): void;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type GetAtqaCompleteCallback = (res: Nfcrwerror) => void;
    /**
     * 接口调用失败的回调函数
     */
    type GetAtqaFailCallback = (res: Nfcrwerror) => void;

    interface GetAtqaSuccessCallbackResult {
        /**
         * 返回 ATQA/SENS_RES 数据
         */
        atqa: ArrayBuffer;
        errMsg: string;
    }

    /**
     * 接口调用成功的回调函数
     */
    type GetAtqaSuccessCallback = (result: GetAtqaSuccessCallbackResult) => void;

    interface GetAtqaOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: GetAtqaCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: GetAtqaFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: GetAtqaSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type GetSakCompleteCallback = (res: Nfcrwerror) => void;
    /**
     * 接口调用失败的回调函数
     */
    type GetSakFailCallback = (res: Nfcrwerror) => void;

    interface GetSakSuccessCallbackResult {
        /**
         * 返回 SAK/SEL_RES 数据
         */
        sak: number;
        errMsg: string;
    }

    /**
     * 接口调用成功的回调函数
     */
    type GetSakSuccessCallback = (result: GetSakSuccessCallbackResult) => void;

    interface GetSakOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: GetSakCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: GetSakFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: GetSakSuccessCallback;
    }

    interface NfcA {
        /**
         *
         * 需要基础库： `2.11.2`
         *
         * 在插件中使用：支持
         *
         * 断开连接
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NfcA.close.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NfcA.close.html)
         */
        close(option?: NdefCloseOption): void;
        /**
         *
         * 需要基础库： `2.11.2`
         *
         * 在插件中使用：支持
         *
         * 连接 NFC 标签
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NfcA.connect.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NfcA.connect.html)
         */
        connect(option?: NdefConnectOption): void;
        /**
         *
         * 需要基础库： `2.11.2`
         *
         * 在插件中使用：支持
         *
         * 获取ATQA信息
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NfcA.getAtqa.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NfcA.getAtqa.html)
         */
        getAtqa(option?: GetAtqaOption): void;
        /**
         *
         * 需要基础库： `2.11.2`
         *
         * 在插件中使用：支持
         *
         * 获取最大传输长度
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NfcA.getMaxTransceiveLength.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NfcA.getMaxTransceiveLength.html)
         */
        getMaxTransceiveLength(option?: GetMaxTransceiveLengthOption): void;
        /**
         *
         * 需要基础库： `2.11.2`
         *
         * 在插件中使用：支持
         *
         * 获取SAK信息
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NfcA.getSak.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NfcA.getSak.html)
         */
        getSak(option?: GetSakOption): void;
        /**
         *
         * 需要基础库： `2.11.2`
         *
         * 在插件中使用：支持
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NfcA.isConnected.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NfcA.isConnected.html)
         */
        isConnected(option?: IsConnectedOption): void;
        /**
         *
         * 需要基础库： `2.11.2`
         *
         * 在插件中使用：支持
         *
         * 设置超时时间
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NfcA.setTimeout.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NfcA.setTimeout.html)
         */
        setTimeout(option: SetTimeoutOption): void;
        /**
         *
         * 需要基础库： `2.11.2`
         *
         * 在插件中使用：支持
         *
         * 发送数据
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NfcA.transceive.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NfcA.transceive.html)
         */
        transceive(option: TransceiveOption): void;
    }

    interface NfcB {
        /**
         *
         * 需要基础库： `2.11.2`
         *
         * 在插件中使用：支持
         *
         * 断开连接
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NfcB.close.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NfcB.close.html)
         */
        close(option?: NdefCloseOption): void;
        /**
         *
         * 需要基础库： `2.11.2`
         *
         * 在插件中使用：支持
         *
         * 连接 NFC 标签
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NfcB.connect.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NfcB.connect.html)
         */
        connect(option?: NdefConnectOption): void;
        /**
         *
         * 需要基础库： `2.11.2`
         *
         * 在插件中使用：支持
         *
         * 获取最大传输长度
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NfcB.getMaxTransceiveLength.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NfcB.getMaxTransceiveLength.html)
         */
        getMaxTransceiveLength(option?: GetMaxTransceiveLengthOption): void;
        /**
         *
         * 需要基础库： `2.11.2`
         *
         * 在插件中使用：支持
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NfcB.isConnected.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NfcB.isConnected.html)
         */
        isConnected(option?: IsConnectedOption): void;
        /**
         *
         * 需要基础库： `2.11.2`
         *
         * 在插件中使用：支持
         *
         * 设置超时时间
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NfcB.setTimeout.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NfcB.setTimeout.html)
         */
        setTimeout(option: SetTimeoutOption): void;
        /**
         *
         * 需要基础库： `2.11.2`
         *
         * 在插件中使用：支持
         *
         * 发送数据
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NfcB.transceive.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NfcB.transceive.html)
         */
        transceive(option: TransceiveOption): void;
    }

    interface NfcF {
        /**
         *
         * 需要基础库： `2.11.2`
         *
         * 在插件中使用：支持
         *
         * 断开连接
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NfcF.close.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NfcF.close.html)
         */
        close(option?: NdefCloseOption): void;
        /**
         *
         * 需要基础库： `2.11.2`
         *
         * 在插件中使用：支持
         *
         * 连接 NFC 标签
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NfcF.connect.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NfcF.connect.html)
         */
        connect(option?: NdefConnectOption): void;
        /**
         *
         * 需要基础库： `2.11.2`
         *
         * 在插件中使用：支持
         *
         * 获取最大传输长度
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NfcF.getMaxTransceiveLength.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NfcF.getMaxTransceiveLength.html)
         */
        getMaxTransceiveLength(option?: GetMaxTransceiveLengthOption): void;
        /**
         *
         * 需要基础库： `2.11.2`
         *
         * 在插件中使用：支持
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NfcF.isConnected.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NfcF.isConnected.html)
         */
        isConnected(option?: IsConnectedOption): void;
        /**
         *
         * 需要基础库： `2.11.2`
         *
         * 在插件中使用：支持
         *
         * 设置超时时间
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NfcF.setTimeout.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NfcF.setTimeout.html)
         */
        setTimeout(option: SetTimeoutOption): void;
        /**
         *
         * 需要基础库： `2.11.2`
         *
         * 在插件中使用：支持
         *
         * 发送数据
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NfcF.transceive.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NfcF.transceive.html)
         */
        transceive(option: TransceiveOption): void;
    }

    interface NfcV {
        /**
         *
         * 需要基础库： `2.11.2`
         *
         * 在插件中使用：支持
         *
         * 断开连接
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NfcV.close.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NfcV.close.html)
         */
        close(option?: NdefCloseOption): void;
        /**
         *
         * 需要基础库： `2.11.2`
         *
         * 在插件中使用：支持
         *
         * 连接 NFC 标签
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NfcV.connect.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NfcV.connect.html)
         */
        connect(option?: NdefConnectOption): void;
        /**
         *
         * 需要基础库： `2.11.2`
         *
         * 在插件中使用：支持
         *
         * 获取最大传输长度
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NfcV.getMaxTransceiveLength.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NfcV.getMaxTransceiveLength.html)
         */
        getMaxTransceiveLength(option?: GetMaxTransceiveLengthOption): void;
        /**
         *
         * 需要基础库： `2.11.2`
         *
         * 在插件中使用：支持
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NfcV.isConnected.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NfcV.isConnected.html)
         */
        isConnected(option?: IsConnectedOption): void;
        /**
         *
         * 需要基础库： `2.11.2`
         *
         * 在插件中使用：支持
         *
         * 设置超时时间
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NfcV.setTimeout.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NfcV.setTimeout.html)
         */
        setTimeout(option: SetTimeoutOption): void;
        /**
         *
         * 需要基础库： `2.11.2`
         *
         * 在插件中使用：支持
         *
         * 发送数据
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NfcV.transceive.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NfcV.transceive.html)
         */
        transceive(option: TransceiveOption): void;
    }

    /**
     * 需要基础库： `2.11.2`
     */
    interface NFCAdapter {
        /**
         * 标签类型枚举
         */
        tech: TechType;
        /**
         *
         * 需要基础库： `2.11.2`
         *
         * 在插件中使用：支持
         *
         * 移除 NFC Tag的监听函数
         *
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NFCAdapter.offDiscovered.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NFCAdapter.offDiscovered.html)
         */
        offDiscovered(listener?: OffDiscoveredCallback): void;
        /**
         *
         * 需要基础库： `2.11.2`
         *
         * 在插件中使用：支持
         *
         * 监听 NFC Tag
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NFCAdapter.onDiscovered.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NFCAdapter.onDiscovered.html)
         */
        onDiscovered(listener: OnDiscoveredCallback): void;
        /**
         *
         * 需要基础库： `2.11.2`
         *
         * 在插件中使用：支持
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NFCAdapter.startDiscovery.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NFCAdapter.startDiscovery.html)
         */
        startDiscovery(option?: StartDiscoveryOption): void;
        /**
         *
         * 需要基础库： `2.11.2`
         *
         * 在插件中使用：支持
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NFCAdapter.stopDiscovery.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NFCAdapter.stopDiscovery.html)
         */
        stopDiscovery(option?: StopDiscoveryOption): void;
        /**
         *
         * 需要基础库： `2.11.2`
         *
         * 在插件中使用：支持
         *
         * 获取IsoDep实例，实例支持ISO-DEP (ISO 14443-4)标准的读写
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NFCAdapter.getIsoDep.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NFCAdapter.getIsoDep.html)
         */
        getIsoDep(): IsoDep;
        /**
         *
         * 需要基础库： `2.11.2`
         *
         * 在插件中使用：支持
         *
         * 获取MifareClassic实例，实例支持MIFARE Classic标签的读写
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NFCAdapter.getMifareClassic.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NFCAdapter.getMifareClassic.html)
         */
        getMifareClassic(): MifareClassic;
        /**
         *
         * 需要基础库： `2.11.2`
         *
         * 在插件中使用：支持
         *
         * 获取MifareUltralight实例，实例支持MIFARE Ultralight标签的读写
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NFCAdapter.getMifareUltralight.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NFCAdapter.getMifareUltralight.html)
         */
        getMifareUltralight(): MifareUltralight;
        /**
         *
         * 需要基础库： `2.11.2`
         *
         * 在插件中使用：支持
         *
         * 获取Ndef实例，实例支持对NDEF格式的NFC标签上的NDEF数据的读写
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NFCAdapter.getNdef.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NFCAdapter.getNdef.html)
         */
        getNdef(): Ndef;
        /**
         *
         * 需要基础库： `2.11.2`
         *
         * 在插件中使用：支持
         *
         * 获取NfcA实例，实例支持NFC-A (ISO 14443-3A)标准的读写
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NFCAdapter.getNfcA.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NFCAdapter.getNfcA.html)
         */
        getNfcA(): NfcA;
        /**
         *
         * 需要基础库： `2.11.2`
         *
         * 在插件中使用：支持
         *
         * 获取NfcB实例，实例支持NFC-B (ISO 14443-3B)标准的读写
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NFCAdapter.getNfcB.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NFCAdapter.getNfcB.html)
         */
        getNfcB(): NfcB;
        /**
         *
         * 需要基础库： `2.11.2`
         *
         * 在插件中使用：支持
         *
         * 获取NfcF实例，实例支持NFC-F (JIS 6319-4)标准的读写
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NFCAdapter.getNfcF.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NFCAdapter.getNfcF.html)
         */
        getNfcF(): NfcF;
        /**
         *
         * 需要基础库： `2.11.2`
         *
         * 在插件中使用：支持
         *
         * 获取NfcV实例，实例支持NFC-V (ISO 15693)标准的读写
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NFCAdapter.getNfcV.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/NFCAdapter.getNfcV.html)
         */
        getNfcV(): NfcV;
    }

    /**
     * 需要基础库： `2.7.0`
     *
     * 图片对象
     */
    interface Image {
        /**
         * 图片的真实高度
         */
        height: number;
        /**
         * 图片加载发生错误后触发的回调函数
         */
        onerror: (...args: any[]) => any;
        /**
         * 图片加载完成后触发的回调函数
         */
        onload: (...args: any[]) => any;
        /**
         * 需要基础库： `2.13.0`
         *
         * `origin`: 发送完整的referrer; `no-referrer`: 不发送。格式固定为 `https://servicewechat.com/{appid}/{version}/page-frame.html`，其中 {appid} 为小程序的 appid，{version} 为小程序的版本号，版本号为 0 表示为开发版、体验版以及审核版本，版本号为 devtools 表示为开发者工具，其余为正式版本；
         */
        referrerPolicy: string;
        /**
         * 图片的 URL。v2.11.0 起支持传递 base64 Data URI
         */
        src: string;
        /**
         * 图片的真实宽度
         */
        width: number;
    }

    /**
     * 需要基础库： `2.7.0`
     *
     * 离屏 canvas 实例，可通过 [uni.createOffscreenCanvas](https://developers.weixin.qq.com/miniprogram/dev/api/canvas/wx.createOffscreenCanvas.html) 创建。
     */
    interface OffscreenCanvas {
        /**
         * 画布高度
         */
        height: number;
        /**
         * 画布宽度
         */
        width: number;
        /**
         *
         * 需要基础库： `2.7.3`
         *
         * 在插件中使用：需要基础库 `2.16.1`
         *
         * 创建一个图片对象。支持在 2D Canvas 和 WebGL Canvas 下使用, 但不支持混用 2D 和 WebGL 的方法。
         *
         * ****
         *
         * 注意不允许混用 webgl 和 2d 画布创建的图片对象，使用时请注意尽量使用 canvas 自身的 `createImage` 创建图片对象。
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/canvas/OffscreenCanvas.createImage.html](https://developers.weixin.qq.com/miniprogram/dev/api/canvas/OffscreenCanvas.createImage.html)
         */
        createImage(): Image;
        /**
         *
         * 需要基础库： `2.7.0`
         *
         * 在插件中使用：需要基础库 `2.16.1`
         *
         * 该方法返回 OffscreenCanvas 的绘图上下文
         *
         * ****
         *
         * 注意不允许混用 webgl 和 2d 绘图上下文，传入的 contextType 必须要与 `wx.createOffscreenCanvas` 传入的 type 类型一致。
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/canvas/OffscreenCanvas.getContext.html](https://developers.weixin.qq.com/miniprogram/dev/api/canvas/OffscreenCanvas.getContext.html)
         */
        getContext(contextType: "webgl" | "2d"): any;
    }

    interface CreateOffscreenCanvasOption {
        /**
         * 在自定义组件下，当前组件实例的 this
         */
        compInst?: any;
        /**
         * 画布高度
         */
        height?: number;
        /**
         * 创建的离屏 canvas 类型
         *
         * 可选值：
         * - 'webgl': webgl类型上下文;
         * - '2d': 2d类型上下文;
         */
        type?: "webgl" | "2d";
        /**
         * 画布宽度
         */
        width?: number;
    }

    /**
     * 单条性能数据。具体数据口径请参考[性能数据文档]((performance/perf_data##_1-4-%E9%80%9A%E8%BF%87-wx-getPerformance-%E5%9C%A8%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%86%85%E8%8E%B7%E5%8F%96))
     */
    interface PerformanceEntry {
        /**
         * 需要基础库： `2.24.0`
         *
         * 解析域名结束时间。仅 resourceTiming 指标有效。
         */
        domainLookupEnd: number;
        /**
         * 需要基础库： `2.24.0`
         *
         * 解析域名开始时间。仅 resourceTiming 指标有效。
         */
        domainLookupStart: number;
        /**
         * 耗时 ms。仅对于表示阶段的指标有效。
         */
        duration: number;
        /**
         * 指标类型
         *
         * 可选值：
         * - 'navigation': 路由;
         * - 'render': 渲染;
         * - 'script': 脚本;
         */
        entryType: "navigation" | "render" | "script";
        /**
         * 需要基础库： `2.21.2`
         *
         * 注入文件列表。仅 evaluateScript 指标有效。
         */
        fileList: string[];
        /**
         * 需要基础库： `2.21.2`
         *
         * 首次渲染参数在渲染层收到的时间。仅 firstRender 指标有效。
         */
        initDataRecvTime: number;
        /**
         * 需要基础库： `2.21.2`
         *
         * 首次渲染参数从逻辑层发出的时间。仅 firstRender 指标有效。
         */
        initDataSendTime: number;
        /**
         * 需要基础库： `2.24.0`
         *
         * 初始化性能条目的资源类型。仅 resourceTiming 指标有效。
         *
         * 可选值：
         * - 'audio': 音频;
         * - 'cover-image': cover-image 组件的图片;
         * - 'image': 组件的图片;
         * - 'open-data': 组件的图片;
         */
        initiatorType: "audio" | "cover-image" | "image" | "open-data";
        /**
         * 分包名，主包表示为 __APP__ (2.21.2 开始)。仅 evaluateScript 指标有效。
         */
        moduleName: string;
        /**
         * 指标名称
         *
         * 可选值：
         * - 'appLaunch': 小程序启动耗时。(entryType: navigation);
         * - 'route': 路由处理耗时。(entryType: navigation);
         * - 'firstRender': 页面首次渲染耗时。(entryType: render);
         * - 'firstPaint': 页面首次绘制(FP)时间点，无 duration。（iOS 不支持）(entryType: render);
         * - 'firstContentfulPaint': 页面首次内容绘制(FCP)时间点，无 duration。（iOS 14.5 以下版本不支持）(entryType: render);
         * - 'largestContentfulPaint': 页面最大内容绘制(LCP)时间点，无 duration。（iOS 不支持）(entryType: render);
         * - 'evaluateScript': 逻辑层 JS 代码注入耗时。(entryType: script);
         * - 'downloadPackage': 代码包下载耗时。(entryType: loadPackage);
         * - 'resourceTiming': 视图层资源加载耗时。(entryType: resource);
         */
        name: "appLaunch" | "route" | "firstRender" | "firstPaint" | "firstContentfulPaint" | "largestContentfulPaint" | "evaluateScript" | "downloadPackage" | "resourceTiming";
        /**
         * 路由真正响应开始时间。仅 navigation 类型指标有效。
         */
        navigationStart: number;
        /**
         * 路由详细类型，与小程序路由方法对应。仅 navigation 类型指标有效。
         */
        navigationType: string;
        /**
         * 需要基础库： `2.24.0`
         *
         * 代码包名称。仅 downloadPackage 指标有效。
         */
        packageName: string;
        /**
         * 需要基础库： `2.24.0`
         *
         * 代码包大小。仅 downloadPackage 指标有效。
         */
        packageSize: number;
        /**
         * 需要基础库： `2.23.1`
         *
         * path 对应页面实例 Id（随机生成，不保证递增）。仅 render/navigation 指标有效。
         */
        pageId: number;
        /**
         * 页面路径。仅 render 和 navigation 类型指标有效。
         */
        path: string;
        /**
         * 需要基础库： `2.23.1`
         *
         * referrerPath对应页面实例 Id（随机生成，不保证递增）。仅 route 指标有效。
         */
        referrerPageId: number;
        /**
         * 需要基础库： `2.23.1`
         *
         * 页面跳转来源页面路径。仅 route 指标有效。
         */
        referrerPath: number;
        /**
         * 开始时间，不同指标的具体含义会有差异。
         */
        startTime: number;
        /**
         * 需要基础库： `2.24.0`
         *
         * 表示获取资源的大小（以八位字节为单位）的数字。仅 resourceTiming 指标有效。(iOS 不支持）
         */
        transferSize: number;
        /**
         * 需要基础库： `2.24.0`
         *
         * 资源路径。仅 resourceTiming 指标有效。
         */
        uri: string;
        /**
         * 需要基础库： `2.21.2`
         *
         * 渲染层代码注入完成时间。仅 firstRender 指标有效。
         */
        viewLayerReadyTime: number;
        /**
         * 需要基础库： `2.21.2`
         *
         * 渲染层执行渲染结束时间。仅 firstRender 指标有效。
         */
        viewLayerRenderEndTime: number;
        /**
         * 需要基础库： `2.21.2`
         *
         * 渲染层执行渲染开始时间。仅 firstRender 指标有效。
         */
        viewLayerRenderStartTime: number;
    }

    /**
     * 设置 type 监听单个类型的指标，设置 entryTypes 监听多个类型指标。
     */
    interface ObserveOption {
        /**
         * 指标类型列表。不能和 type 同时使用。
         */
        entryTypes?: string[];
        /**
         * 指标类型。不能和 entryTypes 同时使用
         *
         * 可选值：
         * - 'navigation': 路由;
         * - 'render': 渲染;
         * - 'script': 脚本;
         * - 'loadPackage': 代码包下载;
         */
        type?: "navigation" | "render" | "script" | "loadPackage";
    }

    /**
     * 需要基础库： `2.11.0`
     *
     * PerformanceObserver 对象，用于监听性能相关事件
     */
    interface PerformanceObserver {
        /**
         * 获取当前支持的所有性能指标类型
         */
        supportedEntryTypes: any[];
        /**
         *
         * 需要基础库： `2.11.0`
         *
         * 在插件中使用：不支持
         *
         * 停止监听
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/performance/PerformanceObserver.disconnect.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/performance/PerformanceObserver.disconnect.html)
         */
        disconnect(): void;
        /**
         *
         * 需要基础库： `2.11.0`
         *
         * 在插件中使用：不支持
         *
         * 开始监听
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/performance/PerformanceObserver.observe.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/performance/PerformanceObserver.observe.html)
         */
        observe(options: ObserveOption): void;
    }

    interface Performance {
        /**
         *
         * 需要基础库： `2.11.0`
         *
         * 在插件中使用：不支持
         *
         * 该方法返回当前缓冲区中的所有性能数据
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/performance/Performance.getEntries.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/performance/Performance.getEntries.html)
         */
        getEntries(): PerformanceEntry[];
        /**
         *
         * 需要基础库： `2.11.0`
         *
         * 在插件中使用：不支持
         *
         * 获取当前缓冲区中所有名称为 [name] 且类型为 [entryType] 的性能数据
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/performance/Performance.getEntriesByName.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/performance/Performance.getEntriesByName.html)
         */
        getEntriesByName(name: string, entryType?: string): PerformanceEntry[];
        /**
         *
         * 需要基础库： `2.11.0`
         *
         * 在插件中使用：不支持
         *
         * 获取当前缓冲区中所有类型为 [entryType] 的性能数据
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/performance/Performance.getEntriesByType.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/performance/Performance.getEntriesByType.html)
         */
        getEntriesByType(entryType: string): PerformanceEntry[];
        /**
         *
         * 需要基础库： `2.11.0`
         *
         * 在插件中使用：不支持
         *
         * 设置缓冲区大小，默认缓冲 30 条性能数据
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/performance/Performance.setBufferSize.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/performance/Performance.setBufferSize.html)
         */
        setBufferSize(size: number): void;
        /**
         *
         * 需要基础库： `2.11.0`
         *
         * 在插件中使用：不支持
         *
         * 创建全局性能事件监听器
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/performance/Performance.createObserver.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/performance/Performance.createObserver.html)
         */
        createObserver(callback: (...args: any[]) => any): PerformanceObserver;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type PreDownloadSubpackageCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type PreDownloadSubpackageFailCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用成功的回调函数
     */
    type PreDownloadSubpackageSuccessCallback = (
                res: GeneralCallbackResult
            ) => void;

    interface PreDownloadSubpackageOption {
        /**
         * 分包的类型。目前仅支持填 "workers"，表示 workers 分包。
         */
        packageType: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: PreDownloadSubpackageCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: PreDownloadSubpackageFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: PreDownloadSubpackageSuccessCallback;
    }

    interface PreDownloadSubpackageTaskOnProgressUpdateListenerResult {
        /**
         * 分包下载进度百分比
         */
        progress: number;
        /**
         * 预期需要下载的数据总长度，单位 Bytes
         */
        totalBytesExpectedToWrite: number;
        /**
         * 已经下载的数据长度，单位 Bytes
         */
        totalBytesWritten: number;
    }

    /**
     * 分包加载进度变化事件的监听函数
     */
    type PreDownloadSubpackageTaskOnProgressUpdateCallback = (
                result: PreDownloadSubpackageTaskOnProgressUpdateListenerResult
            ) => void;

    interface PreDownloadSubpackageTask {
        /**
         *
         * 需要基础库： `2.27.3`
         *
         * 在插件中使用：不支持
         *
         * 监听分包加载进度变化事件
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/subpackage/PreDownloadSubpackageTask.onProgressUpdate.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/subpackage/PreDownloadSubpackageTask.onProgressUpdate.html)
         */
        onProgressUpdate(listener: PreDownloadSubpackageTaskOnProgressUpdateCallback): void;
    }

    interface CurrentState {
        /**
         * 当前缓存中的日志条数
         */
        logCount: number;
        /**
         * 当前缓存中最大可存日志条数
         */
        maxLogCount: number;
        /**
         * 当前缓存最大可用空间，以字节为单位
         */
        maxSize: number;
        /**
         * 当前缓存中已使用空间，以字节为单位
         */
        size: number;
    }

    interface RealtimeTagLogManager {
        /**
         *
         * 需要基础库： `2.16.0`
         *
         * 在插件中使用：需要基础库 `2.16.0`
         *
         * 添加过滤关键字
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/debug/RealtimeTagLogManager.addFilterMsg.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/debug/RealtimeTagLogManager.addFilterMsg.html)
         */
        addFilterMsg(msg: string): void;
        /**
         *
         * 需要基础库： `2.16.0`
         *
         * 在插件中使用：需要基础库 `2.16.0`
         *
         * 写 error 日志
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/debug/RealtimeTagLogManager.error.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/debug/RealtimeTagLogManager.error.html)
         */
        error(key: string, value: any): void;
        /**
         *
         * 需要基础库： `2.16.0`
         *
         * 在插件中使用：需要基础库 `2.16.0`
         *
         * 写 info 日志
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/debug/RealtimeTagLogManager.info.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/debug/RealtimeTagLogManager.info.html)
         */
        info(key: string, value: any): void;
        /**
         *
         * 需要基础库： `2.16.0`
         *
         * 在插件中使用：需要基础库 `2.16.0`
         *
         * 设置过滤关键字
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/debug/RealtimeTagLogManager.setFilterMsg.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/debug/RealtimeTagLogManager.setFilterMsg.html)
         */
        setFilterMsg(msg: string): void;
        /**
         *
         * 需要基础库： `2.16.0`
         *
         * 在插件中使用：需要基础库 `2.16.0`
         *
         * 写 warn 日志
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/debug/RealtimeTagLogManager.warn.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/debug/RealtimeTagLogManager.warn.html)
         */
        warn(key: string, value: any): void;
    }

    interface RealtimeLogManager {
        /**
         *
         * 需要基础库： `2.19.4`
         *
         * 在插件中使用：不支持
         *
         * 实时日志会将一定时间间隔内缓存的日志聚合上报，如果该时间内缓存的内容超出限制，则会被丢弃。此方法可以获取当前缓存剩余空间。
         *
         * > 注意：基础库内部在对日志进行上报时会补充一些结构化数据，如果遇到上报溢出的情况也会补充警告日志，所以此方法获取到的当前占用信息会比预期的大一些。
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/debug/RealtimeLogManager.getCurrentState.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/debug/RealtimeLogManager.getCurrentState.html)
         */
        getCurrentState(): CurrentState;
        /**
         *
         * 需要基础库： `2.8.1`
         *
         * 在插件中使用：不支持
         *
         * 添加过滤关键字，暂不支持在插件使用
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/debug/RealtimeLogManager.addFilterMsg.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/debug/RealtimeLogManager.addFilterMsg.html)
         */
        addFilterMsg(msg: string): void;
        /**
         *
         * 需要基础库： `2.7.1`
         *
         * 在插件中使用：不支持
         *
         * 写 error 日志，暂不支持在插件使用
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/debug/RealtimeLogManager.error.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/debug/RealtimeLogManager.error.html)
         */
        error(args: any[]): void;
        /**
         *
         * 需要基础库： `2.9.1`
         *
         * 在插件中使用：不支持
         *
         * 设置实时日志page参数所在的页面，暂不支持在插件使用
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/debug/RealtimeLogManager.in.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/debug/RealtimeLogManager.in.html)
         */
        in(pageInstance: any): void;
        /**
         *
         * 需要基础库： `2.7.1`
         *
         * 在插件中使用：不支持
         *
         * 写 info 日志，暂不支持在插件使用
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/debug/RealtimeLogManager.info.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/debug/RealtimeLogManager.info.html)
         */
        info(args: any[]): void;
        /**
         *
         * 需要基础库： `2.7.3`
         *
         * 在插件中使用：不支持
         *
         * 设置过滤关键字，暂不支持在插件使用
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/debug/RealtimeLogManager.setFilterMsg.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/debug/RealtimeLogManager.setFilterMsg.html)
         */
        setFilterMsg(msg: string): void;
        /**
         *
         * 需要基础库： `2.7.1`
         *
         * 在插件中使用：不支持
         *
         * 写 warn 日志，暂不支持在插件使用
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/debug/RealtimeLogManager.warn.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/debug/RealtimeLogManager.warn.html)
         */
        warn(args: any[]): void;
        /**
         *
         * 需要基础库： `2.16.0`
         *
         * 在插件中使用：需要基础库 `2.16.0`
         *
         * 获取给定标签的日志管理器实例，目前只支持在插件使用
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/debug/RealtimeLogManager.tag.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/debug/RealtimeLogManager.tag.html)
         */
        tag(tagName: string): RealtimeTagLogManager;
    }

    interface CreateTCPSocketOption {
        /**
         * 需要基础库： `3.6.4`
         *
         * 套接字族，必须是 IPv4 或者 IPv6，默认是 IPv4
         *
         * 可选值：
         * - 'ipv4': IPv4;
         * - 'ipv6': IPv6;
         */
        type?: "ipv4" | "ipv6";
    }

    interface BindWifiOption {
        /**
         * 当前 wifi 网络的 BSSID ，可通过 wx.getConnectedWifi 获取
         */
        BSSID: string;
    }

    interface TCPSocketConnectOption {
        /**
         * 套接字要连接的地址
         */
        address: string;
        /**
         * 套接字要连接的端口
         */
        port: number;
        /**
         * 需要基础库： `3.4.0`
         *
         * 是否开启 HttpDNS 服务。如开启，需要同时填入 httpDNSServiceId 。 HttpDNS 用法详见 [移动解析HttpDNS](https://developers.weixin.qq.com/miniprogram/dev/framework/ability/HTTPDNS.html)
         */
        enableHttpDNS?: boolean;
        /**
         * 需要基础库： `3.4.0`
         *
         * HttpDNS 服务商 Id。 HttpDNS 用法详见 [移动解析HttpDNS](https://developers.weixin.qq.com/miniprogram/dev/framework/ability/HTTPDNS.html)
         */
        httpDNSServiceId?: string;
        /**
         * 套接字要连接的超时时间，默认为 2s
         */
        timeout?: number;
    }

    /**
     * onBindWifi 传入的监听函数。不传此参数则移除所有监听函数。
     */
    type OffBindWifiCallback = (res: GeneralCallbackResult) => void;
    /**
     * onClose 传入的监听函数。不传此参数则移除所有监听函数。
     */
    type UDPSocketOffCloseCallback = (res: GeneralCallbackResult) => void;

    /**
     * 需要基础库： `3.4.0`
     *
     * 异常信息
     */
    interface TCPExceptionReason {
        /**
         * 错误原因
         */
        errMsg: string;
        /**
         * 错误码
         */
        errno: string;
    }

    /**
     * 需要基础库： `3.4.0`
     *
     * 网络请求过程中的一些异常信息（例如：TCPSocket.connect 传了 enableHttpDNS: true，但最终未使用 HttpDNS 时，exception 就会说明未使用 HttpDNS 的原因）
     */
    interface Exception {
        /**
         * 需要基础库： `3.4.0`
         *
         * 异常信息
         */
        reasons: TCPExceptionReason[];
    }

    /**
     * 需要基础库： `3.4.1`
     *
     * 接收端地址信息（目前仅iOS和Android端支持）
     */
    interface OnConnectListenerResultLocalInfo {
        /**
         * 需要基础库： `3.4.1`
         *
         * 接收消息的 socket 的地址
         */
        address: string;
        /**
         * 需要基础库： `3.4.1`
         *
         * 使用的协议族，为 IPv4 或者 IPv6
         */
        family: string;
        /**
         * 需要基础库： `3.4.1`
         *
         * 端口号
         */
        port: number;
    }

    /**
     * 需要基础库： `3.4.1`
     *
     * 发送端地址信息（目前仅iOS和Android端支持）
     */
    interface OnConnectListenerResultRemoteInfo {
        /**
         * 需要基础库： `3.4.1`
         *
         * 发送消息的 socket 的地址
         */
        address: string;
        /**
         * 需要基础库： `3.4.1`
         *
         * 使用的协议族，为 IPv4 或者 IPv6
         */
        family: string;
        /**
         * 需要基础库： `3.4.1`
         *
         * 端口号
         */
        port: number;
    }

    interface OnConnectListenerResult {
        /**
         * 需要基础库： `3.4.0`
         *
         * 网络请求过程中的一些异常信息（例如：TCPSocket.connect 传了 enableHttpDNS: true，但最终未使用 HttpDNS 时，exception 就会说明未使用 HttpDNS 的原因）
         */
        exception: Exception;
        /**
         * 需要基础库： `3.4.1`
         *
         * 接收端地址信息（目前仅iOS和Android端支持）
         */
        localInfo: OnConnectListenerResultLocalInfo;
        /**
         * 需要基础库： `3.4.1`
         *
         * 发送端地址信息（目前仅iOS和Android端支持）
         */
        remoteInfo: OnConnectListenerResultRemoteInfo;
        /**
         * 需要基础库： `3.4.0`
         *
         * 本次连接是否使用了 HttpDNS
         */
        useHttpDNS: boolean;
    }

    /**
     * onConnect 传入的监听函数。不传此参数则移除所有监听函数。
     */
    type OffConnectCallback = (result: OnConnectListenerResult) => void;
    /**
     * onError 传入的监听函数。不传此参数则移除所有监听函数。
     */
    type UDPSocketOffErrorCallback = (result: GeneralCallbackResult) => void;

    interface OnMessageListenerResultLocalInfo {
        /**
         * 接收消息的 socket 的地址
         */
        address: string;
        /**
         * 使用的协议族，为 IPv4 或者 IPv6
         */
        family: string;
        /**
         * 端口号
         */
        port: number;
    }

    /**
     * 发送端地址信息
     */
    interface TCPSocketOnMessageListenerResultRemoteInfo {
        /**
         * 发送消息的 socket 的地址
         */
        address: string;
        /**
         * 使用的协议族，为 IPv4 或者 IPv6
         */
        family: string;
        /**
         * 端口号
         */
        port: number;
    }

    interface TCPSocketOnMessageListenerResult {
        /**
         * 接收端地址信息
         */
        localInfo: OnMessageListenerResultLocalInfo;
        /**
         * 收到的消息
         */
        message: ArrayBuffer;
        /**
         * 发送端地址信息
         */
        remoteInfo: TCPSocketOnMessageListenerResultRemoteInfo;
    }

    /**
     * onMessage 传入的监听函数。不传此参数则移除所有监听函数。
     */
    type TCPSocketOffMessageCallback = (
                result: TCPSocketOnMessageListenerResult
            ) => void;
    /**
     * 当一个 socket 绑定当前 wifi 网络成功时触发该事件的监听函数
     */
    type OnBindWifiCallback = (res: GeneralCallbackResult) => void;
    type UDPSocketOnCloseCallback = (res: GeneralCallbackResult) => void;
    /**
     * 当一个 socket 连接成功建立的时候触发该事件的监听函数
     */
    type OnConnectCallback = (result: OnConnectListenerResult) => void;
    type UDPSocketOnErrorCallback = (result: GeneralCallbackResult) => void;
    /**
     * 当接收到数据的时触发该事件的监听函数
     */
    type TCPSocketOnMessageCallback = (
                result: TCPSocketOnMessageListenerResult
            ) => void;

    interface TCPSocket {
        /**
         *
         * 需要基础库： `2.25.0`
         *
         * 在插件中使用：不支持
         *
         * 将 TCP Socket 绑定到当前 wifi 网络，成功后会触发 onBindWifi 事件（仅安卓支持）
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/network/tcp/TCPSocket.bindWifi.html](https://developers.weixin.qq.com/miniprogram/dev/api/network/tcp/TCPSocket.bindWifi.html)
         */
        bindWifi(options: BindWifiOption): void;
        /**
         *
         * 在插件中使用：不支持
         *
         * 关闭连接
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/network/tcp/TCPSocket.close.html](https://developers.weixin.qq.com/miniprogram/dev/api/network/tcp/TCPSocket.close.html)
         */
        close(): void;
        /**
         *
         * 在插件中使用：不支持
         *
         * 在给定的套接字上启动连接
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/network/tcp/TCPSocket.connect.html](https://developers.weixin.qq.com/miniprogram/dev/api/network/tcp/TCPSocket.connect.html)
         */
        connect(options: TCPSocketConnectOption): void;
        /**
         *
         * 需要基础库： `2.25.0`
         *
         * 在插件中使用：不支持
         *
         * 移除当一个 socket 绑定当前 wifi 网络成功时触发该事件的监听函数
         *
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/network/tcp/TCPSocket.offBindWifi.html](https://developers.weixin.qq.com/miniprogram/dev/api/network/tcp/TCPSocket.offBindWifi.html)
         */
        offBindWifi(listener?: OffBindWifiCallback): void;
        /**
         *
         * 在插件中使用：不支持
         *
         * 移除一旦 socket 完全关闭就发出该事件的监听函数
         *
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/network/tcp/TCPSocket.offClose.html](https://developers.weixin.qq.com/miniprogram/dev/api/network/tcp/TCPSocket.offClose.html)
         */
        offClose(listener?: UDPSocketOffCloseCallback): void;
        /**
         *
         * 在插件中使用：不支持
         *
         * 移除当一个 socket 连接成功建立的时候触发该事件的监听函数
         *
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/network/tcp/TCPSocket.offConnect.html](https://developers.weixin.qq.com/miniprogram/dev/api/network/tcp/TCPSocket.offConnect.html)
         */
        offConnect(listener?: OffConnectCallback): void;
        /**
         *
         * 在插件中使用：不支持
         *
         * 移除当错误发生时触发的监听函数
         *
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/network/tcp/TCPSocket.offError.html](https://developers.weixin.qq.com/miniprogram/dev/api/network/tcp/TCPSocket.offError.html)
         */
        offError(listener?: UDPSocketOffErrorCallback): void;
        /**
         *
         * 在插件中使用：不支持
         *
         * 移除当接收到数据的时触发该事件的监听函数
         *
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/network/tcp/TCPSocket.offMessage.html](https://developers.weixin.qq.com/miniprogram/dev/api/network/tcp/TCPSocket.offMessage.html)
         */
        offMessage(listener?: TCPSocketOffMessageCallback): void;
        /**
         *
         * 需要基础库： `2.25.0`
         *
         * 在插件中使用：不支持
         *
         * 监听当一个 socket 绑定当前 wifi 网络成功时触发该事件
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/network/tcp/TCPSocket.onBindWifi.html](https://developers.weixin.qq.com/miniprogram/dev/api/network/tcp/TCPSocket.onBindWifi.html)
         */
        onBindWifi(listener: OnBindWifiCallback): void;
        /**
         *
         * 在插件中使用：不支持
         *
         * 监听一旦 socket 完全关闭就发出该事件
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/network/tcp/TCPSocket.onClose.html](https://developers.weixin.qq.com/miniprogram/dev/api/network/tcp/TCPSocket.onClose.html)
         */
        onClose(listener: UDPSocketOnCloseCallback): void;
        /**
         *
         * 在插件中使用：不支持
         *
         * 监听当一个 socket 连接成功建立的时候触发该事件
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/network/tcp/TCPSocket.onConnect.html](https://developers.weixin.qq.com/miniprogram/dev/api/network/tcp/TCPSocket.onConnect.html)
         */
        onConnect(listener: OnConnectCallback): void;
        /**
         *
         * 在插件中使用：不支持
         *
         * 监听当错误发生时触发
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/network/tcp/TCPSocket.onError.html](https://developers.weixin.qq.com/miniprogram/dev/api/network/tcp/TCPSocket.onError.html)
         */
        onError(listener: UDPSocketOnErrorCallback): void;
        /**
         *
         * 在插件中使用：不支持
         *
         * 监听当接收到数据的时触发该事件
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/network/tcp/TCPSocket.onMessage.html](https://developers.weixin.qq.com/miniprogram/dev/api/network/tcp/TCPSocket.onMessage.html)
         */
        onMessage(listener: TCPSocketOnMessageCallback): void;
        /**
         *
         * 在插件中使用：不支持
         *
         * 在 socket 上发送数据
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/network/tcp/TCPSocket.write.html](https://developers.weixin.qq.com/miniprogram/dev/api/network/tcp/TCPSocket.write.html)
         */
        write(data: string | ArrayBuffer): void;
    }

    interface UDPSocketConnectOption {
        /**
         * 要发消息的地址
         */
        address: string;
        /**
         * 要发送消息的端口号
         */
        port: number;
    }

    /**
     * onListening 传入的监听函数。不传此参数则移除所有监听函数。
     */
    type OffListeningCallback = (res: GeneralCallbackResult) => void;

    /**
     * 发送端地址信息
     */
    interface UDPSocketOnMessageListenerResultRemoteInfo {
        /**
         * 发送消息的 socket 的地址
         */
        address: string;
        /**
         * 使用的协议族，为 IPv4 或者 IPv6
         */
        family: string;
        /**
         * 端口号
         */
        port: number;
        /**
         * message 的大小，单位：字节
         */
        size: number;
    }

    interface UDPSocketOnMessageListenerResult {
        /**
         * 接收端地址信息，2.18.0 起支持
         */
        localInfo: OnMessageListenerResultLocalInfo;
        /**
         * 收到的消息。消息长度需要小于4096。
         */
        message: ArrayBuffer;
        /**
         * 发送端地址信息
         */
        remoteInfo: UDPSocketOnMessageListenerResultRemoteInfo;
    }

    /**
     * onMessage 传入的监听函数。不传此参数则移除所有监听函数。
     */
    type UDPSocketOffMessageCallback = (
                result: UDPSocketOnMessageListenerResult
            ) => void;
    /**
     * 开始监听数据包消息的事件的监听函数
     */
    type OnListeningCallback = (res: GeneralCallbackResult) => void;
    /**
     * 收到消息的事件的监听函数
     */
    type UDPSocketOnMessageCallback = (
                result: UDPSocketOnMessageListenerResult
            ) => void;

    interface UDPSocketSendOption {
        /**
         * 要发消息的地址。在基础库 <= 2.9.3 版本必须是和本机同网段的 IP 地址，或安全域名列表内的域名地址；之后版本可以是任意 IP 和域名
         */
        address: string;
        /**
         * 要发送的数据
         */
        message: string | ArrayBuffer;
        /**
         * 要发送消息的端口号
         */
        port: number;
        /**
         * 发送数据的长度，仅当 message 为 ArrayBuffer 类型时有效
         */
        length?: number;
        /**
         * 发送数据的偏移量，仅当 message 为 ArrayBuffer 类型时有效
         */
        offset?: number;
        /**
         * 向指定地址发消息时，是否要开启广播，基础库 2.24.0 开始支持
         */
        setBroadcast?: boolean;
    }

    interface UDPSocket {
        /**
         *
         * 在插件中使用：需要基础库 `2.11.1`
         *
         * 关闭 UDP Socket 实例，相当于销毁。 在关闭之后，UDP Socket 实例不能再发送消息，每次调用 `UDPSocket.send` 将会触发错误事件，并且 message 事件回调函数也不会再也执行。在 `UDPSocket` 实例被创建后将被 Native 强引用，保证其不被 GC。在 `UDPSocket.close` 后将解除对其的强引用，让 UDPSocket 实例遵从 GC。
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/network/udp/UDPSocket.close.html](https://developers.weixin.qq.com/miniprogram/dev/api/network/udp/UDPSocket.close.html)
         */
        close(): void;
        /**
         *
         * 需要基础库： `2.15.0`
         *
         * 在插件中使用：需要基础库 `2.11.1`
         *
         * 预先连接到指定的 IP 和 port，需要配合 write 方法一起使用
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/network/udp/UDPSocket.connect.html](https://developers.weixin.qq.com/miniprogram/dev/api/network/udp/UDPSocket.connect.html)
         */
        connect(option: UDPSocketConnectOption): void;
        /**
         *
         * 在插件中使用：需要基础库 `2.11.1`
         *
         * 移除关闭事件的监听函数
         *
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/network/udp/UDPSocket.offClose.html](https://developers.weixin.qq.com/miniprogram/dev/api/network/udp/UDPSocket.offClose.html)
         */
        offClose(listener?: UDPSocketOffCloseCallback): void;
        /**
         *
         * 在插件中使用：需要基础库 `2.11.1`
         *
         * 移除错误事件的监听函数
         *
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/network/udp/UDPSocket.offError.html](https://developers.weixin.qq.com/miniprogram/dev/api/network/udp/UDPSocket.offError.html)
         */
        offError(listener?: UDPSocketOffErrorCallback): void;
        /**
         *
         * 在插件中使用：需要基础库 `2.11.1`
         *
         * 移除开始监听数据包消息的事件的监听函数
         *
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/network/udp/UDPSocket.offListening.html](https://developers.weixin.qq.com/miniprogram/dev/api/network/udp/UDPSocket.offListening.html)
         */
        offListening(listener?: OffListeningCallback): void;
        /**
         *
         * 在插件中使用：需要基础库 `2.11.1`
         *
         * 移除收到消息的事件的监听函数
         *
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/network/udp/UDPSocket.offMessage.html](https://developers.weixin.qq.com/miniprogram/dev/api/network/udp/UDPSocket.offMessage.html)
         */
        offMessage(listener?: UDPSocketOffMessageCallback): void;
        /**
         *
         * 在插件中使用：需要基础库 `2.11.1`
         *
         * 监听关闭事件
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/network/udp/UDPSocket.onClose.html](https://developers.weixin.qq.com/miniprogram/dev/api/network/udp/UDPSocket.onClose.html)
         */
        onClose(listener: UDPSocketOnCloseCallback): void;
        /**
         *
         * 在插件中使用：需要基础库 `2.11.1`
         *
         * 监听错误事件
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/network/udp/UDPSocket.onError.html](https://developers.weixin.qq.com/miniprogram/dev/api/network/udp/UDPSocket.onError.html)
         */
        onError(listener: UDPSocketOnErrorCallback): void;
        /**
         *
         * 在插件中使用：需要基础库 `2.11.1`
         *
         * 监听开始监听数据包消息的事件
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/network/udp/UDPSocket.onListening.html](https://developers.weixin.qq.com/miniprogram/dev/api/network/udp/UDPSocket.onListening.html)
         */
        onListening(listener: OnListeningCallback): void;
        /**
         *
         * 在插件中使用：需要基础库 `2.11.1`
         *
         * 监听收到消息的事件
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/network/udp/UDPSocket.onMessage.html](https://developers.weixin.qq.com/miniprogram/dev/api/network/udp/UDPSocket.onMessage.html)
         */
        onMessage(listener: UDPSocketOnMessageCallback): void;
        /**
         *
         * 在插件中使用：需要基础库 `2.11.1`
         *
         * 向指定的 IP 和 port 发送消息。基础库 2.9.0 起支持广播 (指定地址为 255.255.255.255)。
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/network/udp/UDPSocket.send.html](https://developers.weixin.qq.com/miniprogram/dev/api/network/udp/UDPSocket.send.html)
         */
        send(option: UDPSocketSendOption): void;
        /**
         *
         * 需要基础库： `2.18.0`
         *
         * 在插件中使用：支持
         *
         * 设置 IP_TTL 套接字选项，用于设置一个 IP 数据包传输时允许的最大跳步数
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/network/udp/UDPSocket.setTTL.html](https://developers.weixin.qq.com/miniprogram/dev/api/network/udp/UDPSocket.setTTL.html)
         */
        setTTL(ttl: number): void;
        /**
         *
         * 需要基础库： `2.15.0`
         *
         * 在插件中使用：需要基础库 `2.11.1`
         *
         * 用法与 send 方法相同，如果没有预先调用 connect 则与 send 无差异（注意即使调用了 connect 也需要在本接口填入地址和端口参数）
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/network/udp/UDPSocket.write.html](https://developers.weixin.qq.com/miniprogram/dev/api/network/udp/UDPSocket.write.html)
         */
        write(option: UDPSocketSendOption): void;
        /**
         *
         * 在插件中使用：需要基础库 `2.11.1`
         *
         * 绑定一个系统随机分配的可用端口，或绑定一个指定的端口号
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/network/udp/UDPSocket.bind.html](https://developers.weixin.qq.com/miniprogram/dev/api/network/udp/UDPSocket.bind.html)
         */
        bind(port?: number): number;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type GetLatestUserKeyCompleteCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用失败的回调函数
     */
    type GetLatestUserKeyFailCallback = (res: GeneralCallbackResult) => void;

    interface GetLatestUserKeySuccessCallbackResult {
        /**
         * 用户加密密钥
         */
        encryptKey: string;
        /**
         * 密钥过期时间
         */
        expireTime: number;
        /**
         * 密钥初始向量
         */
        iv: string;
        /**
         * 密钥版本
         */
        version: number;
        errMsg: string;
    }

    /**
     * 接口调用成功的回调函数
     */
    type GetLatestUserKeySuccessCallback = (
                result: GetLatestUserKeySuccessCallbackResult
            ) => void;

    interface GetLatestUserKeyOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: GetLatestUserKeyCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: GetLatestUserKeyFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: GetLatestUserKeySuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type GetRandomValuesCompleteCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用失败的回调函数
     */
    type GetRandomValuesFailCallback = (res: GeneralCallbackResult) => void;

    interface GetRandomValuesSuccessCallbackResult {
        /**
         * 随机数内容，长度为传入的字节数
         */
        randomValues: ArrayBuffer;
        errMsg: string;
    }

    /**
     * 接口调用成功的回调函数
     */
    type GetRandomValuesSuccessCallback = (
                result: GetRandomValuesSuccessCallbackResult
            ) => void;

    interface GetRandomValuesOption {
        /**
         * 整数，生成随机数的字节数，最大 1048576
         */
        length: number;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: GetRandomValuesCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: GetRandomValuesFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: GetRandomValuesSuccessCallback;
    }

    interface UserCryptoManager {
        /**
         *
         * 需要基础库： `2.17.3`
         *
         * 在插件中使用：不支持
         *
         * 获取最新的用户加密密钥
         *
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/crypto/UserCryptoManager.getLatestUserKey.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/crypto/UserCryptoManager.getLatestUserKey.html)
         */
        getLatestUserKey(option?: GetLatestUserKeyOption): void;
        /**
         *
         * 需要基础库： `2.17.3`
         *
         * 在插件中使用：不支持
         *
         * 获取密码学安全随机数
         *
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/crypto/UserCryptoManager.getRandomValues.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/crypto/UserCryptoManager.getRandomValues.html)
         */
        getRandomValues(option: GetRandomValuesOption): void;
    }

    /**
     * 平面跟踪配置
     */
    interface PlaneTrack {
        /**
         * 平面跟踪配置模式
         *
         * 可选值：
         * - 1: 检测横向平面;
         * - 2: 检测纵向平面，只有 v2 版本支持;
         * - 3: 检测横向和纵向平面，只有 v2 版本支持;
         */
        mode: 1 | 2 | 3;
        /**
         * 需要基础库： `3.6.5`
         *
         * 是否开启强制使用V2的模式，只有 v2 版本支持
         */
        force?: boolean;
    }

    /**
     * 需要基础库： `3.3.0`
     *
     * 身份证检测配置。用法详情[指南文档](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/visionkit/idcard.html)。
     */
    interface IDCardTrack {
        /**
         * 需要基础库： `3.3.0`
         *
         * 身份证检测模式
         *
         * 可选值：
         * - 2: 静态图片检测;
         */
        mode: 2;
    }

    /**
     * 需要基础库： `2.27.0`
     *
     * OCR检测配置。用法详情[指南文档](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/visionkit/ocr.html)。
     */
    interface OCRTrack {
        /**
         * 需要基础库： `2.27.0`
         *
         * OCR检测模式
         *
         * 可选值：
         * - 1: 通过摄像头实时检测;
         * - 2: 静态图片检测;
         */
        mode: 1 | 2;
    }

    /**
     * 需要基础库： `2.28.0`
     *
     * 人体检测配置。用法详情[指南文档](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/visionkit/body.html)。
     */
    interface BodyTrack {
        /**
         * 需要基础库： `2.28.0`
         *
         * 人体检测模式
         *
         * 可选值：
         * - 1: 通过摄像头实时检测;
         * - 2: 静态图片检测;
         */
        mode: 1 | 2;
    }

    /**
     * 需要基础库： `3.0.0`
     *
     * 深度识别配置。用法详情[指南文档](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/visionkit/depth.html)。
     */
    interface DepthTrack {
        /**
         * 需要基础库： `3.0.0`
         *
         * 深度识别模式
         *
         * 可选值：
         * - 1: 通过摄像头实时检测;
         * - 2: 静态图片检测;
         */
        mode: 1 | 2;
    }

    /**
     * 需要基础库： `2.25.0`
     *
     * 人脸检测配置。用法详情[指南文档](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/visionkit/face.html)。安卓微信8.0.25开始支持，iOS微信8.0.24开始支持。
     */
    interface FaceTrack {
        /**
         * 需要基础库： `2.25.0`
         *
         * 人脸检测模式
         *
         * 可选值：
         * - 1: 通过摄像头实时检测;
         * - 2: 静态图片检测;
         */
        mode: 1 | 2;
    }

    /**
     * 需要基础库： `2.28.0`
     *
     * 手势检测配置。用法详情[指南文档](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/visionkit/hand.html)。
     */
    interface HandTrack {
        /**
         * 需要基础库： `2.28.0`
         *
         * 手势检测模式
         *
         * 可选值：
         * - 1: 通过摄像头实时检测;
         * - 2: 静态图片检测;
         */
        mode: 1 | 2;
    }

    /**
     * 需要基础库： `3.2.1`
     *
     * 鞋部检测配置。用法详情[指南文档](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/visionkit/shoe.html)。
     */
    interface ShoeTrack {
        /**
         * 需要基础库： `3.2.1`
         *
         * 鞋部检测模式
         *
         * 可选值：
         * - 1: 通过摄像头实时检测;
         */
        mode: 1;
    }

    /**
     * 跟踪能力配置，目前不同的跟踪能力之间是互斥的，默认使用平面跟踪能力。需要注意目前 track 中不同的跟踪配置存在互斥关系（比如 marker 跟踪配置和 OSD 跟踪配置不能同时存在），请按需配置。
     */
    interface Track {
        /**
         * 平面跟踪配置
         */
        plane: PlaneTrack;
        /**
         * 需要基础库： `3.3.0`
         *
         * 身份证检测配置。用法详情[指南文档](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/visionkit/idcard.html)。
         */
        IDCard?: IDCardTrack;
        /**
         * 需要基础库： `2.27.0`
         *
         * OCR检测配置。用法详情[指南文档](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/visionkit/ocr.html)。
         */
        OCR?: OCRTrack;
        /**
         * 需要基础库： `2.24.5`
         *
         * OSD 跟踪配置
         */
        OSD?: boolean;
        /**
         * 需要基础库： `2.28.0`
         *
         * 人体检测配置。用法详情[指南文档](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/visionkit/body.html)。
         */
        body?: BodyTrack;
        /**
         * 需要基础库： `3.0.0`
         *
         * 深度识别配置。用法详情[指南文档](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/visionkit/depth.html)。
         */
        depth?: DepthTrack;
        /**
         * 需要基础库： `2.25.0`
         *
         * 人脸检测配置。用法详情[指南文档](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/visionkit/face.html)。安卓微信8.0.25开始支持，iOS微信8.0.24开始支持。
         */
        face?: FaceTrack;
        /**
         * 需要基础库： `2.28.0`
         *
         * 手势检测配置。用法详情[指南文档](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/visionkit/hand.html)。
         */
        hand?: HandTrack;
        /**
         * 需要基础库： `2.24.5`
         *
         * marker 跟踪配置，基础库(3.0.0)开始允许同时支持v2的水平面检测能力
         */
        marker?: boolean;
        /**
         * 需要基础库： `3.2.1`
         *
         * 鞋部检测配置。用法详情[指南文档](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/visionkit/shoe.html)。
         */
        shoe?: ShoeTrack;
        /**
         * 需要基础库： `2.28.0`
         *
         * 提供基础AR功能，输出相机旋转的3个自由度的位姿，利用手机陀螺仪传感器，实现快速稳定的AR定位能力，适用于简单AR场景。
         */
        threeDof?: boolean;
    }

    interface VKConfig {
        /**
         * 跟踪能力配置，目前不同的跟踪能力之间是互斥的，默认使用平面跟踪能力。需要注意目前 track 中不同的跟踪配置存在互斥关系（比如 marker 跟踪配置和 OSD 跟踪配置不能同时存在），请按需配置。
         */
        track: Track;
        /**
         * 需要基础库： `2.23.0`
         *
         * 绑定的 WebGLRenderingContext 对象
         */
        gl?: any;
        /**
         * 需要基础库： `2.22.0`
         *
         * vision kit 版本。
         *
         * 可选值：
         * - 'v1': v1适用于用户在平面场景下，例如桌面，地面，泛平面场景，放置虚拟物体，不提供真实世界距离。用户放置物体时，手机相机倾斜向下对着目标平面点击即可，具有广泛的机型支持;
         * - 'v2': v2提供真实物理距离的 ar 定位功能，提供平面识别功能，用户在平面范围点击放置虚拟物体的功能，具有[有限的机型支持](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/visionkit/plane.html#%E9%99%84%E5%BD%95)。iOS 设备在基础库 2.22.0 开始支持v2。安卓设备在基础库 2.25.1 开始支持v2，另外，安卓v2不支持竖直平面。**使用v2算法需要初始化，移动手机进行左右平移初始化效果最佳。**;
         */
        version?: "v1" | "v2";
    }

    interface VKSize {
        /**
         * 高度
         */
        height: number;
        /**
         * 宽度
         */
        width: number;
    }

    interface VKMarker {
        /**
         * marker id
         */
        markerId: number;
        /**
         * 图片路径
         */
        path: string;
    }

    /**
     * 检测结果
     */
    interface HitTestRes {
        /**
         * 包含位置、旋转、放缩信息的矩阵，以列为主序
         */
        transform: Float32Array;
    }

    interface DetectBodyOption {
        /**
         * 人脸图像像素点数据，每四项表示一个像素点的 RGBA
         */
        frameBuffer: ArrayBuffer;
        /**
         * 图像高度
         */
        height: number;
        /**
         * 图像宽度
         */
        width: number;
        /**
         * 评分阈值。正常情况传入 0.8 即可。
         */
        scoreThreshold?: number;
        /**
         * 图像源类型。正常情况传入 1 即可。当输入的图片是来自一个连续视频的每一帧图像时，sourceType 传入 0 会得到更优的效果
         *
         * 可选值：
         * - 1: 表示输入的图片是随机的图片;
         * - 0: 表示输入的图片是来自一个连续视频的每一帧图像;
         */
        sourceType?: 0 | 1;
    }

    interface DetectDepthOption {
        /**
         * 需要识别深度的图像像素点数据，每四项表示一个像素点的 RGBA
         */
        frameBuffer: ArrayBuffer;
        /**
         * 图像高度
         */
        height: number;
        /**
         * 图像宽度
         */
        width: number;
    }

    interface DetectFaceOption {
        /**
         * 人脸图像像素点数据，每四项表示一个像素点的 RGBA
         */
        frameBuffer: ArrayBuffer;
        /**
         * 图像高度
         */
        height: number;
        /**
         * 图像宽度
         */
        width: number;
        /**
         * 算法模型类型。正常情况传入 1 即可。0、1、2 分别表示小、中、大模型，模型越大识别准确率越高，但资源占用也越高。建议根据用户设备性能进行选择。
         *
         * 可选值：
         * - 0: 小模型;
         * - 1: 中模型;
         * - 2: 大模型;
         */
        modelModel?: 0 | 1 | 2;
        /**
         * 评分阈值。正常情况传入 0.8 即可。
         */
        scoreThreshold?: number;
        /**
         * 图像源类型。正常情况传入 1 即可。当输入的图片是来自一个连续视频的每一帧图像时，sourceType 传入 0 会得到更优的效果
         *
         * 可选值：
         * - 1: 表示输入的图片是随机的图片;
         * - 0: 表示输入的图片是来自一个连续视频的每一帧图像;
         */
        sourceType?: 0 | 1;
    }

    interface DetectHandOption {
        /**
         * 人脸图像像素点数据，每四项表示一个像素点的 RGBA
         */
        frameBuffer: ArrayBuffer;
        /**
         * 图像高度
         */
        height: number;
        /**
         * 图像宽度
         */
        width: number;
        /**
         * 算法检测模式
         *
         * 可选值：
         * - 0: 检测模式，输出框和点;
         * - 1: 手势模式，输出框和手势分类;
         * - 2: 结合0和1模式，输出框、点、手势分类;
         */
        algoMode?: 0 | 1 | 2;
        /**
         * 评分阈值。正常情况传入 0.8 即可。
         */
        scoreThreshold?: number;
    }

    interface RunOCROption {
        /**
         * 待识别图像的像素点数据，每四项表示一个像素点的 RGBA
         */
        frameBuffer: ArrayBuffer;
        /**
         * 图像高度
         */
        height: number;
        /**
         * 图像宽度
         */
        width: number;
    }

    /**
     * 开启会话回调
     */
    type VKSessionStartCallback = (
        /**
         * 参数 status 可选值：
         * - 0: 成功;
         * - 104: 用户取消授权;
         * - 112: 接口未在隐私协议中声明;
         * - 1025: 小程序隐私接口被封禁，[解决方案参考链接](https://developers.weixin.qq.com/community/develop/doc/00062a6d514c88baacdf52e8a56009);
         * - 1026: 小游戏隐私接口被封禁，[解决方案参考链接](https://developers.weixin.qq.com/community/minigame/doc/0004c84925817819b7ffd8b2356008);
         * - 2000001: 参数错误;
         * - 2003000: 会话不可用;
         * - 2000000: 系统错误;
         * - 2000002: 设备不支持;
         * - 2000003: 系统不支持;
         * - 2000004: 设备不支持;
         * - 2003001: 未开启系统相机权限;
         * - 2003002: 未开启小程序相机权限;
         */
        status:
            | 0
            | 104
            | 112
            | 1025
            | 1026
            | 2000001
            | 2003000
            | 2000000
            | 2000002
            | 2000003
            | 2000004
            | 2003001
            | 2003002
    ) => void;

    interface Update3DModeOption {
        /**
         * 是否开启三维识别
         */
        open3d: boolean;
    }

    interface UpdateMaskModeOption {
        /**
         * 设置是否开启试鞋，返回腿部遮挡纹理
         */
        useMask: boolean;
    }

    /**
     * 需要基础库： `2.20.0`
     *
     * 相机对象
     */
    interface VKCamera {
        /**
         * 需要基础库： `2.22.0`
         *
         * 相机内参，只有 v2 版本支持
         */
        intrinsics: Float32Array;
        /**
         * 相机原始的Pose矩阵
         */
        transform: Float32Array;
        /**
         * 视图矩阵
         */
        viewMatrix: Float32Array;
        /**
         *
         * 需要基础库： `2.20.0`
         *
         * 在插件中使用：需要基础库 `2.20.0`
         *
         * 获取投影矩阵
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/VKCamera.getProjectionMatrix.html](https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/VKCamera.getProjectionMatrix.html)
         */
        getProjectionMatrix(near: number, far: number): Float32Array;
    }

    /**
     * 帧纹理对象
     */
    interface YUVTextureRes {
        /**
         * UV 分量纹理
         */
        uvTexture: any;
        /**
         * Y 分量纹理
         */
        yTexture: any;
    }

    /**
     * 帧深度纹理buffer对象
     */
    interface DepthBufferRes {
        /**
         * 深度纹理buffer
         */
        DepthAddress: ArrayBuffer;
        /**
         * 深度纹理高
         */
        height: number;
        /**
         * 深度纹理宽
         */
        width: number;
    }

    /**
     * 帧深度纹理buffer对象，width * height 大小的 深度值（float32）
     */
    interface LegSegmentBufferRes {
        /**
         * 腿部分割纹理buffer，width * height 大小的 裁剪值（0 为不是脚，越靠近 255 越接近腿部区域）（uint8）
         */
        DepthAddress: ArrayBuffer;
        /**
         * 腿部分割纹理高
         */
        height: number;
        /**
         * 腿部分割纹理宽
         */
        width: number;
    }

    /**
     * 需要基础库： `2.20.0`
     *
     * vision kit 会话对象。
     */
    interface VKFrame {
        /**
         *
         * 相机对象
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/VKCamera.html](https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/VKCamera.html)
         */
        camera: VKCamera;
        /**
         * 生成时间，单位:纳秒(ns)
         */
        timestamp: number;
        /**
         *
         * 需要基础库： `2.24.0`
         *
         * 在插件中使用：不支持
         *
         * 获取当前帧 rgba buffer。iOS 端微信在 v8.0.20 开始支持，安卓端微信在 v8.0.30 开始支持。按 aspect-fill 规则裁剪，此接口要求在创建 VKSession 对象时必须传入 gl 参数。此接口仅建议拿来做帧分析使用，上屏请使用 getCameraTexture 来代替。
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/VKFrame.getCameraBuffer.html](https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/VKFrame.getCameraBuffer.html)
         */
        getCameraBuffer(width: number, height: number): ArrayBuffer;
        /**
         *
         * 需要基础库： `3.0.0`
         *
         * 在插件中使用：不支持
         *
         * 获取当前帧的 jpg 信息Buffer。安卓微信 8.0.49 开始支持，iOS微信 8.0.49 开始支持。
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/VKFrame.getCameraJpgBuffer.html](https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/VKFrame.getCameraJpgBuffer.html)
         */
        getCameraJpgBuffer(width: number, height: number, quality: number): ArrayBuffer;
        /**
         *
         * 需要基础库： `2.20.0`
         *
         * 在插件中使用：需要基础库 `2.20.0`
         *
         * 获取纹理调整矩阵。默认获取到的纹理是未经裁剪调整的纹理，此矩阵可用于在着色器中根据帧对象尺寸对纹理进行裁剪。
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/VKFrame.getDisplayTransform.html](https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/VKFrame.getDisplayTransform.html)
         */
        getDisplayTransform(): Float32Array;
        /**
         *
         * 需要基础库： `2.20.0`
         *
         * 在插件中使用：需要基础库 `2.20.0`
         *
         * 获取当前帧纹理，目前只支持 YUV 纹理。
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/VKFrame.getCameraTexture.html](https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/VKFrame.getCameraTexture.html)
         */
        getCameraTexture(gl: any): YUVTextureRes;
        /**
         *
         * 需要基础库： `3.0.0`
         *
         * 在插件中使用：不支持
         *
         * 获取每帧的深度图信息Buffer。安卓微信 8.0.38 开始支持，iOS微信 8.0.39 开始支持。
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/VKFrame.getDepthBuffer.html](https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/VKFrame.getDepthBuffer.html)
         */
        getDepthBuffer(): DepthBufferRes;
        /**
         *
         * 需要基础库： `3.2.1`
         *
         * 在插件中使用：不支持
         *
         * 获取每帧的腿部分割信息Buffer，安卓微信 8.0.43，iOS微信 8.0.43 开始支持。
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/VKFrame.getLegSegmentBuffer.html](https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/VKFrame.getLegSegmentBuffer.html)
         */
        getLegSegmentBuffer(): LegSegmentBufferRes;
    }

    /**
     * 需要基础库： `2.20.0`
     *
     * vision kit 会话对象。
     */
    interface VKSession {
        /**
         * 相机尺寸
         */
        cameraSize: VKSize;
        /**
         * 会话配置
         */
        config: VKConfig;
        /**
         * 会话状态
         *
         * 可选值：
         * - 0: 不可用;
         * - 1: 运行中;
         * - 2: 暂停中;
         * - 3: 初始化中;
         */
        state: 0 | 1 | 2 | 3;
        /**
         *
         * 需要基础库： `2.24.5`
         *
         * 在插件中使用：需要基础库 `2.24.5`
         *
         * 获取所有 marker，要求调 [uni.createVKSession](https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/wx.createVKSession.html) 时传入的 track.marker 为 true
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/VKSession.getAllMarker.html](https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/VKSession.getAllMarker.html)
         */
        getAllMarker(): VKMarker[];
        /**
         *
         * 需要基础库： `2.24.5`
         *
         * 在插件中使用：需要基础库 `2.24.5`
         *
         * 获取所有 OSD marker，要求调 [uni.createVKSession](https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/wx.createVKSession.html) 时传入的 track.OSD 为 true
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/VKSession.getAllOSDMarker.html](https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/VKSession.getAllOSDMarker.html)
         */
        getAllOSDMarker(): VKMarker[];
        /**
         *
         * 需要基础库： `2.20.0`
         *
         * 在插件中使用：需要基础库 `2.20.0`
         *
         * 触摸检测，v1 版本只支持单平面（即 hitTest 生成一次平面后，后续 hitTest 均不会再生成平面，而是以之前生成的平面为基础进行检测）。如果需要重新识别其他平面，可以在调用此方法时将 reset 参数置为 true。
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/VKSession.hitTest.html](https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/VKSession.hitTest.html)
         */
        hitTest(x: number, y: number, reset: any): HitTestRes[];
        /**
         *
         * 需要基础库： `2.20.0`
         *
         * 在插件中使用：需要基础库 `2.20.0`
         *
         * 取消由 requestAnimationFrame 添加到计划中的动画帧请求。
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/VKSession.cancelAnimationFrame.html](https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/VKSession.cancelAnimationFrame.html)
         */
        cancelAnimationFrame(requestID: number): void;
        /**
         *
         * 需要基础库： `2.20.0`
         *
         * 在插件中使用：需要基础库 `2.20.0`
         *
         * 销毁会话。
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/VKSession.destroy.html](https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/VKSession.destroy.html)
         */
        destroy(): void;
        /**
         *
         * 需要基础库： `2.28.0`
         *
         * 在插件中使用：需要基础库 `2.28.0`
         *
         * 静态图像人体关键点检测。当 wx.createVKSession 参数传入 {track: {body: {mode: 2} } } 时可用。用法详情[指南文档](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/visionkit/body.html)。
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/VKSession.detectBody.html](https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/VKSession.detectBody.html)
         */
        detectBody(option: DetectBodyOption): void;
        /**
         *
         * 需要基础库： `2.33.0`
         *
         * 在插件中使用：需要基础库 `2.33.0`
         *
         * 深度识别。当 wx.createVKSession 参数传入 {track: {depth: {mode: 2} } } 时可用。用法详情[指南文档](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/visionkit/depth.html)。
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/VKSession.detectDepth.html](https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/VKSession.detectDepth.html)
         */
        detectDepth(option: DetectDepthOption): void;
        /**
         *
         * 需要基础库： `2.25.0`
         *
         * 在插件中使用：需要基础库 `2.25.0`
         *
         * 静态图像人脸关键点检测。当 wx.createVKSession 参数传入 {track: {face: {mode: 2} } } 时可用。用法详情[指南文档](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/visionkit/face.html)。安卓微信8.0.25开始支持，iOS微信8.0.24开始支持。
         *
         * ****
         *
         * ### 特别说明
         * 若小程序人脸识别功能涉及采集、存储用户生物特征（如人脸照片或视频、身份证和手持身份证、身份证照和免冠照等），此类型服务需使用[微信原生人脸识别接口](https://developers.weixin.qq.com/community/develop/doc/000442d352c1202bd498ecb105c00d?highline=%E4%BA%BA%E8%84%B8%E6%A0%B8%E8%BA%AB)。
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/VKSession.detectFace.html](https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/VKSession.detectFace.html)
         */
        detectFace(option: DetectFaceOption): void;
        /**
         *
         * 需要基础库： `2.28.0`
         *
         * 在插件中使用：需要基础库 `2.28.0`
         *
         * 静态图像手势关键点检测。当 wx.createVKSession 参数传入 {track: {hand: {mode: 2} } } 时可用。用法详情[指南文档](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/visionkit/hand.html)。
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/VKSession.detectHand.html](https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/VKSession.detectHand.html)
         */
        detectHand(option: DetectHandOption): void;
        /**
         *
         * 需要基础库： `2.20.0`
         *
         * 在插件中使用：需要基础库 `2.20.0`
         *
         * 取消监听会话事件。
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/VKSession.off.html](https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/VKSession.off.html)
         */
        off(eventName: string, fn: (...args: any[]) => any): void;
        /**
         *
         * 需要基础库： `2.20.0`
         *
         * 在插件中使用：需要基础库 `2.20.0`
         *
         * 监听会话事件。
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/VKSession.on.html](https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/VKSession.on.html)
         */
        on(eventName: "resize" | "addAnchors" | "updateAnchors" | "removeAnchors", fn: (...args: any[]) => any): void;
        /**
         *
         * 需要基础库： `2.24.5`
         *
         * 在插件中使用：需要基础库 `2.24.5`
         *
         * 删除一个 marker，要求调 [uni.createVKSession](https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/wx.createVKSession.html) 时传入的 track.marker 为 true
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/VKSession.removeMarker.html](https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/VKSession.removeMarker.html)
         */
        removeMarker(markerId: number): void;
        /**
         *
         * 需要基础库： `2.24.5`
         *
         * 在插件中使用：需要基础库 `2.24.5`
         *
         * 删除一个 OSD marker，要求调 [uni.createVKSession](https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/wx.createVKSession.html) 时传入的 track.OSD 为 true
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/VKSession.removeOSDMarker.html](https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/VKSession.removeOSDMarker.html)
         */
        removeOSDMarker(markerId: number): void;
        /**
         *
         * 需要基础库： `2.27.0`
         *
         * 在插件中使用：需要基础库 `2.27.0`
         *
         * 静态图像OCR检测。当 wx.createVKSession 参数传入 {track: {OCR: {mode: 2} } } 时可用。用法详情[指南文档](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/visionkit/ocr.html)。
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/VKSession.runOCR.html](https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/VKSession.runOCR.html)
         */
        runOCR(option: RunOCROption): void;
        /**
         *
         * 需要基础库： `3.0.0`
         *
         * 在插件中使用：需要基础库 `3.0.0`
         *
         * 更新 深度遮挡 Occ范围，要求调 [uni.createVKSession](https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/wx.createVKSession.html) 时传入 {track: {depth: {mode: 2} } }
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/VKSession.setDepthOccRange.html](https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/VKSession.setDepthOccRange.html)
         */
        setDepthOccRange(threshold: number): void;
        /**
         *
         * 需要基础库： `2.20.0`
         *
         * 在插件中使用：需要基础库 `2.20.0`
         *
         * 开启会话。
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/VKSession.start.html](https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/VKSession.start.html)
         */
        start(callback: VKSessionStartCallback): void;
        /**
         *
         * 需要基础库： `2.20.0`
         *
         * 在插件中使用：需要基础库 `2.20.0`
         *
         * 停止会话。
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/VKSession.stop.html](https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/VKSession.stop.html)
         */
        stop(): void;
        /**
         *
         * 需要基础库： `2.30.2`
         *
         * 在插件中使用：需要基础库 `2.30.2`
         *
         * 更新三维识别相关配置，要求调 [uni.createVKSession](https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/wx.createVKSession.html) 时使用 face / hand / body。
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/VKSession.update3DMode.html](https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/VKSession.update3DMode.html)
         */
        update3DMode(option: Update3DModeOption): void;
        /**
         *
         * 需要基础库： `3.2.1`
         *
         * 在插件中使用：需要基础库 `3.2.1`
         *
         * 设置裁剪相关配置，要求调 [uni.createVKSession](https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/wx.createVKSession.html) 时使用 shoe。
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/VKSession.updateMaskMode.html](https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/VKSession.updateMaskMode.html)
         */
        updateMaskMode(option: UpdateMaskModeOption): void;
        /**
         *
         * 需要基础库： `2.24.5`
         *
         * 在插件中使用：需要基础库 `2.24.5`
         *
         * 更新 OSD 识别精确度，要求调 [uni.createVKSession](https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/wx.createVKSession.html) 时传入的 track.OSD 为 true
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/VKSession.updateOSDThreshold.html](https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/VKSession.updateOSDThreshold.html)
         */
        updateOSDThreshold(threshold: number): void;
        /**
         *
         * 需要基础库： `2.20.0`
         *
         * 在插件中使用：需要基础库 `2.20.0`
         *
         * 获取帧对象，每调用一次都会触发一次帧分析过程。目前 VKSession 相机的最大帧数是 30 fps，因此调用 getVKFrame 的频率也可以限制在 30 fps，以减少渲染开销。
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/VKSession.getVKFrame.html](https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/VKSession.getVKFrame.html)
         */
        getVKFrame(width: number, height: number): VKFrame;
        /**
         *
         * 需要基础库： `2.24.5`
         *
         * 在插件中使用：需要基础库 `2.24.5`
         *
         * 添加一个 marker，要求调 [uni.createVKSession](https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/wx.createVKSession.html) 时传入的 track.marker 为 true
         *
         * **使用提示**
         *
         * 注意事项：
         * 1. 使用 addMarker 接口之前，需要在 createVKSession 的时候声明开启 marker 跟踪。即 wx.createVKSession({ track: { marker: true } })
         * 2. 可以添加多个 marker 图片，但不能重复添加相同的 marker 图片。
         * 3. 在v2模式下同时支持水平面检测与marker检测，同时可输出多个2d/3d marker位姿（需要基础库版本不低于 [2.33.0](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html)
         *
         * ### 2Dmarker
         * 对传入的图片有如下要求：
         * 1. 格式：jpg/png 格式三通道彩图或者 1 通道灰度图
         * 2. 分辨率：尺寸在 480x480 ~ 1920x1920 之间，建议为 1080 分辨率
         * 3. 宽高比：在 1:1 ~ 16:9 之间，要求尽量方正，避免狭长的图片
         * 4. 质量：目标图像为平面模型，需要占画面主体，避免大面积留白，建议用扫描件
         *
         * 示例：
         *
         * <img width="500px" src="https://res.wx.qq.com/op_res/sJPS5gttY4yQq-CmG9crrtaOpjb6Yc6mDhJKdUmrIpmtbWBMfAUAFavtKT6-tEZIh-8zT8tfBJBtvH048ge5Vw" alt="image.png" />
         *
         * 建议：
         *
         * 1. 图片具有丰富的细节
         * 2. 避免重复单一的纹理，例如：
         *
         * <img width="500px" src="https://res.wx.qq.com/op_res/VfNcS-M6nPWWXq_CJ483Dq3iLsNXMvLiM6Wb5ZHOrVVGR2u5ixbQlbiSSuNHzVcMQQY5V0dvnlyOGihUIbyTvA" alt="image.png" />
         * <br>
         * <img width="500px" src="https://res.wx.qq.com/op_res/VfNcS-M6nPWWXq_CJ483Dq-_lR2j4eOi23IOJ2LHFQY_PWufbx3s3uROgLi_flJMHQA8DNvlebs9UwumozPlXg" alt="image.png" />
         * <br>
         * <img width="500px" src="https://res.wx.qq.com/op_res/VfNcS-M6nPWWXq_CJ483Dr9IaSPF18UPnz4KrbAhGW9pIb8oWxzHgmClGIRZK59N4gUnJh69yoQW1TFGqce8ew" alt="image.png" />
         * <br>
         *
         * 3. 避免使用柔和平滑边缘的纹理及大量渐变图像，例如：
         *
         * <img width="500px" src="https://res.wx.qq.com/op_res/rg0BkiSl-LPBybgJtcQCq6DPj88qSVwHFZiumbE0IMq9ibzbnhjewzUSa-n5_VgF_lF9g07FFHHYyrY14KTSfA" alt="image.png" />
         *
         * 4. 避免模糊，建议采用高清、高对比度图像作为识别对象
         * 5. 建议图像有均匀的特征（角点）分布，正确示例：
         *
         * <img width="500px" src="https://res.wx.qq.com/op_res/sJPS5gttY4yQq-CmG9crrrBRWB_Cw2aFXAn1KY0YtfjnQ7WNt854gA8H2zfmZUztlFcJbdEHouBGs63hUO4Mxg" alt="image.png" />
         *
         * 避免角点较少、中间大量空白、没有特征及角点的图像，错误示例：
         *
         * <img width="500px" src="https://res.wx.qq.com/op_res/rg0BkiSl-LPBybgJtcQCqzjY2LY-ylRjFS7TVD-cZsEE8TTB-xzR2YiWKhWyWg1bgpbRqQq-4l6OWPDii4S3Xg" alt="image.png" />
         *
         * ### 3Dmarker
         * 现小程序demo支持通过上传视频, 生成对应模型的3dmarker识别文件,后缀名为.map
         *
         * 对传入的视频有如下要求：
         * 1.视频长宽比为16:9或4:3; 短边大于480px
         * 2.目标物体易于和背景物体区分出来，同时目标物体放置与背景物体一定距离，放置底面与物体易于区分，底面可以放置一张白纸，例如：
         *
         * <img width="500px" src="https://res.wx.qq.com/op_res/a0ooLtlHHfpfb37tq3AxZWPrfqINIs2MvJnZxQeTLzkpbgAGn6m8CaWAoy_osmlVDVhWm16e-yBDXjIY0dhCEQ" alt="image.png" />
         *
         * 3.目标物体最好为刚体，本身不会发生较大形变， 容易变形的物体不适合用作识别对象
         * 4.视频匀速移动，避免模糊，对目标识别面环绕物体拍摄，需要保证相机有足够的平移移动
         * 5.marker物体要求与2d图像要求类似，具有丰富细节，避免重复单一纹理，不反光，无高光
         * 6.拍摄视频中特征纹理丰富，如果marker本身问题较弱，可以在背景中适当添加纹理物体
         * 服务耗时：当前版本30s视频耗时约20分钟，请静待算法返回模型
         *
         * 建议：
         *
         * 1.视频格式：视频帧率30fps，分辨率建议1080p
         * 2.视频时长：视频建议时长在20s~30s，超过30s会被截断，时长过短会导致marker效果欠佳
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/VKSession.addMarker.html](https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/VKSession.addMarker.html)
         */
        addMarker(path: string): number;
        /**
         *
         * 需要基础库： `2.24.5`
         *
         * 在插件中使用：需要基础库 `2.24.5`
         *
         * 添加一个 OSD marker（one-shot detection marker），要求调 [uni.createVKSession](https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/wx.createVKSession.html) 时传入的 track.OSD 为 true
         *
         * **使用提示**
         *
         * 注意事项：
         * 1. 使用 addOSDMarker 接口之前，需要在 createVKSession 的时候声明开启 OSD 跟踪。即 wx.createVKSession({ track: { OSD: true } })
         * 2. 可以添加多个 OSDMarker 图片，但不能重复添加相同的 OSDMarker 图片。
         *
         * 对传入的图片有如下要求：
         * 1. 格式：jpg 格式彩色图片
         * 2. 分辨率：尺寸不低于 240x240
         * 3. 宽高比：在 1:1 ~ 16:9 之间，要求尽量方正，避免狭长的图片
         * 4. 质量：目标物体需要占画面主体，避免大面积留白，避免大面积文字，不能含其他物体。
         *
         * 示例：
         *
         * <img width="500px" src="https://res.wx.qq.com/op_res/rg0BkiSl-LPBybgJtcQCq_Mq0ReXEA5nOzDIvnYYPttmwxn0V1e_yI6UUgkNT6K6aOQj2QRba5IHQglHULkrKg" alt="image.png" />
         * <br>
         * <img width="500px" src="https://res.wx.qq.com/op_res/rg0BkiSl-LPBybgJtcQCqwiRcyGk9oenkCpd3vAHWSTSZPPJcgIrPzcpwnSpmk_9bMiCqUdS8Ds789Rjhy0CtA" alt="image.png" />
         * <br>
         * <img width="500px" src="https://res.wx.qq.com/op_res/rg0BkiSl-LPBybgJtcQCqx8fYUYypBmFmB1_zX-APH06j1oMZDz7K0CE2To_982NDOB5fmM4Y2Rrr1uQF6J4gg" alt="image.png" />
         * <br>
         *
         * 建议：
         *
         * 1. 具有丰富的细节，避免纯色且形状特点不鲜明的物体，例如：
         *
         * <img width="500px" src="https://res.wx.qq.com/op_res/rg0BkiSl-LPBybgJtcQCq-6WwSZKlNbN-if0NCag-Dm6AmNJeBFi5dvR-bRZINlZmuA9G1e4wpngvhlr2z6CXQ" alt="image.png" />
         *
         * 2. 避免模糊，最好采用高清图片
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/VKSession.addOSDMarker.html](https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/VKSession.addOSDMarker.html)
         */
        addOSDMarker(path: string): number;
        /**
         *
         * 需要基础库： `2.20.0`
         *
         * 在插件中使用：需要基础库 `2.20.0`
         *
         * 在下次进行重绘时执行。
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/VKSession.requestAnimationFrame.html](https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/VKSession.requestAnimationFrame.html)
         */
        requestAnimationFrame(callback: (...args: any[]) => any): number;
    }

    /**
     * 一类音频处理模块，不同的Node具备不同的功能，如GainNode(音量调整)等。一个WebAudioContextNode可以通过上下文来创建。
     * 目前已经支持以下Node：
     * IIRFilterNode
     * WaveShaperNode
     * ConstantSourceNode
     * ChannelMergerNode
     * OscillatorNode
     * GainNode
     * BiquadFilterNode
     * PeriodicWaveNode
     * BufferSourceNode
     * ChannelSplitterNode
     * ChannelMergerNode
     * DelayNode
     * DynamicsCompressorNode
     * ScriptProcessorNode
     * PannerNode
     * AnalyserNode
     */
    interface WebAudioContextNode {
    }

    /**
     * 空间音频监听器，代表在一个音频场景内唯一的位置和方向信息。
     */
    interface AudioListener {
        /**
         * 表示监听器的前向系统在同一笛卡尔坐标系中的水平位置，作为位置（位置x，位置和位置和位置）值。
         */
        forwardX: number;
        /**
         * 表示听众的前向方向在同一笛卡尔坐标系中作为位置（位置x，位置和位置和位置）值的垂直位置。
         */
        forwardY: number;
        /**
         * 表示与position (positionX、positionY和positionZ)值在同一笛卡尔坐标系下的听者前进方向的纵向(前后)位置。
         */
        forwardZ: number;
        /**
         * 右手笛卡尔坐标系中X轴的位置。
         */
        positionX: number;
        /**
         * 右手笛卡尔坐标系中Y轴的位置。
         */
        positionY: number;
        /**
         * 右手笛卡尔坐标系中Z轴的位置。
         */
        positionZ: number;
        /**
         * 设置监听器的方向
         */
        setOrientation: (...args: any[]) => any;
        /**
         * 设置监听器的位置
         */
        setPosition: (...args: any[]) => any;
        /**
         * 表示在与position (positionX、positionY和positionZ)值相同的笛卡尔坐标系中侦听器向前方向的水平位置。
         */
        upX: number;
        /**
         * 表示在与position (positionX、positionY和positionZ)值相同的笛卡尔坐标系中侦听器向上方向的水平位置。
         */
        upY: number;
        /**
         * 表示在与position (positionX、positionY和positionZ)值相同的笛卡尔坐标系中侦听器向后方向的水平位置。
         */
        upZ: number;
    }

    /**
     * 一个字典对象，用于指定是否禁用规范化(默认启用规范化)
     */
    interface Constraints {
        /**
         * 如果指定为true则禁用标准化，默认为false
         */
        disableNormalization?: boolean;
    }

    /**
     * 需要基础库： `2.19.0`
     *
     * AudioBuffer接口表示存在内存里的一段短小的音频资源，利用[WebAudioContext.decodeAudioData](https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/WebAudioContext.decodeAudioData.html)方法从一个音频文件构建，或者利用 [WebAudioContext.createBuffer](https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/WebAudioContext.createBuffer.html)从原始数据构建。把音频放入AudioBuffer后，可以传入到一个 AudioBufferSourceNode进行播放。
     */
    interface AudioBuffer {
        /**
         * 返回存储在缓存区的PCM数据的时长（单位为秒）
         */
        duration: number;
        /**
         * 返回存储在缓存区的PCM数据的采样帧率
         */
        length: number;
        /**
         * 储存在缓存区的PCM数据的通道数
         */
        numberOfChannels: number;
        /**
         * 存储在缓存区的PCM数据的采样率（单位为sample/s)
         */
        sampleRate: number;
        /**
         *
         * 在插件中使用：不支持
         *
         * 从AudioBuffer的指定频道复制到数组终端。
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/AudioBuffer.copyFromChannel.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/AudioBuffer.copyFromChannel.html)
         */
        copyFromChannel(): void;
        /**
         *
         * 在插件中使用：不支持
         *
         * 从指定数组复制样本到audioBuffer的特定通道
         *
         * **示例代码**
         *
         * 示例代码参考AudioBuffer.copyFromChannel
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/AudioBuffer.copyToChannel.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/AudioBuffer.copyToChannel.html)
         */
        copyToChannel(source: Float32Array, channelNumber: number, startInChannel: number): void;
        /**
         *
         * 在插件中使用：不支持
         *
         * 返回一个 Float32Array，包含了带有频道的PCM数据，由频道参数定义（有0代表第一个频道）
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/AudioBuffer.getChannelData.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/AudioBuffer.getChannelData.html)
         */
        getChannelData(channel: number): Float32Array;
    }

    /**
     * 需要基础库： `2.19.0`
     *
     * AudioParam 接口代表音频相关的参数，通常是 AudioNode（例如 GainNode.gain）的参数
     */
    interface AudioParam {
        /**
         * 代表被具体的 AudioNode 创建的 AudioParam 的属性的初始值（只读）
         */
        defaultValue: number;
        /**
         * 代表参数有效范围的最大可能值（只读）
         */
        maxValue: number;
        /**
         * 代表参数有效范围的最小可能值（只读）
         */
        minValue: number;
        /**
         * 当前属性的值（比如音量值或播放倍速值）（可读可写）
         */
        value: number;
    }

    /**
     * 音频源节点，通过 [WebAudioContext.createBufferSource](https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/WebAudioContext.createBufferSource.html)方法获得。
     *
     */
    interface BufferSourceNode {
        /**
         *
         * 是一个 AudioBuffer， 它定义了要播放的音频，当设置它的值为 0 时，它会定义一个静默的单通道。（可读可写）
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/AudioBuffer.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/AudioBuffer.html)
         */
        buffer: AudioBuffer;
        /**
         * 定义音频是否循环播放（可读可写）
         */
        loop?: boolean;
        /**
         * 定义音频循环播放时，结束播放的位置。单位是秒，默认值是0（可读可写）
         */
        loopEnd?: number;
        /**
         * 定义音频循环播放时，开始播放的位置。单位是秒，默认值是0（可读可写）
         */
        loopStart?: number;
        /**
         * 定义音频播放结束事件回调函数（可读可写）
         */
        onended?: (...args: any[]) => any;
        /**
         *
         * 定义音频的播放倍速，数值越大速度越快，默认速度1.0，有效范围为 0 < playbackRate <= 2.0（可读可写）
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/AudioParam.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/AudioParam.html)
         */
        playbackRate?: AudioParam;
        /**
         *
         * 在插件中使用：不支持
         *
         * 连接到一个指定目标。这个指定的目标可能是另一个 AudioNode（从而将音频数据引导到下一个指定节点）或一个AudioParam, 以便上一个节点的输出数据随着时间流逝能自动地对下一个参数值进行改变
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/BufferSourceNode.connect.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/BufferSourceNode.connect.html)
         */
        connect(destination: any): void;
        /**
         *
         * 在插件中使用：不支持
         *
         * 与已连接的目标节点断开连接
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/BufferSourceNode.disconnect.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/BufferSourceNode.disconnect.html)
         */
        disconnect(): void;
        /**
         *
         * 在插件中使用：不支持
         *
         * 音频源开始播放
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/BufferSourceNode.start.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/BufferSourceNode.start.html)
         */
        start(when?: number, offset?: number, duration?: number): void;
        /**
         *
         * 在插件中使用：不支持
         *
         * 停止播放
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/BufferSourceNode.stop.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/BufferSourceNode.stop.html)
         */
        stop(when?: number): void;
    }

    /**
     * 需要基础库： `2.19.0`
     *
     * WebAudioContext 实例，通过[uni.createWebAudioContext](https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/wx.createWebAudioContext.html) 接口获取该实例。
     *
     */
    interface WebAudioContext {
        /**
         * 获取当前上下文的时间戳。
         */
        currentTime: number;
        /**
         *
         * 当前上下文的最终目标节点，一般是音频渲染设备。
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/WebAudioContextNode.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/WebAudioContextNode.html)
         */
        destination: WebAudioContextNode;
        /**
         *
         * 空间音频监听器。
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/AudioListener.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/AudioListener.html)
         */
        listener: AudioListener;
        /**
         * 可写属性，开发者可以对该属性设置一个监听函数，当WebAudio状态改变的时候，会触发开发者设置的监听函数。
         */
        onstatechange: (...args: any[]) => any;
        /**
         * 采样率，通常在8000-96000之间，通常44100hz的采样率最为常见。
         */
        sampleRate: number;
        /**
         * 当前WebAudio上下文的状态。可能的值如下：suspended（暂停）、running（正在运行）、closed（已关闭）。需要注意的是，不要在 audioContext close后再访问state属性
         */
        state: string;
        /**
         *
         * 需要基础库： `2.22.0`
         *
         * 在插件中使用：不支持
         *
         * 创建一个 AnalyserNode 。可以用来获取音频时间和频率数据，以及实现数据可视化。
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/WebAudioContext.createAnalyser.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/WebAudioContext.createAnalyser.html)
         */
        createAnalyser(): any;
        /**
         *
         * 在插件中使用：不支持
         *
         * 创建一个BiquadFilterNode
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/WebAudioContext.createBiquadFilter.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/WebAudioContext.createBiquadFilter.html)
         */
        createBiquadFilter(): any;
        /**
         *
         * 在插件中使用：不支持
         *
         * 创建一个ChannelMergerNode
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/WebAudioContext.createChannelMerger.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/WebAudioContext.createChannelMerger.html)
         */
        createChannelMerger(numberOfInputs: number): any;
        /**
         *
         * 在插件中使用：不支持
         *
         * 创建一个ChannelSplitterNode
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/WebAudioContext.createChannelSplitter.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/WebAudioContext.createChannelSplitter.html)
         */
        createChannelSplitter(numberOfOutputs: number): any;
        /**
         *
         * 在插件中使用：不支持
         *
         * 创建一个ConstantSourceNode
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/WebAudioContext.createConstantSource.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/WebAudioContext.createConstantSource.html)
         */
        createConstantSource(): any;
        /**
         *
         * 在插件中使用：不支持
         *
         * 创建一个DelayNode
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/WebAudioContext.createDelay.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/WebAudioContext.createDelay.html)
         */
        createDelay(maxDelayTime: number): any;
        /**
         *
         * 在插件中使用：不支持
         *
         * 创建一个DynamicsCompressorNode
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/WebAudioContext.createDynamicsCompressor.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/WebAudioContext.createDynamicsCompressor.html)
         */
        createDynamicsCompressor(): any;
        /**
         *
         * 在插件中使用：不支持
         *
         * 创建一个GainNode
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/WebAudioContext.createGain.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/WebAudioContext.createGain.html)
         */
        createGain(): any;
        /**
         *
         * 在插件中使用：不支持
         *
         * 创建一个IIRFilterNode
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/WebAudioContext.createIIRFilter.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/WebAudioContext.createIIRFilter.html)
         */
        createIIRFilter(feedforward: number[], feedback: number[]): any;
        /**
         *
         * 在插件中使用：不支持
         *
         * 创建一个OscillatorNode
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/WebAudioContext.createOscillator.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/WebAudioContext.createOscillator.html)
         */
        createOscillator(): any;
        /**
         *
         * 在插件中使用：不支持
         *
         * 创建一个PannerNode
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/WebAudioContext.createPanner.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/WebAudioContext.createPanner.html)
         */
        createPanner(): any;
        /**
         *
         * 在插件中使用：不支持
         *
         * 创建一个PeriodicWaveNode
         *
         * **注意**
         *
         * `real`和`imag`数组必须拥有一样的长度，否则抛出错误
         * ```js
         * const real = new Float32Array(2)
         * const imag = new Float32Array(2)
         * real[0] = 0
         * imag[0] = 0
         * real[1] = 1
         * imag[1] = 0
         *
         * const waveNode = audioContext.createPeriodicWave(real, imag, {disableNormalization: true})
         * ```
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/WebAudioContext.createPeriodicWave.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/WebAudioContext.createPeriodicWave.html)
         */
        createPeriodicWave(real: Float32Array, imag: Float32Array, constraints: Constraints): any;
        /**
         *
         * 在插件中使用：不支持
         *
         * 关闭WebAudioContext
         *
         * **注意事项**
         *
         * 同步关闭对应的WebAudio上下文。close后会立即释放当前上下文的资源，<b>不要在close后再次访问state属性。</b>
         * ```js
         * const audioCtx = wx.createWebAudioContext()
         * audioCtx.close().then(() => {
         * console.log(audioCtx.state) // bad case：不应该在close后再访问state
         * })
         * ```
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/WebAudioContext.close.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/WebAudioContext.close.html)
         */
        close(): Promise<any>;
        /**
         *
         * 在插件中使用：不支持
         *
         * 同步恢复已经被暂停的WebAudioContext上下文
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/WebAudioContext.resume.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/WebAudioContext.resume.html)
         */
        resume(): Promise<any>;
        /**
         *
         * 在插件中使用：不支持
         *
         * 同步暂停WebAudioContext上下文
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/WebAudioContext.suspend.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/WebAudioContext.suspend.html)
         */
        suspend(): Promise<any>;
        /**
         *
         * 在插件中使用：不支持
         *
         * 创建一个ScriptProcessorNode
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/WebAudioContext.createScriptProcessor.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/WebAudioContext.createScriptProcessor.html)
         */
        createScriptProcessor(bufferSize: number, numberOfInputChannels: number, numberOfOutputChannels: number): any;
        /**
         *
         * 在插件中使用：不支持
         *
         * 创建一个WaveShaperNode
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/WebAudioContext.createWaveShaper.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/WebAudioContext.createWaveShaper.html)
         */
        createWaveShaper(): any;
        /**
         *
         * 在插件中使用：不支持
         *
         * 创建一个AudioBuffer，代表着一段驻留在内存中的短音频
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/WebAudioContext.createBuffer.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/WebAudioContext.createBuffer.html)
         */
        createBuffer(numOfChannels: number, length: number, sampleRate: number): AudioBuffer;
        /**
         *
         * 在插件中使用：不支持
         *
         * 异步解码一段资源为AudioBuffer。
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/WebAudioContext.decodeAudioData.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/WebAudioContext.decodeAudioData.html)
         */
        decodeAudioData(audioData: ArrayBuffer, successCallback: (...args: any[]) => any, errorCallback: (...args: any[]) => any): AudioBuffer;
        /**
         *
         * 在插件中使用：不支持
         *
         * 创建一个BufferSourceNode实例，通过AudioBuffer对象来播放音频数据。
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/WebAudioContext.createBufferSource.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/WebAudioContext.createBufferSource.html)
         */
        createBufferSource(): BufferSourceNode;
    }

    /**
     * 需要添加的卡券列表
     */
    interface AddCardRequestInfo {
        /**
         * 卡券的扩展参数。需将 CardExt 对象 JSON 序列化为**字符串**传入
         */
        cardExt: string;
        /**
         * 卡券 ID
         */
        cardId: string;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type AddCardCompleteCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用失败的回调函数
     */
    type AddCardFailCallback = (res: GeneralCallbackResult) => void;

    /**
     * 卡券添加结果列表
     */
    interface AddCardResponseInfo {
        /**
         * 卡券的扩展参数，结构请参考下文
         */
        cardExt: string;
        /**
         * 用户领取到卡券的 ID
         */
        cardId: string;
        /**
         * 加密 code，为用户领取到卡券的code加密后的字符串，解密请参照：[code 解码接口](https://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1499332673_Unm7V)
         */
        code: string;
        /**
         * 是否成功
         */
        isSuccess: boolean;
    }

    interface AddCardSuccessCallbackResult {
        /**
         * 卡券添加结果列表
         */
        cardList: AddCardResponseInfo[];
        errMsg: string;
    }

    /**
     * 接口调用成功的回调函数
     */
    type AddCardSuccessCallback = (result: AddCardSuccessCallbackResult) => void;

    interface AddCardOption {
        /**
         * 需要添加的卡券列表
         */
        cardList: AddCardRequestInfo[];
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: AddCardCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: AddCardFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: AddCardSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type AddFileToFavoritesCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type AddFileToFavoritesFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type AddFileToFavoritesSuccessCallback = (
                res: GeneralCallbackResult
            ) => void;

    interface AddFileToFavoritesOption {
        /**
         * 要收藏的文件地址，必须为本地路径或临时路径
         */
        filePath: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: AddFileToFavoritesCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: AddFileToFavoritesFailCallback;
        /**
         * 自定义文件名，若留空则使用filePath中的文件名
         */
        fileName?: string;
        /**
         * 接口调用成功的回调函数
         */
        success?: AddFileToFavoritesSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type AddPhoneCalendarCompleteCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用失败的回调函数
     */
    type AddPhoneCalendarFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type AddPhoneCalendarSuccessCallback = (res: GeneralCallbackResult) => void;

    interface AddPhoneCalendarOption {
        /**
         * 开始时间的 unix 时间戳
         */
        startTime: number;
        /**
         * 日历事件标题
         */
        title: string;
        /**
         * 是否提醒，默认 true
         */
        alarm?: boolean;
        /**
         * 提醒提前量，单位秒，默认 0 表示开始时提醒
         */
        alarmOffset?: number;
        /**
         * 是否全天事件，默认 false
         */
        allDay?: boolean;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: AddPhoneCalendarCompleteCallback;
        /**
         * 事件说明
         */
        description?: string;
        /**
         * 结束时间的 unix 时间戳，默认与开始时间相同
         */
        endTime?: string;
        /**
         * 接口调用失败的回调函数
         */
        fail?: AddPhoneCalendarFailCallback;
        /**
         * 事件位置
         */
        location?: string;
        /**
         * 需要基础库： `3.7.6`
         *
         * 跳转小程序路径，必须要和 signature 一起使用，填入后会自动生成跳转链接拼接在事件说明中
         */
        path?: string;
        /**
         * 需要基础库： `3.7.6`
         *
         * 跳转小程序路径签名，必须要和 path 一起使用，用 session_key 对 path 签名得到的结果，即 `hmac_sha256(session_key, path)`。详见 [用户数据的签名验证和加解密](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.html)
         */
        signature?: string;
        /**
         * 接口调用成功的回调函数
         */
        success?: AddPhoneCalendarSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type AddPhoneRepeatCalendarCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type AddPhoneRepeatCalendarFailCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用成功的回调函数
     */
    type AddPhoneRepeatCalendarSuccessCallback = (
                res: GeneralCallbackResult
            ) => void;

    interface AddPhoneRepeatCalendarOption {
        /**
         * 开始时间的 unix 时间戳 (1970年1月1日开始所经过的秒数)
         */
        startTime: number;
        /**
         * 日历事件标题
         */
        title: string;
        /**
         * 是否提醒，默认 true
         */
        alarm?: boolean;
        /**
         * 提醒提前量，单位秒，默认 0 表示开始时提醒
         */
        alarmOffset?: number;
        /**
         * 是否全天事件，默认 false
         */
        allDay?: boolean;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: AddPhoneRepeatCalendarCompleteCallback;
        /**
         * 事件说明
         */
        description?: string;
        /**
         * 结束时间的 unix 时间戳，默认与开始时间相同
         */
        endTime?: string;
        /**
         * 接口调用失败的回调函数
         */
        fail?: AddPhoneRepeatCalendarFailCallback;
        /**
         * 事件位置
         */
        location?: string;
        /**
         * 需要基础库： `3.7.6`
         *
         * 跳转小程序路径，必须要和 signature 一起使用，填入后会自动生成跳转链接拼接在事件说明中
         */
        path?: string;
        /**
         * 重复周期结束时间的 unix 时间戳，不填表示一直重复
         */
        repeatEndTime?: number;
        /**
         * 重复周期，默认 month 每月重复
         *
         * 可选值：
         * - 'day': 每天重复;
         * - 'week': 每周重复;
         * - 'month': 每月重复。该模式日期不能大于 28 日;
         * - 'year': 每年重复;
         */
        repeatInterval?: "day" | "week" | "month" | "year";
        /**
         * 需要基础库： `3.7.6`
         *
         * 跳转小程序路径签名，必须要和 path 一起使用，用 session_key 对 path 签名得到的结果，即 `hmac_sha256(session_key, path)`。详见 [用户数据的签名验证和加解密](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.html)
         */
        signature?: string;
        /**
         * 接口调用成功的回调函数
         */
        success?: AddPhoneRepeatCalendarSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type AddVideoToFavoritesCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type AddVideoToFavoritesFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type AddVideoToFavoritesSuccessCallback = (
                res: GeneralCallbackResult
            ) => void;

    interface AddVideoToFavoritesOption {
        /**
         * 要收藏的视频地址，必须为本地路径或临时路径
         */
        videoPath: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: AddVideoToFavoritesCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: AddVideoToFavoritesFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: AddVideoToFavoritesSuccessCallback;
        /**
         * 缩略图路径，若留空则使用视频首帧
         */
        thumbPath?: string;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type AuthPrivateMessageCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type AuthPrivateMessageFailCallback = (res: GeneralCallbackResult) => void;

    interface AuthPrivateMessageSuccessCallbackResult {
        /**
         * 经过加密的activityId，解密后可得到原始的activityId。若解密后得到的activityId可以与开发者后台的活动id对应上则验证通过，否则表明valid字段不可靠（被篡改） 详细见[加密数据解密算法](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.html)
         */
        encryptedData: string;
        /**
         * 错误信息
         */
        errMsg: string;
        /**
         * 加密算法的初始向量，详细见[加密数据解密算法](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.html)
         */
        iv: string;
        /**
         * 验证是否通过
         */
        valid: boolean;
    }

    /**
     * 接口调用成功的回调函数
     */
    type AuthPrivateMessageSuccessCallback = (
                result: AuthPrivateMessageSuccessCallbackResult
            ) => void;

    interface AuthPrivateMessageOption {
        /**
         * shareTicket。可以从 wx.getEnterOptionsSync 中获取。详情 [shareTicket](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/share.html)
         */
        shareTicket: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: AuthPrivateMessageCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: AuthPrivateMessageFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: AuthPrivateMessageSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type AuthorizeForMiniProgramCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type AuthorizeForMiniProgramFailCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用成功的回调函数
     */
    type AuthorizeForMiniProgramSuccessCallback = (
                res: GeneralCallbackResult
            ) => void;

    interface AuthorizeForMiniProgramOption {
        /**
         * 需要获取权限的 scope，详见 [scope 列表](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/authorize.html#scope-列表)
         *
         * 可选值：
         * - 'scope.record': ;
         * - 'scope.writePhotosAlbum': ;
         * - 'scope.camera': ;
         */
        scope: "scope.record" | "scope.writePhotosAlbum" | "scope.camera";
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: AuthorizeForMiniProgramCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: AuthorizeForMiniProgramFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: AuthorizeForMiniProgramSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type BatchGetStorageCompleteCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用失败的回调函数
     */
    type BatchGetStorageFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type BatchGetStorageSuccessCallback = (res: GeneralCallbackResult) => void;

    interface BatchGetStorageOption {
        /**
         * 本地缓存中指定的 keyList
         */
        keyList: string[];
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: BatchGetStorageCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: BatchGetStorageFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: BatchGetStorageSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type BatchSetStorageCompleteCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用失败的回调函数
     */
    type BatchSetStorageFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type BatchSetStorageSuccessCallback = (res: GeneralCallbackResult) => void;

    interface BatchSetStorageOption {
        /**
         * [{ key, value }]
         */
        kvList: any[];
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: BatchSetStorageCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: BatchSetStorageFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: BatchSetStorageSuccessCallback;
    }

    interface KvList {
        /**
         * key 本地缓存中指定的 key
         */
        key: string;
        /**
         * data 需要存储的内容。只支持原生类型、Date、及能够通过`JSON.stringify`序列化的对象。
         */
        value: any;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type CheckDeviceSupportHevcCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type CheckDeviceSupportHevcFailCallback = (
                res: GeneralCallbackResult
            ) => void;

    interface CheckDeviceSupportHevcSuccessCallbackResult {
        /**
         * 设备是否支持 H.265 编码
         */
        supportHevc: boolean;
        errMsg: string;
    }

    /**
     * 接口调用成功的回调函数
     */
    type CheckDeviceSupportHevcSuccessCallback = (
                result: CheckDeviceSupportHevcSuccessCallbackResult
            ) => void;

    interface CheckDeviceSupportHevcOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: CheckDeviceSupportHevcCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: CheckDeviceSupportHevcFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: CheckDeviceSupportHevcSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type CheckIsAddedToMyMiniProgramCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type CheckIsAddedToMyMiniProgramFailCallback = (
                res: GeneralCallbackResult
            ) => void;

    interface CheckIsAddedToMyMiniProgramSuccessCallbackResult {
        /**
         * 是否被添加至 「我的小程序」
         */
        added: boolean;
        errMsg: string;
    }

    /**
     * 接口调用成功的回调函数
     */
    type CheckIsAddedToMyMiniProgramSuccessCallback = (
                result: CheckIsAddedToMyMiniProgramSuccessCallbackResult
            ) => void;

    interface CheckIsAddedToMyMiniProgramOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: CheckIsAddedToMyMiniProgramCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: CheckIsAddedToMyMiniProgramFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: CheckIsAddedToMyMiniProgramSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type CheckIsOpenAccessibilityCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type CheckIsOpenAccessibilityFailCallback = (
                res: GeneralCallbackResult
            ) => void;

    interface CheckIsOpenAccessibilitySuccessCallbackOption {
        /**
         * iOS 上开启辅助功能旁白，安卓开启 talkback 时返回 true
         */
        open: boolean;
        errMsg: string;
    }

    /**
     * 接口调用成功的回调函数
     */
    type CheckIsOpenAccessibilitySuccessCallback = (
                option: CheckIsOpenAccessibilitySuccessCallbackOption
            ) => void;

    interface CheckIsOpenAccessibilityOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: CheckIsOpenAccessibilityCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: CheckIsOpenAccessibilityFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: CheckIsOpenAccessibilitySuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type ChooseContactCompleteCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用失败的回调函数
     */
    type ChooseContactFailCallback = (res: GeneralCallbackResult) => void;

    interface ChooseContactSuccessCallbackOption {
        /**
         * 联系人姓名
         */
        displayName: string;
        /**
         * 手机号
         */
        phoneNumber: string;
        /**
         * 选定联系人的所有手机号（部分 Android 系统只能选联系人而不能选特定手机号）
         */
        phoneNumberList: string;
        errMsg: string;
    }

    /**
     * 接口调用成功的回调函数
     */
    type ChooseContactSuccessCallback = (
                option: ChooseContactSuccessCallbackOption
            ) => void;

    interface ChooseContactOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: ChooseContactCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: ChooseContactFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: ChooseContactSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type ChooseInvoiceCompleteCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用失败的回调函数
     */
    type ChooseInvoiceFailCallback = (res: GeneralCallbackResult) => void;

    interface ChooseInvoiceSuccessCallbackResult {
        /**
         * 用户选中的发票信息，格式为一个 JSON 字符串，包含三个字段： card_id：所选发票卡券的 cardId，encrypt_code：所选发票卡券的加密 code，报销方可以通过 cardId 和 encryptCode 获得报销发票的信息，app_id： 发票方的 appId。
         */
        invoiceInfo: string;
        errMsg: string;
    }

    /**
     * 接口调用成功的回调函数
     */
    type ChooseInvoiceSuccessCallback = (
                result: ChooseInvoiceSuccessCallbackResult
            ) => void;

    interface ChooseInvoiceOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: ChooseInvoiceCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: ChooseInvoiceFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: ChooseInvoiceSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type ChooseLicensePlateCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type ChooseLicensePlateFailCallback = (res: GeneralCallbackResult) => void;

    interface ChooseLicensePlateSuccessCallbackResult {
        /**
         * 用户选择的车牌号
         */
        plateNumber: string;
        errMsg: string;
    }

    /**
     * 接口调用成功的回调函数
     */
    type ChooseLicensePlateSuccessCallback = (
                result: ChooseLicensePlateSuccessCallbackResult
            ) => void;

    interface ChooseLicensePlateOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: ChooseLicensePlateCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: ChooseLicensePlateFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: ChooseLicensePlateSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type ChooseMediaCompleteCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用失败的回调函数
     */
    type ChooseMediaFailCallback = (res: GeneralCallbackResult) => void;

    /**
     * 本地临时文件列表
     */
    interface MediaFile {
        /**
         * 视频的时间长度
         */
        duration: number;
        /**
         * 文件类型
         *
         * 可选值：
         * - 'image': 图片;
         * - 'video': 视频;
         */
        fileType: "video" | "image";
        /**
         * 视频的高度
         */
        height: number;
        /**
         * 本地临时文件大小，单位 B
         */
        size: number;
        /**
         * 本地临时文件路径 (本地路径)
         */
        tempFilePath: string;
        /**
         * 视频缩略图临时文件路径
         */
        thumbTempFilePath: string;
        /**
         * 视频的宽度
         */
        width: number;
    }

    interface ChooseMediaSuccessCallbackResult {
        /**
         * 本地临时文件列表
         */
        tempFiles: MediaFile[];
        /**
         * 文件类型，有效值有 image 、video、mix
         */
        type: string;
        errMsg: string;
    }

    /**
     * 接口调用成功的回调函数
     */
    type ChooseMediaSuccessCallback = (
                result: ChooseMediaSuccessCallbackResult
            ) => void;

    interface ChooseMediaOption {
        /**
         * 仅在 sourceType 为 camera 时生效，使用前置或后置摄像头
         *
         * 可选值：
         * - 'back': 使用后置摄像头;
         * - 'front': 使用前置摄像头;
         */
        camera?: "back" | "front";
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: ChooseMediaCompleteCallback;
        /**
         * 最多可以选择的文件个数，基础库2.25.0前，最多可支持9个文件，2.25.0及以后最多可支持20个文件
         */
        count?: number;
        /**
         * 接口调用失败的回调函数
         */
        fail?: ChooseMediaFailCallback;
        /**
         * 拍摄视频最长拍摄时间，单位秒。时间范围为 3s 至 60s 之间。不限制相册。
         */
        maxDuration?: number;
        /**
         * 文件类型
         *
         * 可选值：
         * - 'image': 只能拍摄图片或从相册选择图片;
         * - 'video': 只能拍摄视频或从相册选择视频;
         * - 'mix': 可同时选择图片和视频;
         */
        mediaType?: ("video" | "image" | "mix")[];
        /**
         * 是否压缩所选文件，基础库2.25.0前仅对 mediaType 为 image 时有效，2.25.0及以后对全量 mediaType 有效
         */
        sizeType?: string[];
        /**
         * 图片和视频选择的来源
         *
         * 可选值：
         * - 'album': 从相册选择;
         * - 'camera': 使用相机拍摄;
         */
        sourceType?: ("album" | "camera")[];
        /**
         * 接口调用成功的回调函数
         */
        success?: ChooseMediaSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type ChooseMessageFileCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type ChooseMessageFileFailCallback = (res: GeneralCallbackResult) => void;

    /**
     * 返回选择的文件的本地临时文件对象数组
     */
    interface ChooseFile {
        /**
         * 选择的文件名称
         */
        name: string;
        /**
         * 本地临时文件路径 (本地路径)
         */
        path: string;
        /**
         * 本地临时文件大小，单位 B
         */
        size: number;
        /**
         * 选择的文件的会话发送时间，Unix时间戳，工具暂不支持此属性
         */
        time: number;
        /**
         * 选择的文件类型
         *
         * 可选值：
         * - 'video': 选择了视频文件;
         * - 'image': 选择了图片文件;
         * - 'file': 选择了除图片和视频的文件;
         */
        type: "video" | "image" | "file";
    }

    interface ChooseMessageFileSuccessCallbackResult {
        /**
         * 返回选择的文件的本地临时文件对象数组
         */
        tempFiles: ChooseFile[];
        errMsg: string;
    }

    /**
     * 接口调用成功的回调函数
     */
    type ChooseMessageFileSuccessCallback = (
                result: ChooseMessageFileSuccessCallbackResult
            ) => void;

    interface ChooseMessageFileOption {
        /**
         * 最多可以选择的文件个数，可以 0～100
         */
        count: number;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: ChooseMessageFileCompleteCallback;
        /**
         * 需要基础库： `2.6.0`
         *
         * 根据文件拓展名过滤，仅 type==file 时有效。每一项都不能是空字符串。默认不过滤。
         */
        extension?: string[];
        /**
         * 接口调用失败的回调函数
         */
        fail?: ChooseMessageFileFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: ChooseMessageFileSuccessCallback;
        /**
         * 所选的文件的类型
         *
         * 可选值：
         * - 'all': 从所有文件选择;
         * - 'video': 只能选择视频文件;
         * - 'image': 只能选择图片文件;
         * - 'file': 可以选择除了图片和视频之外的其它的文件;
         */
        type?: "all" | "video" | "image" | "file";
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type ChoosePoiCompleteCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用失败的回调函数
     */
    type ChoosePoiFailCallback = (res: GeneralCallbackResult) => void;

    interface ChoosePoiSuccessCallbackResult {
        /**
         * 详细地址
         */
        address: string;
        /**
         * 城市名称
         */
        city: number;
        /**
         * 纬度，浮点数，范围为-90~90，负数表示南纬。使用 gcj02 国测局坐标系（即将废弃）
         */
        latitude: number;
        /**
         * 经度，浮点数，范围为-180~180，负数表示西经。使用 gcj02 国测局坐标系（即将废弃）
         */
        longitude: number;
        /**
         * 位置名称
         */
        name: string;
        /**
         * 选择城市时，值为 1，选择精确位置时，值为 2
         */
        type: number;
        errMsg: string;
    }

    /**
     * 接口调用成功的回调函数
     */
    type ChoosePoiSuccessCallback = (
                result: ChoosePoiSuccessCallbackResult
            ) => void;

    interface ChoosePoiOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: ChoosePoiCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: ChoosePoiFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: ChoosePoiSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type CreateBLEPeripheralServerCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type CreateBLEPeripheralServerFailCallback = (
                res: GeneralCallbackResult
            ) => void;

    /**
     * 描述符的权限
     */
    interface DescriptorPermission {
        /**
         * 读
         */
        read?: boolean;
        /**
         * 写
         */
        write?: boolean;
    }

    /**
     * 描述符数据
     */
    interface CharacteristicDescriptor {
        /**
         * Descriptor 的 UUID
         */
        uuid: string;
        /**
         * 描述符的权限
         */
        permission?: DescriptorPermission;
        /**
         * 描述符数据
         */
        value?: ArrayBuffer;
    }

    /**
     * 特征权限
     */
    interface CharacteristicPermission {
        /**
         * 加密读请求
         */
        readEncryptionRequired?: boolean;
        /**
         * 可读
         */
        readable?: boolean;
        /**
         * 加密写请求
         */
        writeEncryptionRequired?: boolean;
        /**
         * 可写
         */
        writeable?: boolean;
    }

    /**
     * 特征支持的操作
     */
    interface CharacteristicProperties {
        /**
         * 回包
         */
        indicate?: boolean;
        /**
         * 订阅
         */
        notify?: boolean;
        /**
         * 读
         */
        read?: boolean;
        /**
         * 写
         */
        write?: boolean;
        /**
         * 无回复写
         */
        writeNoResponse?: boolean;
    }

    /**
     * characteristics列表
     */
    interface Characteristic {
        /**
         * characteristic 的 UUID
         */
        uuid: string;
        /**
         * 描述符数据
         */
        descriptors?: CharacteristicDescriptor[];
        /**
         * 特征权限
         */
        permission?: CharacteristicPermission;
        /**
         * 特征支持的操作
         */
        properties?: CharacteristicProperties;
        /**
         * 特征对应的二进制值
         */
        value?: ArrayBuffer;
    }

    /**
     * 描述service的Object
     */
    interface BLEPeripheralService {
        /**
         * characteristics列表
         */
        characteristics: Characteristic[];
        /**
         * 蓝牙服务的 UUID
         */
        uuid: string;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type AddServiceCompleteCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用失败的回调函数
     */
    type AddServiceFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type AddServiceSuccessCallback = (res: GeneralCallbackResult) => void;

    interface AddServiceOption {
        /**
         * 描述service的Object
         */
        service: BLEPeripheralService;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: AddServiceCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: AddServiceFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: AddServiceSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type SocketTaskCloseCompleteCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用失败的回调函数
     */
    type SocketTaskCloseFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type SocketTaskCloseSuccessCallback = (res: GeneralCallbackResult) => void;

    interface BLEPeripheralServerCloseOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: SocketTaskCloseCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: SocketTaskCloseFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: SocketTaskCloseSuccessCallback;
    }

    interface OnCharacteristicReadRequestListenerResult {
        /**
         * 唯一标识码，调用 [writeCharacteristicValue](https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth-peripheral/BLEPeripheralServer.writeCharacteristicValue.html) 时使用
         */
        callbackId: number;
        /**
         * 蓝牙特征的 UUID
         */
        characteristicId: string;
        /**
         * 蓝牙特征对应服务的 UUID
         */
        serviceId: string;
    }

    /**
     * onCharacteristicReadRequest 传入的监听函数。不传此参数则移除所有监听函数。
     */
    type OffCharacteristicReadRequestCallback = (
                result: OnCharacteristicReadRequestListenerResult
            ) => void;

    interface OnCharacteristicSubscribedListenerResult {
        /**
         * 蓝牙特征的 UUID
         */
        characteristicId: string;
        /**
         * 蓝牙特征对应服务的 UUID
         */
        serviceId: string;
    }

    /**
     * onCharacteristicSubscribed 传入的监听函数。不传此参数则移除所有监听函数。
     */
    type OffCharacteristicSubscribedCallback = (
                result: OnCharacteristicSubscribedListenerResult
            ) => void;
    /**
     * onCharacteristicUnsubscribed 传入的监听函数。不传此参数则移除所有监听函数。
     */
    type OffCharacteristicUnsubscribedCallback = (
                result: OnCharacteristicSubscribedListenerResult
            ) => void;

    interface OnCharacteristicWriteRequestListenerResult {
        /**
         * 唯一标识码，调用 [writeCharacteristicValue](https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth-peripheral/BLEPeripheralServer.writeCharacteristicValue.html) 时使用
         */
        callbackId: number;
        /**
         * 蓝牙特征的 UUID
         */
        characteristicId: string;
        /**
         * 蓝牙特征对应服务的 UUID
         */
        serviceId: string;
        /**
         * 请求写入特征的二进制数据值
         */
        value: ArrayBuffer;
    }

    /**
     * onCharacteristicWriteRequest 传入的监听函数。不传此参数则移除所有监听函数。
     */
    type OffCharacteristicWriteRequestCallback = (
                result: OnCharacteristicWriteRequestListenerResult
            ) => void;
    /**
     * 已连接的设备请求读当前外围设备的特征值事件的监听函数
     */
    type OnCharacteristicReadRequestCallback = (
                result: OnCharacteristicReadRequestListenerResult
            ) => void;
    /**
     * 特征订阅事件的监听函数
     */
    type OnCharacteristicSubscribedCallback = (
                result: OnCharacteristicSubscribedListenerResult
            ) => void;
    /**
     * 取消特征订阅事件的监听函数
     */
    type OnCharacteristicUnsubscribedCallback = (
                result: OnCharacteristicSubscribedListenerResult
            ) => void;
    /**
     * 已连接的设备请求写当前外围设备的特征值事件的监听函数
     */
    type OnCharacteristicWriteRequestCallback = (
                result: OnCharacteristicWriteRequestListenerResult
            ) => void;
    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type RemoveServiceCompleteCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用失败的回调函数
     */
    type RemoveServiceFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type RemoveServiceSuccessCallback = (res: GeneralCallbackResult) => void;

    interface RemoveServiceOption {
        /**
         * service 的 UUID
         */
        serviceId: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: RemoveServiceCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: RemoveServiceFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: RemoveServiceSuccessCallback;
    }

    /**
     * 需要基础库： `2.20.1`
     *
     * 以 beacon 设备形式广播的参数。
     */
    interface BeaconInfoObj {
        /**
         * Beacon 设备的主 ID
         */
        major: number;
        /**
         * Beacon 设备的次 ID
         */
        minor: number;
        /**
         * Beacon 设备广播的 UUID
         */
        uuid: string;
        /**
         * 用于判断距离设备 1 米时 RSSI 大小的参考值
         */
        measuredPower?: number;
    }

    /**
     * 广播的制造商信息。仅安卓支持，iOS 因系统限制无法定制。
     */
    interface ManufacturerData {
        /**
         * 制造商ID，0x 开头的十六进制
         */
        manufacturerId: string;
        /**
         * 制造商信息
         */
        manufacturerSpecificData?: ArrayBuffer;
    }

    /**
     * 广播自定义参数
     */
    interface AdvertiseReqObj {
        /**
         * 需要基础库： `2.20.1`
         *
         * 以 beacon 设备形式广播的参数。
         */
        beacon?: BeaconInfoObj;
        /**
         * 当前设备是否可连接
         */
        connectable?: boolean;
        /**
         * 广播中 deviceName 字段，默认为空
         */
        deviceName?: string;
        /**
         * 广播的制造商信息。仅安卓支持，iOS 因系统限制无法定制。
         */
        manufacturerData?: ManufacturerData[];
        /**
         * 要广播的服务 UUID 列表。使用 16/32 位 UUID 时请参考注意事项。
         */
        serviceUuids?: string[];
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type StartAdvertisingCompleteCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用失败的回调函数
     */
    type StartAdvertisingFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type StartAdvertisingSuccessCallback = (res: GeneralCallbackResult) => void;

    interface StartAdvertisingObject {
        /**
         * 广播自定义参数
         */
        advertiseRequest: AdvertiseReqObj;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: StartAdvertisingCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: StartAdvertisingFailCallback;
        /**
         * 广播功率
         *
         * 可选值：
         * - 'low': 功率低;
         * - 'medium': 功率适中;
         * - 'high': 功率高;
         */
        powerLevel?: "low" | "medium" | "high";
        /**
         * 接口调用成功的回调函数
         */
        success?: StartAdvertisingSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type StopAdvertisingCompleteCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用失败的回调函数
     */
    type StopAdvertisingFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type StopAdvertisingSuccessCallback = (res: GeneralCallbackResult) => void;

    interface StopAdvertisingOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: StopAdvertisingCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: StopAdvertisingFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: StopAdvertisingSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type WriteCharacteristicValueCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type WriteCharacteristicValueFailCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用成功的回调函数
     */
    type WriteCharacteristicValueSuccessCallback = (
                res: GeneralCallbackResult
            ) => void;

    interface WriteCharacteristicValueObject {
        /**
         * 蓝牙特征的 UUID
         */
        characteristicId: string;
        /**
         * 是否需要通知主机 value 已更新
         */
        needNotify: boolean;
        /**
         * 蓝牙特征对应服务的 UUID
         */
        serviceId: string;
        /**
         * characteristic 对应的二进制值
         */
        value: ArrayBuffer;
        /**
         * 可选，处理回包时使用
         */
        callbackId?: number;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: WriteCharacteristicValueCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: WriteCharacteristicValueFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: WriteCharacteristicValueSuccessCallback;
    }

    interface BLEPeripheralServer {
        /**
         *
         * 需要基础库： `2.10.3`
         *
         * 在插件中使用：不支持
         *
         * 添加服务。
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth-peripheral/BLEPeripheralServer.addService.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth-peripheral/BLEPeripheralServer.addService.html)
         */
        addService(option: AddServiceOption): void;
        /**
         *
         * 需要基础库： `2.10.3`
         *
         * 在插件中使用：不支持
         *
         * 关闭当前服务端。
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth-peripheral/BLEPeripheralServer.close.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth-peripheral/BLEPeripheralServer.close.html)
         */
        close(option?: BLEPeripheralServerCloseOption): void;
        /**
         *
         * 需要基础库： `2.10.3`
         *
         * 在插件中使用：不支持
         *
         * 移除已连接的设备请求读当前外围设备的特征值事件的监听函数
         *
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth-peripheral/BLEPeripheralServer.offCharacteristicReadRequest.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth-peripheral/BLEPeripheralServer.offCharacteristicReadRequest.html)
         */
        offCharacteristicReadRequest(listener?: OffCharacteristicReadRequestCallback): void;
        /**
         *
         * 需要基础库： `2.13.0`
         *
         * 在插件中使用：不支持
         *
         * 移除特征订阅事件的监听函数
         *
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth-peripheral/BLEPeripheralServer.offCharacteristicSubscribed.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth-peripheral/BLEPeripheralServer.offCharacteristicSubscribed.html)
         */
        offCharacteristicSubscribed(listener?: OffCharacteristicSubscribedCallback): void;
        /**
         *
         * 需要基础库： `2.13.0`
         *
         * 在插件中使用：不支持
         *
         * 移除取消特征订阅事件的监听函数
         *
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth-peripheral/BLEPeripheralServer.offCharacteristicUnsubscribed.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth-peripheral/BLEPeripheralServer.offCharacteristicUnsubscribed.html)
         */
        offCharacteristicUnsubscribed(listener?: OffCharacteristicUnsubscribedCallback): void;
        /**
         *
         * 需要基础库： `2.10.3`
         *
         * 在插件中使用：不支持
         *
         * 移除已连接的设备请求写当前外围设备的特征值事件的监听函数
         *
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth-peripheral/BLEPeripheralServer.offCharacteristicWriteRequest.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth-peripheral/BLEPeripheralServer.offCharacteristicWriteRequest.html)
         */
        offCharacteristicWriteRequest(listener?: OffCharacteristicWriteRequestCallback): void;
        /**
         *
         * 需要基础库： `2.10.3`
         *
         * 在插件中使用：不支持
         *
         * 监听已连接的设备请求读当前外围设备的特征值事件。收到该消息后需要立刻调用 [writeCharacteristicValue](https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth-peripheral/BLEPeripheralServer.writeCharacteristicValue.html) 写回数据，否则主机不会收到响应。
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth-peripheral/BLEPeripheralServer.onCharacteristicReadRequest.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth-peripheral/BLEPeripheralServer.onCharacteristicReadRequest.html)
         */
        onCharacteristicReadRequest(listener: OnCharacteristicReadRequestCallback): void;
        /**
         *
         * 需要基础库： `2.13.0`
         *
         * 在插件中使用：不支持
         *
         * 监听特征订阅事件，仅 iOS 支持。
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth-peripheral/BLEPeripheralServer.onCharacteristicSubscribed.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth-peripheral/BLEPeripheralServer.onCharacteristicSubscribed.html)
         */
        onCharacteristicSubscribed(listener: OnCharacteristicSubscribedCallback): void;
        /**
         *
         * 需要基础库： `2.13.0`
         *
         * 在插件中使用：不支持
         *
         * 监听取消特征订阅事件，仅 iOS 支持。
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth-peripheral/BLEPeripheralServer.onCharacteristicUnsubscribed.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth-peripheral/BLEPeripheralServer.onCharacteristicUnsubscribed.html)
         */
        onCharacteristicUnsubscribed(listener: OnCharacteristicUnsubscribedCallback): void;
        /**
         *
         * 需要基础库： `2.10.3`
         *
         * 在插件中使用：不支持
         *
         * 监听已连接的设备请求写当前外围设备的特征值事件。收到该消息后需要立刻调用 [writeCharacteristicValue](https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth-peripheral/BLEPeripheralServer.writeCharacteristicValue.html) 写回数据，否则主机不会收到响应。
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth-peripheral/BLEPeripheralServer.onCharacteristicWriteRequest.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth-peripheral/BLEPeripheralServer.onCharacteristicWriteRequest.html)
         */
        onCharacteristicWriteRequest(listener: OnCharacteristicWriteRequestCallback): void;
        /**
         *
         * 需要基础库： `2.10.3`
         *
         * 在插件中使用：不支持
         *
         * 移除服务。
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth-peripheral/BLEPeripheralServer.removeService.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth-peripheral/BLEPeripheralServer.removeService.html)
         */
        removeService(option: RemoveServiceOption): void;
        /**
         *
         * 需要基础库： `2.10.3`
         *
         * 在插件中使用：不支持
         *
         * 开始广播本地创建的外围设备。
         *
         * **注意**
         *
         * - Android 8.0.9 开始，支持直接使用 16/32/128 位 UUID；
         * - Android 8.0.9 以下版本只支持 128 位 UUID，使用 16/32 位的 UUID 时需要进行补位（系统会自动识别是否属于预分配区间），可以参考[蓝牙指南](https://developers.weixin.qq.com/miniprogram/dev/framework/device/ble.html)；
         * - iOS 必须直接使用 16 位的 UUID，不能补位到 128 位，否则系统组包时仍会按照 128 位传输。iOS 暂不支持 32 位 UUID。
         * - iOS 同时只能发起一个广播，安卓支持同时发起多个广播。
         * - 传 beacon 参数时，不能同时传入 deviceName，serviceUuids，manufacturerData 参数。
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth-peripheral/BLEPeripheralServer.startAdvertising.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth-peripheral/BLEPeripheralServer.startAdvertising.html)
         */
        startAdvertising(Object: StartAdvertisingObject): void;
        /**
         *
         * 需要基础库： `2.10.3`
         *
         * 在插件中使用：不支持
         *
         * 停止广播。
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth-peripheral/BLEPeripheralServer.stopAdvertising.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth-peripheral/BLEPeripheralServer.stopAdvertising.html)
         */
        stopAdvertising(option?: StopAdvertisingOption): void;
        /**
         *
         * 需要基础库： `2.10.3`
         *
         * 在插件中使用：不支持
         *
         * 往指定特征写入二进制数据值，并通知已连接的主机，从机的特征值已发生变化，该接口会处理是走回包还是走订阅。
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth-peripheral/BLEPeripheralServer.writeCharacteristicValue.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth-peripheral/BLEPeripheralServer.writeCharacteristicValue.html)
         */
        writeCharacteristicValue(Object: WriteCharacteristicValueObject): void;
    }

    interface CreateBLEPeripheralServerSuccessCallbackResult {
        /**
         *
         * 外围设备的服务端。
         *
         * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth-peripheral/BLEPeripheralServer.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth-peripheral/BLEPeripheralServer.html)
         */
        server: BLEPeripheralServer;
        errMsg: string;
    }

    /**
     * 接口调用成功的回调函数
     */
    type CreateBLEPeripheralServerSuccessCallback = (
                result: CreateBLEPeripheralServerSuccessCallbackResult
            ) => void;

    interface CreateBLEPeripheralServerOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: CreateBLEPeripheralServerCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: CreateBLEPeripheralServerFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: CreateBLEPeripheralServerSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type CropImageCompleteCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用失败的回调函数
     */
    type CropImageFailCallback = (res: GeneralCallbackResult) => void;

    interface CropImageSuccessCallbackResult {
        /**
         * 编辑后图片的临时文件路径 (本地路径)
         */
        tempFilePath: string;
        errMsg: string;
    }

    /**
     * 接口调用成功的回调函数
     */
    type CropImageSuccessCallback = (
                result: CropImageSuccessCallbackResult
            ) => void;

    interface CropImageOption {
        /**
         * 裁剪比例
         *
         * 可选值：
         * - '16:9': 宽高比为16比9;
         * - '9:16': 宽高比为9比16;
         * - '4:3': 宽高比为4比3;
         * - '3:4': 宽高比为3比4;
         * - '5:4': 宽高比为5比4;
         * - '4:5': 宽高比为4比5;
         * - '1:1': 宽高比为1比1;
         */
        cropScale: "16:9" | "9:16" | "4:3" | "3:4" | "5:4" | "4:5" | "1:1";
        /**
         * 图片路径，图片的路径，支持本地路径、代码包路径
         */
        src: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: CropImageCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: CropImageFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: CropImageSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type DisableAlertBeforeUnloadCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type DisableAlertBeforeUnloadFailCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用成功的回调函数
     */
    type DisableAlertBeforeUnloadSuccessCallback = (
                res: GeneralCallbackResult
            ) => void;

    interface DisableAlertBeforeUnloadOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: DisableAlertBeforeUnloadCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: DisableAlertBeforeUnloadFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: DisableAlertBeforeUnloadSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type EditImageCompleteCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用失败的回调函数
     */
    type EditImageFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type EditImageSuccessCallback = (
                result: CropImageSuccessCallbackResult
            ) => void;

    interface EditImageOption {
        /**
         * 图片路径，图片的路径，支持本地路径、代码包路径
         */
        src: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: EditImageCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: EditImageFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: EditImageSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type EnableAlertBeforeUnloadCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type EnableAlertBeforeUnloadFailCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用成功的回调函数
     */
    type EnableAlertBeforeUnloadSuccessCallback = (
                res: GeneralCallbackResult
            ) => void;

    interface EnableAlertBeforeUnloadOption {
        /**
         * 询问对话框内容
         */
        message: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: EnableAlertBeforeUnloadCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: EnableAlertBeforeUnloadFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: EnableAlertBeforeUnloadSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type ExitMiniProgramCompleteCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用失败的回调函数
     */
    type ExitMiniProgramFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type ExitMiniProgramSuccessCallback = (res: GeneralCallbackResult) => void;

    interface ExitMiniProgramOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: ExitMiniProgramCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: ExitMiniProgramFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: ExitMiniProgramSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type ExitVoIPChatCompleteCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用失败的回调函数
     */
    type ExitVoIPChatFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type ExitVoIPChatSuccessCallback = (res: GeneralCallbackResult) => void;

    interface ExitVoIPChatOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: ExitVoIPChatCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: ExitVoIPChatFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: ExitVoIPChatSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type FaceDetectCompleteCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用失败的回调函数
     */
    type FaceDetectFailCallback = (res: GeneralCallbackResult) => void;

    /**
     * 人脸角度信息，取值范围 [-1, 1]，数值越接近 0 表示越正对摄像头
     */
    interface FaceAngel {
        /**
         * 仰俯角（点头）
         */
        pitch: number;
        /**
         * 翻滚角（左右倾）
         */
        roll: number;
        /**
         * 偏航角（摇头）
         */
        yaw: number;
    }

    /**
     * 人脸置信度，取值范围 [0, 1]，数值越大置信度越高（遮挡越少）
     */
    interface FaceConf {
        /**
         * 整体可信度
         */
        global: number;
        /**
         * 左眼可信度
         */
        leftEye: number;
        /**
         * 嘴巴可信度
         */
        mouth: number;
        /**
         * 鼻子可信度
         */
        nose: number;
        /**
         * 右眼可信度
         */
        rightEye: number;
    }

    interface FaceDetectSuccessCallbackResult {
        /**
         * 人脸角度信息，取值范围 [-1, 1]，数值越接近 0 表示越正对摄像头
         */
        angleArray: FaceAngel;
        /**
         * 人脸置信度，取值范围 [0, 1]，数值越大置信度越高（遮挡越少）
         */
        confArray: FaceConf;
        /**
         * 脸部方框数值，对象包含 height, width, originX, originY 四个属性 (origin 为方框左上角坐标)
         */
        detectRect: any;
        /**
         * 多人模式（enableMultiFace）下的人脸信息，每个对象包含上述其它属性
         */
        faceInfo: any;
        /**
         * 标记人脸轮廓的 106 个点位置数组，数组每个对象包含 x 和 y
         */
        pointArray: any;
        /**
         * 脸部中心点横坐标，检测不到人脸则为 -1
         */
        x: number;
        /**
         * 脸部中心点纵坐标，检测不到人脸则为 -1
         */
        y: number;
        errMsg: string;
    }

    /**
     * 接口调用成功的回调函数
     */
    type FaceDetectSuccessCallback = (
                result: FaceDetectSuccessCallbackResult
            ) => void;

    interface FaceDetectOption {
        /**
         * 图像像素点数据，每四项表示一个像素点的 RGBA
         */
        frameBuffer: ArrayBuffer;
        /**
         * 图像高度
         */
        height: number;
        /**
         * 图像宽度
         */
        width: number;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: FaceDetectCompleteCallback;
        /**
         * 是否返回当前图像的人脸角度信息
         */
        enableAngle?: boolean;
        /**
         * 是否返回当前图像的人脸的置信度（可表示器官遮挡情况）
         */
        enableConf?: boolean;
        /**
         * 是否返回多张人脸的信息
         */
        enableMultiFace?: boolean;
        /**
         * 是否返回当前图像的人脸（106 个点）
         */
        enablePoint?: boolean;
        /**
         * 接口调用失败的回调函数
         */
        fail?: FaceDetectFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: FaceDetectSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type GetAvailableAudioSourcesCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type GetAvailableAudioSourcesFailCallback = (
                res: GeneralCallbackResult
            ) => void;

    interface GetAvailableAudioSourcesSuccessCallbackResult {
        /**
         * 支持的音频输入源列表，可在 [RecorderManager.start()](https://developers.weixin.qq.com/miniprogram/dev/api/media/recorder/RecorderManager.start.html) 接口中使用。返回值定义参考 https://developer.android.com/reference/kotlin/android/media/MediaRecorder.AudioSource
         *
         * 可选值：
         * - 'auto': 自动设置，默认使用手机麦克风，插上耳麦后自动切换使用耳机麦克风，所有平台适用;
         * - 'buildInMic': 手机麦克风，仅限 iOS;
         * - 'headsetMic': 耳机麦克风，仅限 iOS;
         * - 'mic': 麦克风（没插耳麦时是手机麦克风，插耳麦时是耳机麦克风），仅限 Android;
         * - 'camcorder': 同 mic，适用于录制音视频内容，仅限 Android;
         * - 'voice_communication': 同 mic，适用于实时沟通，仅限 Android;
         * - 'voice_recognition': 同 mic，适用于语音识别，仅限 Android;
         */
        audioSources: ("auto" | "buildInMic" | "headsetMic" | "mic" | "camcorder" | "voice_communication" | "voice_recognition")[];
        errMsg: string;
    }

    /**
     * 接口调用成功的回调函数
     */
    type GetAvailableAudioSourcesSuccessCallback = (
                result: GetAvailableAudioSourcesSuccessCallbackResult
            ) => void;

    interface GetAvailableAudioSourcesOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: GetAvailableAudioSourcesCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: GetAvailableAudioSourcesFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: GetAvailableAudioSourcesSuccessCallback;
    }

    interface BluetoothError {
        /**
         * 错误信息
         *
         * | 错误码 | 错误信息 | 说明 |
         * | - | - | - |
         * | 0 | ok | 正常 |
         * | -1 | already connect | 已连接 |
         * | 10000 | not init | 未初始化蓝牙适配器 |
         * | 10001 | not available | 当前蓝牙适配器不可用 |
         * | 10002 | no device | 没有找到指定设备 |
         * | 10003 | connection fail | 连接失败 |
         * | 10004 | no service | 没有找到指定服务 |
         * | 10005 | no characteristic | 没有找到指定特征 |
         * | 10006 | no connection | 当前连接已断开 |
         * | 10007 | property not support | 当前特征不支持此操作 |
         * | 10008 | system error | 其余所有系统上报的异常 |
         * | 10009 | system not support | Android 系统特有，系统版本低于 4.3 不支持 BLE |
         * | 10012 | operate time out | 连接超时 |
         * | 10013 | invalid_data | 连接 deviceId 为空或者是格式不正确 |
         */
        errMsg: string;
        /**
         * 错误码
         *
         * | 错误码 | 错误信息 | 说明 |
         * | - | - | - |
         * | 0 | ok | 正常 |
         * | -1 | already connect | 已连接 |
         * | 10000 | not init | 未初始化蓝牙适配器 |
         * | 10001 | not available | 当前蓝牙适配器不可用 |
         * | 10002 | no device | 没有找到指定设备 |
         * | 10003 | connection fail | 连接失败 |
         * | 10004 | no service | 没有找到指定服务 |
         * | 10005 | no characteristic | 没有找到指定特征 |
         * | 10006 | no connection | 当前连接已断开 |
         * | 10007 | property not support | 当前特征不支持此操作 |
         * | 10008 | system error | 其余所有系统上报的异常 |
         * | 10009 | system not support | Android 系统特有，系统版本低于 4.3 不支持 BLE |
         * | 10012 | operate time out | 连接超时 |
         * | 10013 | invalid_data | 连接 deviceId 为空或者是格式不正确 |
         */
        errCode: number;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type GetBLEMTUCompleteCallback = (res: BluetoothError) => void;
    /**
     * 接口调用失败的回调函数
     */
    type GetBLEMTUFailCallback = (res: BluetoothError) => void;

    interface GetBLEMTUSuccessCallbackResult {
        /**
         * 最大传输单元
         */
        mtu: number;
        errMsg: string;
    }

    /**
     * 接口调用成功的回调函数
     */
    type GetBLEMTUSuccessCallback = (
                result: GetBLEMTUSuccessCallbackResult
            ) => void;

    interface GetBLEMTUOption {
        /**
         * 蓝牙设备 id
         */
        deviceId: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: GetBLEMTUCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: GetBLEMTUFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: GetBLEMTUSuccessCallback;
        /**
         * 写模式 （iOS 特有参数）
         *
         * 可选值：
         * - 'write': 有回复写;
         * - 'writeNoResponse': 无回复写;
         */
        writeType?: "write" | "writeNoResponse";
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type GetBackgroundAudioPlayerStateCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type GetBackgroundAudioPlayerStateFailCallback = (
                res: GeneralCallbackResult
            ) => void;

    interface GetBackgroundAudioPlayerStateSuccessCallbackResult {
        /**
         * 选定音频的播放位置（单位：s），只有在音乐播放中时返回
         */
        currentPosition: number;
        /**
         * 歌曲数据链接，只有在音乐播放中时返回
         */
        dataUrl: string;
        /**
         * 音频的下载进度百分比，只有在音乐播放中时返回
         */
        downloadPercent: number;
        /**
         * 选定音频的长度（单位：s），只有在音乐播放中时返回
         */
        duration: number;
        /**
         * 播放状态
         *
         * 可选值：
         * - 0: 暂停中;
         * - 1: 播放中;
         * - 2: 没有音乐播放;
         */
        status: 0 | 1 | 2;
        errMsg: string;
    }

    /**
     * 接口调用成功的回调函数
     */
    type GetBackgroundAudioPlayerStateSuccessCallback = (
                result: GetBackgroundAudioPlayerStateSuccessCallbackResult
            ) => void;

    interface GetBackgroundAudioPlayerStateOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: GetBackgroundAudioPlayerStateCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: GetBackgroundAudioPlayerStateFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: GetBackgroundAudioPlayerStateSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type GetBackgroundFetchDataCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type GetBackgroundFetchDataFailCallback = (
                res: GeneralCallbackResult
            ) => void;

    interface GetBackgroundFetchDataSuccessCallbackResult {
        /**
         * 缓存数据
         */
        fetchedData: string;
        /**
         * 小程序页面路径
         */
        path: string;
        /**
         * 传给页面的 query 参数
         */
        query: string;
        /**
         * 进入小程序的场景值
         */
        scene: number;
        /**
         * 客户端拿到缓存数据的时间戳 ms。(iOS 时间戳存在异常，8.0.27 修复)
         */
        timeStamp: number;
        errMsg: string;
    }

    /**
     * 接口调用成功的回调函数
     */
    type GetBackgroundFetchDataSuccessCallback = (
                result: GetBackgroundFetchDataSuccessCallbackResult
            ) => void;

    interface GetBackgroundFetchDataOption {
        /**
         * 缓存数据类别，取值为 periodic 或 pre
         */
        fetchType: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: GetBackgroundFetchDataCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: GetBackgroundFetchDataFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: GetBackgroundFetchDataSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type GetBackgroundFetchTokenCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type GetBackgroundFetchTokenFailCallback = (
                res: GeneralCallbackResult
            ) => void;

    interface GetBackgroundFetchTokenSuccessCallbackResult {
        /**
         * 接口调用结果
         */
        errMsg: string;
        /**
         * 自定义的登录态
         */
        token: string;
    }

    /**
     * 接口调用成功的回调函数
     */
    type GetBackgroundFetchTokenSuccessCallback = (
                result: GetBackgroundFetchTokenSuccessCallbackResult
            ) => void;

    interface GetBackgroundFetchTokenOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: GetBackgroundFetchTokenCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: GetBackgroundFetchTokenFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: GetBackgroundFetchTokenSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type GetChannelsLiveInfoCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type GetChannelsLiveInfoFailCallback = (res: GeneralCallbackResult) => void;

    interface GetChannelsLiveInfoSuccessCallbackResult {
        /**
         * 直播主题
         */
        description: string;
        /**
         * 直播 feedId
         */
        feedId: string;
        /**
         * 视频号头像
         */
        headUrl: string;
        /**
         * 视频号昵称
         */
        nickname: string;
        /**
         * 直播 nonceId
         */
        nonceId: string;
        /**
         * 需要基础库： `2.29.0`
         *
         * 除最近的一条直播外，其他的直播列表（注意：每次最多返回按时间戳增序排列的15个直播信息，其中时间最近的那个直播会在接口其他的返回参数中展示，其余的直播会在该字段中展示）。
         */
        otherInfos: any[];
        /**
         * 需要基础库： `2.29.0`
         *
         * 直播回放状态
         *
         * 可选值：
         * - 0: 未生成;
         * - 1: 已生成;
         * - 3: 生成中;
         * - 6: 已过期;
         */
        replayStatus: 0 | 1 | 3 | 6;
        /**
         * 直播状态
         *
         * 可选值：
         * - 1: 直播状态不存在（针对未开过直播的主播）;
         * - 2: 直播中;
         * - 3: 直播已结束;
         * - 4: 直播准备中（未开播）;
         */
        status: 1 | 2 | 3 | 4;
        errMsg: string;
    }

    /**
     * 接口调用成功的回调函数
     */
    type GetChannelsLiveInfoSuccessCallback = (
                result: GetChannelsLiveInfoSuccessCallbackResult
            ) => void;

    interface GetChannelsLiveInfoOption {
        /**
         * 视频号 id，以“sph”开头的id，可在视频号助手获取
         */
        finderUserName: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: GetChannelsLiveInfoCompleteCallback;
        /**
         * 需要基础库： `2.29.0`
         *
         * 结束时间，筛选指定时间段的直播。若上传了startTime，未上传endTime，则endTime默认取当前时间
         */
        endTime?: number;
        /**
         * 接口调用失败的回调函数
         */
        fail?: GetChannelsLiveInfoFailCallback;
        /**
         * 需要基础库： `2.29.0`
         *
         * 起始时间，筛选指定时间段的直播。若上传了endTime，未上传startTime，则startTime默认为0
         */
        startTime?: number;
        /**
         * 接口调用成功的回调函数
         */
        success?: GetChannelsLiveInfoSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type GetChannelsLiveNoticeInfoCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type GetChannelsLiveNoticeInfoFailCallback = (
                res: GeneralCallbackResult
            ) => void;

    interface GetChannelsLiveNoticeInfoSuccessCallbackResult {
        /**
         * 直播封面
         */
        headUrl: string;
        /**
         * 视频号昵称
         */
        nickname: string;
        /**
         * 预告 id
         */
        noticeId: string;
        /**
         * 需要基础库： `2.24.6`
         *
         * 除最近的一条预告信息外，其他的预告信息列表（注意：每次最多返回按时间戳增序排列的15个预告信息，其中时间最近的那个预告信息会在接口其他的返回参数中展示，其余的预告信息会在该字段中展示）。
         */
        otherInfos: any[];
        /**
         * 是否可预约
         */
        reservable: boolean;
        /**
         * 开始时间
         */
        startTime: string;
        /**
         * 预告状态：0可用 1取消 2已用
         */
        status: number;
        errMsg: string;
    }

    /**
     * 接口调用成功的回调函数
     */
    type GetChannelsLiveNoticeInfoSuccessCallback = (
                result: GetChannelsLiveNoticeInfoSuccessCallbackResult
            ) => void;

    interface GetChannelsLiveNoticeInfoOption {
        /**
         * 视频号 id，以“sph”开头的id，可在视频号助手获取
         */
        finderUserName: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: GetChannelsLiveNoticeInfoCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: GetChannelsLiveNoticeInfoFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: GetChannelsLiveNoticeInfoSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type GetChannelsShareKeyCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type GetChannelsShareKeyFailCallback = (res: GeneralCallbackResult) => void;

    /**
     * 推广员
     */
    interface PromoterResult {
        /**
         * 推广员昵称
         */
        finderNickname: string;
        /**
         * 推广员 id
         */
        promoterId: string;
        /**
         * 推广员 openid
         */
        promoterOpenId: string;
    }

    interface GetChannelsShareKeySuccessCallbackResult {
        /**
         * 推广员
         */
        promoter: PromoterResult;
        /**
         * 分享者 openid
         */
        sharerOpenId: string;
        errMsg: string;
    }

    /**
     * 接口调用成功的回调函数
     */
    type GetChannelsShareKeySuccessCallback = (
                result: GetChannelsShareKeySuccessCallbackResult
            ) => void;

    interface GetChannelsShareKeyOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: GetChannelsShareKeyCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: GetChannelsShareKeyFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: GetChannelsShareKeySuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type GetChatToolInfoCompleteCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用失败的回调函数
     */
    type GetChatToolInfoFailCallback = (res: GeneralCallbackResult) => void;

    interface GetChatToolInfoSuccessCallbackResult {
        /**
         * 敏感数据对应的云 ID，开通[云开发](https://developers.weixin.qq.com/miniprogram/dev/wxcloudservice/wxcloud/basis/getting-started.html)的小程序才会返回，可通过云调用直接获取开放数据，详细见[云调用直接获取开放数据](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.html#method-cloud)
         */
        cloudID: string;
        /**
         * 包括敏感数据在内的完整转发信息的加密数据，详细见[加密数据解密算法](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.html)
         */
        encryptedData: string;
        /**
         * 错误信息
         */
        errMsg: string;
        /**
         * 加密算法的初始向量，详细见[加密数据解密算法](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.html)
         */
        iv: string;
    }

    /**
     * 接口调用成功的回调函数
     */
    type GetChatToolInfoSuccessCallback = (
                result: GetChatToolInfoSuccessCallbackResult
            ) => void;

    interface GetChatToolInfoOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: GetChatToolInfoCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: GetChatToolInfoFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: GetChatToolInfoSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type GetCommonConfigCompleteCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用失败的回调函数
     */
    type GetCommonConfigFailCallback = (res: GeneralCallbackResult) => void;

    interface GetCommonConfigSuccessCallbackResult {
        /**
         * 根据conf_type来确定conf内容,conf_type为1时conf是一个json数组, 类似"[{xxx},{xxx}]", 每一项对应表类型每一行配置内容, 其中conf_type为2时conf是一个json对象，类似"{xxxx}"
         */
        conf: string;
        /**
         * 配置类型, 1-表类型 2-kv类型
         */
        conf_type: number;
        /**
         * 错误码
         */
        errcode: number;
        /**
         * 错误信息
         */
        errmsg: string;
        /**
         * 过期时间,单位秒. 0表示当次有效
         */
        expire_sec: number;
        errMsg: string;
    }

    /**
     * 接口调用成功的回调函数
     */
    type GetCommonConfigSuccessCallback = (
                result: GetCommonConfigSuccessCallbackResult
            ) => void;

    interface GetCommonConfigOption {
        /**
         * 0：通用配置模式 1：实验模式, 参数与返回结果的使用等效于接口[uni.getExptInfoSync](https://developers.weixin.qq.com/miniprogram/dev/api/data-analysis/wx.getExptInfoSync.html)
         */
        mode: number;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: GetCommonConfigCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: GetCommonConfigFailCallback;
        /**
         * 需要获取的数据指标的对象数组，每个string的格式约定：配置类型_分表key
         */
        keys?: string[];
        /**
         * 接口调用成功的回调函数
         */
        success?: GetCommonConfigSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type GetDeviceBenchmarkInfoCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type GetDeviceBenchmarkInfoFailCallback = (
                res: GeneralCallbackResult
            ) => void;

    interface GetDeviceBenchmarkInfoSuccessCallbackResult {
        /**
         * 需要基础库： `3.4.5`
         *
         * 设备性能等级。-1（性能未知），>=1（设备性能值，该值越高，设备性能越好，目前最高不超过50）<br> 注意：设备的benchmarkLevel值不会随着时间的推移而变化
         */
        benchmarkLevel: number;
        /**
         * 需要基础库： `3.4.5`
         *
         * 设备机型档位。0（档位未知），1（高档机），2（中档机），3（低档机）<br> 注意：设备的机型档位会随着时间的推移而变化，因此在使用时请谨慎对待；若业务逻辑依赖于机型档位，但担心受到机型档位变化的影响，请参考[设备档位映射文档](https://developers.weixin.qq.com/minigame/dev/guide/performance/perf-benchmarkLevel.html)自行判断机型档位
         */
        modelLevel: number;
        errMsg: string;
    }

    /**
     * 接口调用成功的回调函数
     */
    type GetDeviceBenchmarkInfoSuccessCallback = (
                result: GetDeviceBenchmarkInfoSuccessCallbackResult
            ) => void;

    interface GetDeviceBenchmarkInfoOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: GetDeviceBenchmarkInfoCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: GetDeviceBenchmarkInfoFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: GetDeviceBenchmarkInfoSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type GetDeviceVoIPListCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type GetDeviceVoIPListFailCallback = (res: GeneralCallbackResult) => void;

    interface DeviceVoIPInfo {
        /**
         * 需要基础库： `2.30.4`
         *
         * 设备组的唯一标识 id（仅设备组时）
         */
        group_id: string;
        /**
         * 设备型号 id。通过微信公众平台注册设备获得。（仅单台设备时）
         */
        model_id: string;
        /**
         * 设备唯一序列号。（仅单台设备时）
         */
        sn: string;
        /**
         * 设备（组）授权状态。0：未授权；1：已授权
         */
        status: number;
    }

    interface GetDeviceVoIPListSuccessCallbackResult {
        list: DeviceVoIPInfo[];
        errMsg: string;
    }

    /**
     * 接口调用成功的回调函数
     */
    type GetDeviceVoIPListSuccessCallback = (
                result: GetDeviceVoIPListSuccessCallbackResult
            ) => void;

    interface GetDeviceVoIPListOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: GetDeviceVoIPListCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: GetDeviceVoIPListFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: GetDeviceVoIPListSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type GetFuzzyLocationCompleteCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用失败的回调函数
     */
    type GetFuzzyLocationFailCallback = (res: GeneralCallbackResult) => void;

    interface GetFuzzyLocationSuccessCallbackResult {
        /**
         * 纬度，范围为 -90~90，负数表示南纬
         */
        latitude: number;
        /**
         * 经度，范围为 -180~180，负数表示西经
         */
        longitude: number;
        errMsg: string;
    }

    /**
     * 接口调用成功的回调函数
     */
    type GetFuzzyLocationSuccessCallback = (
                result: GetFuzzyLocationSuccessCallbackResult
            ) => void;

    interface GetFuzzyLocationOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: GetFuzzyLocationCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: GetFuzzyLocationFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: GetFuzzyLocationSuccessCallback;
        /**
         * 返回的坐标类型
         *
         * 可选值：
         * - 'wgs84': 返回 gps 坐标;
         * - 'gcj02': 返回 gcj02 坐标，可用于 wx.openLocation;
         */
        type?: "wgs84" | "gcj02";
    }

    interface GetGroupEnterInfoError {
        /**
         * 错误信息
         *
         * | 错误码 | 错误信息 | 说明 |
         * | - | - | - |
         * | 40097 |  | 场景错误 |
         * | 65206 |  | 用户已不在该群内 |
         */
        errMsg: string;
        /**
         * 错误码
         *
         * | 错误码 | 错误信息 | 说明 |
         * | - | - | - |
         * | 40097 |  | 场景错误 |
         * | 65206 |  | 用户已不在该群内 |
         */
        errCode: number;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type GetGroupEnterInfoCompleteCallback = (
                res: GetGroupEnterInfoError
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type GetGroupEnterInfoFailCallback = (res: GetGroupEnterInfoError) => void;

    interface GetGroupEnterInfoSuccessCallbackResult {
        /**
         * 需要基础库： `2.7.0`
         *
         * 敏感数据对应的云 ID，开通[云开发](https://developers.weixin.qq.com/miniprogram/dev/wxcloudservice/wxcloud/basis/getting-started.html)的小程序才会返回，可通过云调用直接获取开放数据，详细见[云调用直接获取开放数据](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.html#method-cloud)
         */
        cloudID: string;
        /**
         * 包括敏感数据在内的完整转发信息的加密数据，详细见[加密数据解密算法](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.html)
         */
        encryptedData: string;
        /**
         * 错误信息
         */
        errMsg: string;
        /**
         * 加密算法的初始向量，详细见[加密数据解密算法](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.html)
         */
        iv: string;
    }

    /**
     * 接口调用成功的回调函数
     */
    type GetGroupEnterInfoSuccessCallback = (
                result: GetGroupEnterInfoSuccessCallbackResult
            ) => void;

    interface GetGroupEnterInfoOption {
        /**
         * 需要基础库： `3.7.8`
         *
         * 开启后单聊下返回 open_single_roomid
         */
        allowSingleChat?: boolean;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: GetGroupEnterInfoCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: GetGroupEnterInfoFailCallback;
        /**
         * 需要基础库： `3.7.8`
         *
         * 开启后返回用户在群(含单聊)下的 group_openid
         */
        needGroupOpenID?: boolean;
        /**
         * 接口调用成功的回调函数
         */
        success?: GetGroupEnterInfoSuccessCallback;
    }

    interface NFCError {
        /**
         * 错误信息
         *
         * | 错误码 | 错误信息 | 说明 |
         * | - | - | - |
         * | 0 | ok | 正常 |
         * | 13000 |  | 当前设备不支持NFC |
         * | 13001 |  | 当前设备支持NFC，但系统NFC开关未开启 |
         * | 13002 |  | 当前设备支持NFC，但不支持HCE |
         * | 13003 |  | AID列表参数格式错误 |
         * | 13004 |  | 未设置微信为默认NFC支付应用 |
         * | 13005 |  | 返回的指令不合法 |
         * | 13006 |  | 注册AID失败 |
         */
        errMsg: string;
        /**
         * 错误码
         *
         * | 错误码 | 错误信息 | 说明 |
         * | - | - | - |
         * | 0 | ok | 正常 |
         * | 13000 |  | 当前设备不支持NFC |
         * | 13001 |  | 当前设备支持NFC，但系统NFC开关未开启 |
         * | 13002 |  | 当前设备支持NFC，但不支持HCE |
         * | 13003 |  | AID列表参数格式错误 |
         * | 13004 |  | 未设置微信为默认NFC支付应用 |
         * | 13005 |  | 返回的指令不合法 |
         * | 13006 |  | 注册AID失败 |
         */
        errCode: number;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type GetHCEStateCompleteCallback = (res: NFCError) => void;
    /**
     * 接口调用失败的回调函数
     */
    type GetHCEStateFailCallback = (res: NFCError) => void;
    /**
     * 接口调用成功的回调函数
     */
    type GetHCEStateSuccessCallback = (res: NFCError) => void;

    interface GetHCEStateOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: GetHCEStateCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: GetHCEStateFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: GetHCEStateSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type GetInferenceEnvInfoCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type GetInferenceEnvInfoFailCallback = (res: GeneralCallbackResult) => void;

    interface GetInferenceEnvInfoSuccessCallbackResult {
        /**
         * AI推理引擎版本
         */
        ver: string;
        errMsg: string;
    }

    /**
     * 接口调用成功的回调函数
     */
    type GetInferenceEnvInfoSuccessCallback = (
                result: GetInferenceEnvInfoSuccessCallbackResult
            ) => void;

    interface GetInferenceEnvInfoOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: GetInferenceEnvInfoCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: GetInferenceEnvInfoFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: GetInferenceEnvInfoSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type GetLocalIPAddressCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type GetLocalIPAddressFailCallback = (res: GeneralCallbackResult) => void;

    interface GetLocalIPAddressSuccessCallbackResult {
        /**
         * 错误信息
         */
        errMsg: string;
        /**
         * 本机局域网IP地址
         */
        localip: string;
        /**
         * 本机局域网子网掩码，基础库 2.24.0 开始支持
         */
        netmask: string;
    }

    /**
     * 接口调用成功的回调函数
     */
    type GetLocalIPAddressSuccessCallback = (
                result: GetLocalIPAddressSuccessCallbackResult
            ) => void;

    interface GetLocalIPAddressOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: GetLocalIPAddressCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: GetLocalIPAddressFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: GetLocalIPAddressSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type GetPrivacySettingCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type GetPrivacySettingFailCallback = (res: GeneralCallbackResult) => void;

    interface GetPrivacySettingSuccessCallbackResult {
        /**
         * 是否需要用户授权隐私协议（如果开发者没有在「MP后台-设置-服务内容声明-用户隐私保护指引」中声明隐私收集类型则会返回false；如果开发者声明了隐私收集，且用户之前同意过隐私协议则会返回false；如果开发者声明了隐私收集，且用户还没同意过则返回true；如果用户之前同意过、但后来小程序又新增了隐私收集类型也会返回true）
         */
        needAuthorization: boolean;
        /**
         * 隐私授权协议的名称
         */
        privacyContractName: string;
        errMsg: string;
    }

    /**
     * 接口调用成功的回调函数
     */
    type GetPrivacySettingSuccessCallback = (
                result: GetPrivacySettingSuccessCallbackResult
            ) => void;

    interface GetPrivacySettingOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: GetPrivacySettingCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: GetPrivacySettingFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: GetPrivacySettingSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type GetScreenRecordingStateCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type GetScreenRecordingStateFailCallback = (
                res: GeneralCallbackResult
            ) => void;

    interface GetScreenRecordingStateSuccessCallbackResult {
        /**
         * 录屏状态
         *
         * 可选值：
         * - 'on': 开启;
         * - 'off': 关闭;
         */
        state: "on" | "off";
        errMsg: string;
    }

    /**
     * 接口调用成功的回调函数
     */
    type GetScreenRecordingStateSuccessCallback = (
                result: GetScreenRecordingStateSuccessCallbackResult
            ) => void;

    interface GetScreenRecordingStateOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: GetScreenRecordingStateCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: GetScreenRecordingStateFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: GetScreenRecordingStateSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type GetShareInfoCompleteCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用失败的回调函数
     */
    type GetShareInfoFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type GetShareInfoSuccessCallback = (
                result: GetGroupEnterInfoSuccessCallbackResult
            ) => void;

    interface GetShareInfoOption {
        /**
         * shareTicket，详见[获取更多转发信息](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/share.html#获取更多转发信息)
         */
        shareTicket: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: GetShareInfoCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: GetShareInfoFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: GetShareInfoSuccessCallback;
        /**
         * 需要基础库： `1.9.90`
         *
         * 超时时间，单位 ms
         */
        timeout?: number;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type GetShowSplashAdStatusCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type GetShowSplashAdStatusFailCallback = (
                res: GeneralCallbackResult
            ) => void;

    interface GetShowSplashAdStatusSuccessCallbackResult {
        /**
         * 封面广告组件展示状态码
         *
         * 可选值：
         * - -1: 初始值，状态未知;
         * - 1: 展示成功;
         * - 2: 主动拦截过滤，不展示广告;
         * - 3: 展示超时;
         */
        code: 1 | 2 | 3 | -1;
        /**
         * 封面广告组件展示状态
         *
         * 可选值：
         * - 'unknown': 初始值，状态未知;
         * - 'pending': 进行展示中;
         * - 'success': 展示成功;
         * - 'fail': 展示失败;
         */
        status: "unknown" | "pending" | "success" | "fail";
        errMsg: string;
    }

    /**
     * 接口调用成功的回调函数
     */
    type GetShowSplashAdStatusSuccessCallback = (
                result: GetShowSplashAdStatusSuccessCallbackResult
            ) => void;

    interface GetShowSplashAdStatusOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: GetShowSplashAdStatusCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: GetShowSplashAdStatusFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: GetShowSplashAdStatusSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type GetSkylineInfoCompleteCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用失败的回调函数
     */
    type GetSkylineInfoFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type GetSkylineInfoSuccessCallback = (
                /** 当前运行环境对于 [Skyline 渲染引擎](https://developers.weixin.qq.com/miniprogram/dev/framework/runtime/skyline/introduction.html) 的支持情况 */
                result: SkylineInfo
            ) => void;

    interface GetSkylineInfoOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: GetSkylineInfoCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: GetSkylineInfoFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: GetSkylineInfoSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type GetSystemInfoAsyncCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type GetSystemInfoAsyncFailCallback = (res: GeneralCallbackResult) => void;

    /**
     * 需要基础库： `2.12.3`
     *
     * 当前小程序运行的宿主环境
     */
    interface SystemInfoHost {
        /**
         * 宿主 app 对应的 appId
         */
        appId: string;
    }

    interface SystemInfo {
        /**
         * 需要基础库： `1.1.0`
         *
         * 客户端基础库版本
         */
        SDKVersion: string;
        /**
         * 需要基础库： `2.6.0`
         *
         * 允许微信使用相册的开关（仅 iOS 有效）
         */
        albumAuthorized: boolean;
        /**
         * 需要基础库： `1.8.0`
         *
         * 设备性能等级（仅 Android）。取值为：-2 或 0（该设备无法运行小游戏），-1（性能未知），>=1（设备性能值，该值越高，设备性能越好）<br> 注意：性能等级当前仅反馈真机机型，暂不支持 IDE 模拟器机型
         */
        benchmarkLevel: number;
        /**
         * 需要基础库： `2.6.0`
         *
         * 蓝牙的系统开关
         */
        bluetoothEnabled: boolean;
        /**
         * 需要基础库： `1.5.0`
         *
         * 设备品牌
         */
        brand: string;
        /**
         * 需要基础库： `2.6.0`
         *
         * 允许微信使用摄像头的开关
         */
        cameraAuthorized: boolean;
        /**
         * 设备方向（注意：IOS客户端横屏游戏获取deviceOrientation可能不准，建议以屏幕宽高为准）
         *
         * 可选值：
         * - 'portrait': 竖屏;
         * - 'landscape': 横屏;
         */
        deviceOrientation: "portrait" | "landscape";
        /**
         * 需要基础库： `2.15.0`
         *
         * 是否已打开调试。可通过右上角菜单或 [uni.setEnableDebug](https://developers.weixin.qq.com/miniprogram/dev/api/base/debug/wx.setEnableDebug.html) 打开调试。
         */
        enableDebug: boolean;
        /**
         * 需要基础库： `1.5.0`
         *
         * 用户字体大小（单位px）。以微信客户端「我-设置-通用-字体大小」中的设置为准
         */
        fontSizeSetting: number;
        /**
         * 需要基础库： `2.12.3`
         *
         * 当前小程序运行的宿主环境
         */
        host: SystemInfoHost;
        /**
         * 微信设置的语言
         */
        language: string;
        /**
         * 需要基础库： `2.6.0`
         *
         * 允许微信使用定位的开关
         */
        locationAuthorized: boolean;
        /**
         * 需要基础库： `2.6.0`
         *
         * 地理位置的系统开关
         */
        locationEnabled: boolean;
        /**
         * `true` 表示模糊定位，`false` 表示精确定位，仅 iOS 支持
         */
        locationReducedAccuracy: boolean;
        /**
         * 需要基础库： `2.6.0`
         *
         * 允许微信使用麦克风的开关
         */
        microphoneAuthorized: boolean;
        /**
         * 设备型号。新机型刚推出一段时间会显示unknown，微信会尽快进行适配。
         */
        model: string;
        /**
         * 需要基础库： `2.6.0`
         *
         * 允许微信通知带有提醒的开关（仅 iOS 有效）
         */
        notificationAlertAuthorized: boolean;
        /**
         * 需要基础库： `2.6.0`
         *
         * 允许微信通知的开关
         */
        notificationAuthorized: boolean;
        /**
         * 需要基础库： `2.6.0`
         *
         * 允许微信通知带有标记的开关（仅 iOS 有效）
         */
        notificationBadgeAuthorized: boolean;
        /**
         * 需要基础库： `2.6.0`
         *
         * 允许微信通知带有声音的开关（仅 iOS 有效）
         */
        notificationSoundAuthorized: boolean;
        /**
         * 需要基础库： `2.19.3`
         *
         * 允许微信使用日历的开关
         */
        phoneCalendarAuthorized: boolean;
        /**
         * 设备像素比
         */
        pixelRatio: number;
        /**
         * 客户端平台
         *
         * 可选值：
         * - 'ios': iOS微信（包含 iPhone、iPad）;
         * - 'android': Android微信;
         * - 'ohos': HarmonyOS微信;
         * - 'windows': Windows微信;
         * - 'mac': macOS微信;
         * - 'devtools': 微信开发者工具;
         */
        platform: "ios" | "android" | "ohos" | "windows" | "mac" | "devtools";
        /**
         * 需要基础库： `2.7.0`
         *
         * 在竖屏正方向下的安全区域。部分机型没有安全区域概念，也不会返回 safeArea 字段，开发者需自行兼容。
         */
        safeArea: SafeArea;
        /**
         * 需要基础库： `1.1.0`
         *
         * 屏幕高度，单位px
         */
        screenHeight: number;
        /**
         * 需要基础库： `1.1.0`
         *
         * 屏幕宽度，单位px
         */
        screenWidth: number;
        /**
         * 需要基础库： `1.9.0`
         *
         * 状态栏的高度，单位px
         */
        statusBarHeight: number;
        /**
         * 操作系统及版本
         */
        system: string;
        /**
         * 微信版本号
         */
        version: string;
        /**
         * 需要基础库： `2.6.0`
         *
         * Wi-Fi 的系统开关
         */
        wifiEnabled: boolean;
        /**
         * 可使用窗口高度，单位px
         */
        windowHeight: number;
        /**
         * 可使用窗口宽度，单位px
         */
        windowWidth: number;
        /**
         * 需要基础库： `2.11.0`
         *
         * 系统当前主题，取值为`light`或`dark`，全局配置`"darkmode":true`时才能获取，否则为 undefined （不支持小游戏）
         *
         * 可选值：
         * - 'dark': 深色主题;
         * - 'light': 浅色主题;
         */
        theme?: "dark" | "light";
    }

    /**
     * 接口调用成功的回调函数
     */
    type GetSystemInfoAsyncSuccessCallback = (result: SystemInfo) => void;

    interface GetSystemInfoAsyncOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: GetSystemInfoAsyncCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: GetSystemInfoAsyncFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: GetSystemInfoAsyncSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type GetWeRunDataCompleteCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用失败的回调函数
     */
    type GetWeRunDataFailCallback = (res: GeneralCallbackResult) => void;

    interface GetWeRunDataSuccessCallbackResult {
        /**
         * 需要基础库： `2.7.0`
         *
         * 敏感数据对应的云 ID，开通云开发的小程序才会返回，可通过云调用直接获取开放数据，详细见[云调用直接获取开放数据](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.html#method-cloud)
         */
        cloudID: string;
        /**
         * 包括敏感数据在内的完整用户信息的加密数据，详细见[加密数据解密算法](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.html)。解密后得到的数据结构见后文
         */
        encryptedData: string;
        /**
         * 加密算法的初始向量，详细见[加密数据解密算法](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.html)
         */
        iv: string;
        errMsg: string;
    }

    /**
     * 接口调用成功的回调函数
     */
    type GetWeRunDataSuccessCallback = (
                result: GetWeRunDataSuccessCallbackResult
            ) => void;

    interface GetWeRunDataOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: GetWeRunDataCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: GetWeRunDataFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: GetWeRunDataSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type InitFaceDetectCompleteCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用失败的回调函数
     */
    type InitFaceDetectFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type InitFaceDetectSuccessCallback = (res: GeneralCallbackResult) => void;

    interface InitFaceDetectOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: InitFaceDetectCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: InitFaceDetectFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: InitFaceDetectSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type IsBluetoothDevicePairedCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type IsBluetoothDevicePairedFailCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用成功的回调函数
     */
    type IsBluetoothDevicePairedSuccessCallback = (
                res: GeneralCallbackResult
            ) => void;

    interface IsBluetoothDevicePairedOption {
        /**
         * 蓝牙设备 id
         */
        deviceId: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: IsBluetoothDevicePairedCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: IsBluetoothDevicePairedFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: IsBluetoothDevicePairedSuccessCallback;
    }

    interface VoIP1v1ChatUser {
        /**
         * 昵称
         */
        nickname: string;
        /**
         * 小程序内 openid
         */
        openid: string;
        /**
         * 头像
         */
        headImage?: string;
    }

    interface Join1v1ChatError {
        /**
         * 错误信息
         *
         * | 错误码 | 错误信息 | 说明 |
         * | - | - | - |
         * | -20000 | not open 1v1 Chat | 未开通双人通话 |
         * | -20001 | device not support | 当前设备不支持 |
         * | -20002 | on call | 正在通话中 |
         * | -20003 | occupied by other miniprogram | 其它小程序正在通话中 |
         * | -30000 | system error | 内部系统错误 |
         * | -30001 | wechat has no camera authorization | 微信缺失相机权限 |
         * | -30002 | wechat has no record authorization | 微信缺失录音权限 |
         * | -30003 | miniprogram has no record authorization | 小程序缺失录音权限 |
         * | -30004 | miniprogram has no camera authorization | 小程序缺失相机权限 |
         * | -1 |  | 当前已在房间内 |
         * | -2 |  | 录音设备被占用，可能是当前正在使用微信内语音通话或系统通话 |
         * | -3 |  | 加入会话期间退出（可能是用户主动退出，或者退后台、来电等原因），因此加入失败 |
         * | -1000 |  | 系统错误 |
         */
        errMsg: string;
        /**
         * 错误码
         *
         * | 错误码 | 错误信息 | 说明 |
         * | - | - | - |
         * | -20000 | not open 1v1 Chat | 未开通双人通话 |
         * | -20001 | device not support | 当前设备不支持 |
         * | -20002 | on call | 正在通话中 |
         * | -20003 | occupied by other miniprogram | 其它小程序正在通话中 |
         * | -30000 | system error | 内部系统错误 |
         * | -30001 | wechat has no camera authorization | 微信缺失相机权限 |
         * | -30002 | wechat has no record authorization | 微信缺失录音权限 |
         * | -30003 | miniprogram has no record authorization | 小程序缺失录音权限 |
         * | -30004 | miniprogram has no camera authorization | 小程序缺失相机权限 |
         * | -1 |  | 当前已在房间内 |
         * | -2 |  | 录音设备被占用，可能是当前正在使用微信内语音通话或系统通话 |
         * | -3 |  | 加入会话期间退出（可能是用户主动退出，或者退后台、来电等原因），因此加入失败 |
         * | -1000 |  | 系统错误 |
         */
        errCode: number;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type Join1v1ChatCompleteCallback = (res: Join1v1ChatError) => void;
    /**
     * 接口调用失败的回调函数
     */
    type Join1v1ChatFailCallback = (res: Join1v1ChatError) => void;
    /**
     * 接口调用成功的回调函数
     */
    type Join1v1ChatSuccessCallback = (res: Join1v1ChatError) => void;

    interface Join1v1ChatOption {
        /**
         * 呼叫方信息
         */
        caller: VoIP1v1ChatUser;
        /**
         * 接听方信息
         */
        listener: VoIP1v1ChatUser;
        /**
         * 窗口背景色(音频通话背景以及小窗模式背景)
         *
         * 可选值：
         * - 0: #262930;
         * - 1: #FA5151;
         * - 2: #FA9D3B;
         * - 3: #3D7257;
         * - 4: #1485EE;
         * - 5: #6467F0;
         */
        backgroundType?: 0 | 1 | 2 | 3 | 4 | 5;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: Join1v1ChatCompleteCallback;
        /**
         * 不允许切换到语音通话
         */
        disableSwitchVoice?: boolean;
        /**
         * 接口调用失败的回调函数
         */
        fail?: Join1v1ChatFailCallback;
        /**
         * 小窗样式
         */
        minWindowType?: number;
        /**
         * 通话类型
         *
         * 可选值：
         * - 'voice': 语音通话;
         * - 'video': 视频通话;
         */
        roomType?: "video" | "voice";
        /**
         * 接口调用成功的回调函数
         */
        success?: Join1v1ChatSuccessCallback;
    }

    interface JoinVoIPChatError {
        /**
         * 错误信息
         *
         * | 错误码 | 错误信息 | 说明 |
         * | - | - | - |
         * | -1 | 当前已在房间内 |  |
         * | -2 | 录音设备被占用，可能是当前正在使用微信内语音通话或系统通话 |  |
         * | -3 | 加入会话期间退出（可能是用户主动退出，或者退后台、来电等原因），因此加入失败 |  |
         * | -1000 | 系统错误 |  |
         */
        errMsg: string;
        /**
         * 错误码
         *
         * | 错误码 | 错误信息 | 说明 |
         * | - | - | - |
         * | -1 | 当前已在房间内 |  |
         * | -2 | 录音设备被占用，可能是当前正在使用微信内语音通话或系统通话 |  |
         * | -3 | 加入会话期间退出（可能是用户主动退出，或者退后台、来电等原因），因此加入失败 |  |
         * | -1000 | 系统错误 |  |
         */
        errCode: number;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type JoinVoIPChatCompleteCallback = (res: JoinVoIPChatError) => void;
    /**
     * 接口调用失败的回调函数
     */
    type JoinVoIPChatFailCallback = (res: JoinVoIPChatError) => void;

    /**
     * 静音设置
     */
    interface MuteConfig {
        /**
         * 是否静音耳机
         */
        muteEarphone?: boolean;
        /**
         * 是否静音麦克风
         */
        muteMicrophone?: boolean;
    }

    interface JoinVoIPChatSuccessCallbackResult {
        /**
         * 错误码
         */
        errCode: number;
        /**
         * 调用结果
         */
        errMsg: string;
        /**
         * 在此通话中的成员 openId 名单
         */
        openIdList: string[];
    }

    /**
     * 接口调用成功的回调函数
     */
    type JoinVoIPChatSuccessCallback = (
                result: JoinVoIPChatSuccessCallbackResult
            ) => void;

    interface JoinVoIPChatOption {
        /**
         * 小游戏内此房间/群聊的 ID。同一时刻传入相同 groupId 的用户会进入到同个实时语音房间。
         */
        groupId: string;
        /**
         * 验证所需的随机字符串
         */
        nonceStr: string;
        /**
         * 签名，用于验证小游戏的身份
         */
        signature: string;
        /**
         * 验证所需的时间戳
         */
        timeStamp: number;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: JoinVoIPChatCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: JoinVoIPChatFailCallback;
        /**
         * 需要基础库： `2.29.0`
         *
         * 开启后，joinVoIPChat 会同时走 Wi-Fi 和蜂窝网络2种网络模式，保证实时通话体验。
         */
        forceCellularNetwork?: boolean;
        /**
         * 静音设置
         */
        muteConfig?: MuteConfig;
        /**
         * 房间类型
         *
         * 可选值：
         * - 'voice': 音频房间，用于语音通话;
         * - 'video': 视频房间，结合 [voip-room](https://developers.weixin.qq.com/miniprogram/dev/component/voip-room.html) 组件可显示成员画面;
         */
        roomType?: "video" | "voice";
        /**
         * 接口调用成功的回调函数
         */
        success?: JoinVoIPChatSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type LoadBuiltInFontFaceCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type LoadBuiltInFontFaceFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type LoadBuiltInFontFaceSuccessCallback = (
                res: GeneralCallbackResult
            ) => void;

    interface LoadBuiltInFontFaceOption {
        /**
         * 定义的字体名称
         */
        family: string;
        /**
         * 要加载的内置字体名字
         *
         * 可选值：
         * - 'WeChatSansSS': WeChatSansSS 字体;
         * - 'WeChatSansStd': WeChatSansStd 字体;
         */
        source: "WeChatSansSS" | "WeChatSansStd";
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: LoadBuiltInFontFaceCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: LoadBuiltInFontFaceFailCallback;
        /**
         * <是否全局生效
         */
        global?: boolean;
        /**
         * 字体作用范围，可选值为 webview / native / skyline，默认全选，设置 native 可在 Canvas 2D 下使用
         */
        scopes?: any[];
        /**
         * 接口调用成功的回调函数
         */
        success?: LoadBuiltInFontFaceSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type MakeBluetoothPairCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type MakeBluetoothPairFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type MakeBluetoothPairSuccessCallback = (res: GeneralCallbackResult) => void;

    interface MakeBluetoothPairOption {
        /**
         * 蓝牙设备 id
         */
        deviceId: string;
        /**
         * pin 码，Base64 格式。
         */
        pin: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: MakeBluetoothPairCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: MakeBluetoothPairFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: MakeBluetoothPairSuccessCallback;
        /**
         * 超时时间，单位 ms
         */
        timeout?: number;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type NotifyGroupMembersCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type NotifyGroupMembersFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type NotifyGroupMembersSuccessCallback = (
                res: GeneralCallbackResult
            ) => void;

    interface NotifyGroupMembersOption {
        /**
         * 文字链跳转路径
         */
        entrancePath: string;
        /**
         * 需要提醒的用户 group_openid 列表
         */
        members: string[];
        /**
         * 文字链标题，发送的内容将由微信拼接为：@的成员列表+“请完成：”/"请参与："+打开小程序的文字链，如「@alex @cindy 请完成：团建报名统计」。
         */
        title: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: NotifyGroupMembersCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: NotifyGroupMembersFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: NotifyGroupMembersSuccessCallback;
        /**
         * 展示的动词
         *
         * 可选值：
         * - 'participate': 请参与;
         * - 'complete': 请完成;
         */
        type?: "participate" | "complete";
    }

    interface OnAfterPageLoadListenerResult {
        /**
         * 组件框架
         *
         * 可选值：
         * - 'exparser': 旧版小程序组件框架;
         * - 'glass-easel': 新版小程序组件框架;
         */
        componentFramework: "exparser" | "glass-easel";
        /**
         * 路由打开类型
         */
        openType: string;
        /**
         * 页面实例
         */
        page: any;
        /**
         * 页面路径
         */
        path: string;
        /**
         * 路由参数
         */
        query: any;
        /**
         * 路由事件 id
         */
        routeEventId: string;
    }

    /**
     * onAfterPageLoad 传入的监听函数。不传此参数则移除所有监听函数。
     */
    type OffAfterPageLoadCallback = (
                result: OnAfterPageLoadListenerResult
            ) => void;

    interface OnAfterPageUnloadListenerResult {
        /**
         * 页面路径
         */
        path: string;
        /**
         * 路由事件 id
         */
        routeEventId: string;
    }

    /**
     * onAfterPageUnload 传入的监听函数。不传此参数则移除所有监听函数。
     */
    type OffAfterPageUnloadCallback = (
                result: OnAfterPageUnloadListenerResult
            ) => void;

    interface OnApiCategoryChangeListenerResult {
        /**
         * API 类别
         *
         * 可选值：
         * - 'default': 默认类别;
         * - 'nativeFunctionalized': 原生功能化，视频号直播商品、商品橱窗等场景打开的小程序;
         * - 'browseOnly': 仅浏览，朋友圈快照页等场景打开的小程序;
         * - 'embedded': 内嵌，通过打开半屏小程序能力打开的小程序;
         * - 'chatTool': 聊天工具打开小程序;
         */
        apiCategory: "default" | "nativeFunctionalized" | "browseOnly" | "embedded" | "chatTool";
    }

    /**
     * onApiCategoryChange 传入的监听函数。不传此参数则移除所有监听函数。
     */
    type OffApiCategoryChangeCallback = (
                result: OnApiCategoryChangeListenerResult
            ) => void;
    /**
     * onAppHide 传入的监听函数。不传此参数则移除所有监听函数。
     */
    type OffAppHideCallback = (res: GeneralCallbackResult) => void;

    interface OnAppRouteListenerResult {
        /**
         * 是否未找到页面
         */
        notFound: boolean;
        /**
         * 路由打开类型
         */
        openType: string;
        /**
         * 当前打开页面的相关配置
         */
        page: any;
        /**
         * 页面路径
         */
        path: string;
        /**
         * 可选值：
         * - 'min': 视频页面缩小为小窗;
         * - 'max': 视频小窗还原为页面;
         */
        pipMode: "min" | "max";
        /**
         * 路由参数
         */
        query: any;
        /**
         * 渲染引擎
         *
         * 可选值：
         * - 'webview': Webview 渲染引擎;
         * - 'skyline': Skyline 渲染引擎;
         * - 'xr-frame': xr-frame 解决方案;
         */
        renderer: "webview" | "skyline" | "xr-frame";
        /**
         * 路由事件 id
         */
        routeEventId: string;
        /**
         * 路由下发的时间戳
         */
        timeStamp: number;
        /**
         * 当前页面 id
         */
        webviewId: number;
    }

    /**
     * onAppRoute 传入的监听函数。不传此参数则移除所有监听函数。
     */
    type OffAppRouteCallback = (result: OnAppRouteListenerResult) => void;

    interface OnAppRouteDoneListenerResult {
        /**
         * 路由打开类型
         */
        openType: string;
        /**
         * 页面路径
         */
        path: string;
        /**
         * 路由参数
         */
        query: any;
        /**
         * 路由事件 id
         */
        routeEventId: string;
        /**
         * 路由下发的时间戳
         */
        timeStamp: number;
        /**
         * 当前页面 id
         */
        webviewId: number;
    }

    /**
     * onAppRouteDone 传入的监听函数。不传此参数则移除所有监听函数。
     */
    type OffAppRouteDoneCallback = (
                result: OnAppRouteDoneListenerResult
            ) => void;
    /**
     * onAppShow 传入的监听函数。不传此参数则移除所有监听函数。
     */
    type OffAppShowCallback = (res: GeneralCallbackResult) => void;
    /**
     * onAudioInterruptionBegin 传入的监听函数。不传此参数则移除所有监听函数。
     */
    type OffAudioInterruptionBeginCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * onAudioInterruptionEnd 传入的监听函数。不传此参数则移除所有监听函数。
     */
    type OffAudioInterruptionEndCallback = (res: GeneralCallbackResult) => void;

    interface OnBLEConnectionStateChangeListenerResult {
        /**
         * 是否处于已连接状态
         */
        connected: boolean;
        /**
         * 蓝牙设备 id
         */
        deviceId: string;
    }

    /**
     * onBLEConnectionStateChange 传入的监听函数。不传此参数则移除所有监听函数。
     */
    type OffBLEConnectionStateChangeCallback = (
                result: OnBLEConnectionStateChangeListenerResult
            ) => void;

    interface OnBLEMTUChangeListenerResult {
        /**
         * 蓝牙设备 id
         */
        deviceId: string;
        /**
         * 最大传输单元
         */
        mtu: number;
    }

    /**
     * onBLEMTUChange 传入的监听函数。不传此参数则移除所有监听函数。
     */
    type OffBLEMTUChangeCallback = (
                result: OnBLEMTUChangeListenerResult
            ) => void;

    interface OnBLEPeripheralConnectionStateChangedListenerResult {
        /**
         * 连接目前状态
         */
        connected: boolean;
        /**
         * 连接状态变化的设备 id
         */
        deviceId: string;
        /**
         * server 的 UUID
         */
        serverId: string;
    }

    /**
     * onBLEPeripheralConnectionStateChanged 传入的监听函数。不传此参数则移除所有监听函数。
     */
    type OffBLEPeripheralConnectionStateChangedCallback = (
                result: OnBLEPeripheralConnectionStateChangedListenerResult
            ) => void;

    interface OnBatteryInfoChangeListenerResult {
        /**
         * 是否处于省电模式
         */
        isLowPowerModeEnabled: boolean;
    }

    /**
     * onBatteryInfoChange 传入的监听函数。不传此参数则移除所有监听函数。
     */
    type OffBatteryInfoChangeCallback = (
                result: OnBatteryInfoChangeListenerResult
            ) => void;

    interface OnBeforeAppRouteListenerResult {
        /**
         * 是否未找到页面
         */
        notFound: boolean;
        /**
         * 路由打开类型
         */
        openType: string;
        /**
         * 当前打开页面的相关配置
         */
        page: any;
        /**
         * 页面路径
         */
        path: string;
        /**
         * 可选值：
         * - 'min': 视频页面缩小为小窗;
         * - 'max': 视频小窗还原为页面;
         */
        pipMode: "min" | "max";
        /**
         * 路由参数
         */
        query: any;
        /**
         * 渲染引擎
         *
         * 可选值：
         * - 'webview': Webview 渲染引擎;
         * - 'skyline': Skyline 渲染引擎;
         * - 'xr-frame': xr-frame 解决方案;
         */
        renderer: "webview" | "skyline" | "xr-frame";
        /**
         * 路由事件 id
         */
        routeEventId: string;
        /**
         * 当前页面 id
         */
        webviewId: number;
    }

    /**
     * onBeforeAppRoute 传入的监听函数。不传此参数则移除所有监听函数。
     */
    type OffBeforeAppRouteCallback = (
                result: OnBeforeAppRouteListenerResult
            ) => void;

    interface OnBeforePageLoadListenerResult {
        /**
         * 组件框架
         *
         * 可选值：
         * - 'exparser': 旧版小程序组件框架;
         * - 'glass-easel': 新版小程序组件框架;
         */
        componentFramework: "exparser" | "glass-easel";
        /**
         * 路由打开类型
         */
        openType: string;
        /**
         * 页面路径
         */
        path: string;
        /**
         * 路由参数
         */
        query: any;
        /**
         * 路由事件 id
         */
        routeEventId: string;
    }

    /**
     * onBeforePageLoad 传入的监听函数。不传此参数则移除所有监听函数。
     */
    type OffBeforePageLoadCallback = (
                result: OnBeforePageLoadListenerResult
            ) => void;

    interface OnBeforePageUnloadListenerResult {
        /**
         * 页面实例
         */
        page: any;
        /**
         * 页面路径
         */
        path: string;
        /**
         * 路由事件 id
         */
        routeEventId: string;
    }

    /**
     * onBeforePageUnload 传入的监听函数。不传此参数则移除所有监听函数。
     */
    type OffBeforePageUnloadCallback = (
                result: OnBeforePageUnloadListenerResult
            ) => void;
    /**
     * onDeviceMotionChange 传入的监听函数。不传此参数则移除所有监听函数。
     */
    type OffDeviceMotionChangeCallback = (res: GeneralCallbackResult) => void;

    interface OnEmbeddedMiniProgramHeightChangeListenerResult {
        /**
         * 可视高度
         */
        height: number;
        /**
         * 半屏小程序初始高度
         */
        initialHeight: number;
    }

    /**
     * onEmbeddedMiniProgramHeightChange 传入的监听函数。不传此参数则移除所有监听函数。
     */
    type OffEmbeddedMiniProgramHeightChangeCallback = (
                result: OnEmbeddedMiniProgramHeightChangeListenerResult
            ) => void;
    /**
     * onGyroscopeChange 传入的监听函数。不传此参数则移除所有监听函数。
     */
    type OffGyroscopeChangeCallback = (res: GeneralCallbackResult) => void;

    interface OnHCEMessageListenerResult {
        /**
         * `messageType=1` 时 ,客户端接收到 NFC 设备的指令
         */
        data: ArrayBuffer;
        /**
         * 消息类型
         *
         * 可选值：
         * - 1: HCE APDU Command类型，小程序需对此指令进行处理，并调用 sendHCEMessage 接口返回处理指令;
         * - 2: 设备离场事件类型;
         */
        messageType: 1 | 2;
        /**
         * `messageType=2` 时，原因
         */
        reason: number;
    }

    /**
     * onHCEMessage 传入的监听函数。不传此参数则移除所有监听函数。
     */
    type OffHCEMessageCallback = (result: OnHCEMessageListenerResult) => void;

    interface OnKeyDownListenerResult {
        /**
         * 当前是否同时按下了 altKey，同 Web 规范 KeyEvent altKey 属性
         */
        altKey: string;
        /**
         * 按键 code，同 Web 规范 KeyEvent code 属性
         */
        code: string;
        /**
         * 按键名称，同 Web 规范 KeyEvent key 属性
         */
        key: string;
        /**
         * 当前是否同时按下了 shiftKey，同 Web 规范 KeyEvent shiftKey 属性
         */
        shiftKey: string;
        /**
         * 事件触发时的时间戳
         */
        timeStamp: number;
    }

    /**
     * onKeyDown 传入的监听函数。不传此参数则移除所有监听函数。
     */
    type OffKeyDownCallback = (result: OnKeyDownListenerResult) => void;
    /**
     * onKeyUp 传入的监听函数。不传此参数则移除所有监听函数。
     */
    type OffKeyUpCallback = (result: OnKeyDownListenerResult) => void;

    interface OnLazyLoadErrorListenerResult {
        /**
         * 详细信息
         */
        errMsg: string;
        /**
         * 异步组件所属的分包
         */
        subpackage: any[];
        /**
         * 'subpackage' 失败类型
         */
        type: string;
    }

    /**
     * onLazyLoadError 传入的监听函数。不传此参数则移除所有监听函数。
     */
    type OffLazyLoadErrorCallback = (
                result: OnLazyLoadErrorListenerResult
            ) => void;
    /**
     * onLocalServiceDiscoveryStop 传入的监听函数。不传此参数则移除所有监听函数。
     */
    type OffLocalServiceDiscoveryStopCallback = (
                res: GeneralCallbackResult
            ) => void;

    interface OnLocalServiceFoundListenerResult {
        /**
         * 服务的 ip 地址
         */
        ip: string;
        /**
         * 服务的端口
         */
        port: number;
        /**
         * 服务的名称
         */
        serviceName: string;
        /**
         * 服务的类型
         */
        serviceType: string;
    }

    /**
     * onLocalServiceFound 传入的监听函数。不传此参数则移除所有监听函数。
     */
    type OffLocalServiceFoundCallback = (
                result: OnLocalServiceFoundListenerResult
            ) => void;

    interface OnLocalServiceLostListenerResult {
        /**
         * 服务的名称
         */
        serviceName: string;
        /**
         * 服务的类型
         */
        serviceType: string;
    }

    /**
     * onLocalServiceLost 传入的监听函数。不传此参数则移除所有监听函数。
     */
    type OffLocalServiceLostCallback = (
                result: OnLocalServiceLostListenerResult
            ) => void;
    /**
     * onLocalServiceResolveFail 传入的监听函数。不传此参数则移除所有监听函数。
     */
    type OffLocalServiceResolveFailCallback = (
                result: OnLocalServiceLostListenerResult
            ) => void;

    interface OnMenuButtonBoundingClientRectWeightChangeListenerResult {
        /**
         * 下边界坐标，单位：px
         */
        bottom: number;
        /**
         * 高度，单位：px
         */
        height: number;
        /**
         * 左边界坐标，单位：px
         */
        left: number;
        /**
         * 右边界坐标，单位：px
         */
        right: number;
        /**
         * 上边界坐标，单位：px
         */
        top: number;
        /**
         * 宽度，单位：px
         */
        width: number;
    }

    /**
     * onMenuButtonBoundingClientRectWeightChange 传入的监听函数。不传此参数则移除所有监听函数。
     */
    type OffMenuButtonBoundingClientRectWeightChangeCallback = (
                result: OnMenuButtonBoundingClientRectWeightChangeListenerResult
            ) => void;

    interface OnNetworkWeakChangeListenerResult {
        /**
         * 当前网络类型
         */
        networkType: string;
        /**
         * 当前是否处于弱网状态
         */
        weakNet: boolean;
    }

    /**
     * onNetworkWeakChange 传入的监听函数。不传此参数则移除所有监听函数。
     */
    type OffNetworkWeakChangeCallback = (
                result: OnNetworkWeakChangeListenerResult
            ) => void;

    interface OnOnUserTriggerTranslationListenerResult {
        /**
         * 翻译到的目标语言
         */
        locale: string;
        /**
         * 触发来源， `button` 表示点击了菜单中的翻译按钮， `capsule` 表示点击了胶囊中的翻译提示
         */
        type: string;
    }

    /**
     * onOnUserTriggerTranslation 传入的监听函数。不传此参数则移除所有监听函数。
     */
    type OffOnUserTriggerTranslationCallback = (
                result: OnOnUserTriggerTranslationListenerResult
            ) => void;

    interface OnPageNotFoundListenerResult {
        /**
         * 是否本次启动的首个页面（例如从分享等入口进来，首个页面是开发者配置的分享页面）
         */
        isEntryPage: boolean;
        /**
         * 不存在页面的路径 (代码包路径)
         */
        path: string;
        /**
         * 打开不存在页面的 query 参数
         */
        query: Record<string, string>;
    }

    /**
     * onPageNotFound 传入的监听函数。不传此参数则移除所有监听函数。
     */
    type OffPageNotFoundCallback = (
                result: OnPageNotFoundListenerResult
            ) => void;

    interface OnScreenRecordingStateChangedListenerResult {
        /**
         * 录屏状态
         *
         * 可选值：
         * - 'start': 开始录屏;
         * - 'stop': 结束录屏;
         */
        state: "start" | "stop";
    }

    /**
     * onScreenRecordingStateChanged 传入的监听函数。不传此参数则移除所有监听函数。
     */
    type OffScreenRecordingStateChangedCallback = (
                result: OnScreenRecordingStateChangedListenerResult
            ) => void;

    interface OnVoIPChatInterruptedListenerResult {
        /**
         * 错误码
         */
        errCode: number;
        /**
         * 调用结果（错误原因）
         */
        errMsg: string;
    }

    /**
     * onVoIPChatInterrupted 传入的监听函数。不传此参数则移除所有监听函数。
     */
    type OffVoIPChatInterruptedCallback = (
                result: OnVoIPChatInterruptedListenerResult
            ) => void;

    interface OnVoIPChatMembersChangedListenerResult {
        /**
         * 错误码
         */
        errCode: number;
        /**
         * 调用结果
         */
        errMsg: string;
        /**
         * 还在实时语音通话中的成员 openId 名单
         */
        openIdList: string[];
    }

    /**
     * onVoIPChatMembersChanged 传入的监听函数。不传此参数则移除所有监听函数。
     */
    type OffVoIPChatMembersChangedCallback = (
                result: OnVoIPChatMembersChangedListenerResult
            ) => void;

    interface OnVoIPChatSpeakersChangedListenerResult {
        /**
         * 错误码
         */
        errCode: number;
        /**
         * 调用结果（错误原因）
         */
        errMsg: string;
        /**
         * 还在实时语音通话中的成员 openId 名单
         */
        openIdList: string[];
    }

    /**
     * onVoIPChatSpeakersChanged 传入的监听函数。不传此参数则移除所有监听函数。
     */
    type OffVoIPChatSpeakersChangedCallback = (
                result: OnVoIPChatSpeakersChangedListenerResult
            ) => void;

    interface OnVoIPChatStateChangedListenerResult {
        /**
         * 事件码
         */
        code: number;
        /**
         * 附加信息
         */
        data: any;
        /**
         * 错误码
         */
        errCode: number;
        /**
         * 调用结果
         */
        errMsg: string;
    }

    /**
     * onVoIPChatStateChanged 传入的监听函数。不传此参数则移除所有监听函数。
     */
    type OffVoIPChatStateChangedCallback = (
                result: OnVoIPChatStateChangedListenerResult
            ) => void;

    interface OnVoIPVideoMembersChangedListenerResult {
        /**
         * 错误码
         */
        errCode: number;
        /**
         * 调用结果
         */
        errMsg: string;
        /**
         * 开启视频的成员名单
         */
        openIdList: string[];
    }

    /**
     * onVoIPVideoMembersChanged 传入的监听函数。不传此参数则移除所有监听函数。
     */
    type OffVoIPVideoMembersChangedCallback = (
                result: OnVoIPVideoMembersChangedListenerResult
            ) => void;
    /**
     * 路由事件的监听函数
     */
    type OnAfterPageLoadCallback = (
                result: OnAfterPageLoadListenerResult
            ) => void;
    /**
     * 路由事件的监听函数
     */
    type OnAfterPageUnloadCallback = (
                result: OnAfterPageUnloadListenerResult
            ) => void;
    /**
     * API 类别变化事件的监听函数
     */
    type OnApiCategoryChangeCallback = (
                result: OnApiCategoryChangeListenerResult
            ) => void;

    /**
     * 切后台参数
     */
    interface HideOptionsApp {
        /**
         * 需要基础库： `3.5.7`
         *
         * 原因
         *
         * 可选值：
         * - 0: 用户退出小程序;
         * - 1: 进入其他小程序;
         * - 2: 打开原生功能页;
         * - 3: 其他;
         */
        reason?: 0 | 1 | 2 | 3;
    }

    /**
     * 小程序切后台事件的监听函数
     */
    type OnAppHideCallback = (
                /** 切后台参数 */
                options: HideOptionsApp
            ) => void;
    /**
     * 路由事件的监听函数
     */
    type OnAppRouteCallback = (result: OnAppRouteListenerResult) => void;
    /**
     * 当前路由动画执行完成的事件的监听函数
     */
    type OnAppRouteDoneCallback = (result: OnAppRouteDoneListenerResult) => void;

    /**
     * 打开的文件信息数组，只有从聊天素材场景打开（scene为1173）才会携带该参数
     */
    interface ForwardMaterials {
        /**
         * 文件名
         */
        name: string;
        /**
         * 文件路径（如果是webview则是url）
         */
        path: string;
        /**
         * 文件大小
         */
        size: number;
        /**
         * 文件的mimetype类型
         */
        type: string;
    }

    /**
     * 启动参数
     */
    interface LaunchOptionsApp {
        /**
         * 需要基础库： `2.20.0`
         *
         * API 类别
         *
         * 可选值：
         * - 'default': 默认类别;
         * - 'nativeFunctionalized': 原生功能化，视频号直播商品、商品橱窗等场景打开的小程序;
         * - 'browseOnly': 仅浏览，朋友圈快照页等场景打开的小程序;
         * - 'embedded': 内嵌，通过打开半屏小程序能力打开的小程序;
         * - 'chatTool': 聊天工具，通过打开聊天工具能力打开的小程序;
         */
        apiCategory: "default" | "nativeFunctionalized" | "browseOnly" | "embedded" | "chatTool";
        /**
         * 打开的文件信息数组，只有从聊天素材场景打开（scene为1173）才会携带该参数
         */
        forwardMaterials: ForwardMaterials[];
        /**
         * 启动小程序的路径 (代码包路径)
         */
        path: string;
        /**
         * 启动小程序的 query 参数
         */
        query: Record<string, string>;
        /**
         * 来源信息。从另一个小程序、公众号或 App 进入小程序时返回。否则返回 `{}`。(参见后文注意)
         */
        referrerInfo: ReferrerInfo;
        /**
         * 启动小程序的[场景值](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/scene.html)
         */
        scene: number;
        /**
         * 从微信群聊/单聊打开小程序时，chatType 表示具体微信群聊/单聊类型
         *
         * 可选值：
         * - 1: 微信联系人单聊;
         * - 2: 企业微信联系人单聊;
         * - 3: 普通微信群聊;
         * - 4: 企业微信互通群聊;
         */
        chatType?: 1 | 2 | 3 | 4;
        /**
         * shareTicket，详见[获取更多转发信息](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/share.html#获取更多转发信息)
         */
        shareTicket?: string;
    }

    /**
     * 小程序切前台事件的监听函数
     */
    type OnAppShowCallback = (
                /** 启动参数 */
                options: LaunchOptionsApp
            ) => void;
    /**
     * 音频因为受到系统占用而被中断开始事件的监听函数
     */
    type OnAudioInterruptionBeginCallback = (res: GeneralCallbackResult) => void;
    /**
     * 音频中断结束事件的监听函数
     */
    type OnAudioInterruptionEndCallback = (res: GeneralCallbackResult) => void;
    /**
     * 蓝牙低功耗的最大传输单元变化事件的监听函数
     */
    type OnBLEMTUChangeCallback = (result: OnBLEMTUChangeListenerResult) => void;
    /**
     * 当前外围设备被连接或断开连接事件的监听函数
     */
    type OnBLEPeripheralConnectionStateChangedCallback = (
                result: OnBLEPeripheralConnectionStateChangedListenerResult
            ) => void;
    /**
     * 音乐暂停事件的监听函数
     */
    type OnBackgroundAudioPauseCallback = (res: GeneralCallbackResult) => void;
    /**
     * 音乐播放事件的监听函数
     */
    type OnBackgroundAudioPlayCallback = (res: GeneralCallbackResult) => void;
    /**
     * 音乐停止事件的监听函数
     */
    type OnBackgroundAudioStopCallback = (res: GeneralCallbackResult) => void;

    interface OnBackgroundFetchDataListenerResult {
        /**
         * 缓存数据类别，取值为 periodic 或 pre
         */
        fetchType: string;
        /**
         * 缓存数据
         */
        fetchedData: string;
        /**
         * 小程序页面路径
         */
        path: string;
        /**
         * 传给页面的 query 参数
         */
        query: string;
        /**
         * 进入小程序的场景值
         */
        scene: number;
        /**
         * 客户端拿到缓存数据的时间戳
         */
        timeStamp: number;
    }

    /**
     * 收到 backgroundFetch 数据事件的监听函数
     */
    type OnBackgroundFetchDataCallback = (
                result: OnBackgroundFetchDataListenerResult
            ) => void;
    /**
     * 电池信息变化事件的监听函数
     */
    type OnBatteryInfoChangeCallback = (
                result: OnBatteryInfoChangeListenerResult
            ) => void;
    /**
     * 路由事件的监听函数
     */
    type OnBeforeAppRouteCallback = (
                result: OnBeforeAppRouteListenerResult
            ) => void;
    /**
     * 路由事件的监听函数
     */
    type OnBeforePageLoadCallback = (
                result: OnBeforePageLoadListenerResult
            ) => void;
    /**
     * 路由事件的监听函数
     */
    type OnBeforePageUnloadCallback = (
                result: OnBeforePageUnloadListenerResult
            ) => void;

    interface OnCopyUrlListenerResult {
        /**
         * 用短链打开小程序时当前页面携带的查询字符串。小程序中使用时，应在进入页面时调用 `wx.onCopyUrl` 自定义 `query`，退出页面时调用 `wx.offCopyUrl`，防止影响其它页面。
         */
        query: string;
    }

    /**
     * 用户点击右上角菜单的「复制链接」按钮时触发的事件的监听函数
     */
    type OnCopyUrlCallback = (result: OnCopyUrlListenerResult) => void;

    interface OnDeviceMotionChangeListenerResult {
        /**
         * 当 手机坐标 X/Y 和 地球 X/Y 重合时，绕着 Z 轴转动的夹角为 alpha，范围值为 [0, 2*PI)。逆时针转动为正。
         */
        alpha: number;
        /**
         * 当手机坐标 Y/Z 和地球 Y/Z 重合时，绕着 X 轴转动的夹角为 beta。范围值为 [-1*PI, PI) 。顶部朝着地球表面转动为正。也有可能朝着用户为正。
         */
        beta: number;
        /**
         * 当手机 X/Z 和地球 X/Z 重合时，绕着 Y 轴转动的夹角为 gamma。范围值为 [-1*PI/2, PI/2)。右边朝着地球表面转动为正。
         */
        gamma: number;
    }

    /**
     * 设备方向变化事件的监听函数
     */
    type OnDeviceMotionChangeCallback = (
                result: OnDeviceMotionChangeListenerResult
            ) => void;
    /**
     * 半屏小程序可视高度变化事件的监听函数
     */
    type OnEmbeddedMiniProgramHeightChangeCallback = (
                result: OnEmbeddedMiniProgramHeightChangeListenerResult
            ) => void;
    /**
     * 接收 NFC 设备消息事件的监听函数
     */
    type OnHCEMessageCallback = (result: OnHCEMessageListenerResult) => void;
    /**
     * 小程序全局键盘按键按下事件的监听函数
     */
    type OnKeyDownCallback = (result: OnKeyDownListenerResult) => void;
    /**
     * 小程序全局键盘按键弹起事件的监听函数
     */
    type OnKeyUpCallback = (result: OnKeyDownListenerResult) => void;
    /**
     * 小程序异步组件加载失败事件的监听函数
     */
    type OnLazyLoadErrorCallback = (
                result: OnLazyLoadErrorListenerResult
            ) => void;
    /**
     * mDNS 服务停止搜索的事件的监听函数
     */
    type OnLocalServiceDiscoveryStopCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * mDNS 服务发现的事件的监听函数
     */
    type OnLocalServiceFoundCallback = (
                result: OnLocalServiceFoundListenerResult
            ) => void;
    /**
     * mDNS 服务离开的事件的监听函数
     */
    type OnLocalServiceLostCallback = (
                result: OnLocalServiceLostListenerResult
            ) => void;
    /**
     * mDNS 服务解析失败的事件的监听函数
     */
    type OnLocalServiceResolveFailCallback = (
                result: OnLocalServiceLostListenerResult
            ) => void;
    /**
     * 菜单按钮（右上角胶囊按钮）的布局位置信息变化事件的监听函数
     */
    type OnMenuButtonBoundingClientRectWeightChangeCallback = (
                result: OnMenuButtonBoundingClientRectWeightChangeListenerResult
            ) => void;
    /**
     * 隐私接口需要用户授权事件的监听函数
     */
    type OnNeedPrivacyAuthorizationCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 弱网状态变化事件的监听函数
     */
    type OnNetworkWeakChangeCallback = (
                result: OnNetworkWeakChangeListenerResult
            ) => void;
    /**
     * 用户触发小程序菜单中翻译功能的事件的监听函数
     */
    type OnOnUserTriggerTranslationCallback = (
                result: OnOnUserTriggerTranslationListenerResult
            ) => void;
    /**
     * 小程序要打开的页面不存在事件的监听函数
     */
    type OnPageNotFoundCallback = (result: OnPageNotFoundListenerResult) => void;
    /**
     * 用户录屏事件的监听函数
     */
    type OnScreenRecordingStateChangedCallback = (
                result: OnScreenRecordingStateChangedListenerResult
            ) => void;
    /**
     * 被动断开实时语音通话事件的监听函数
     */
    type OnVoIPChatInterruptedCallback = (
                result: OnVoIPChatInterruptedListenerResult
            ) => void;
    /**
     * 实时语音通话成员在线状态变化事件的监听函数
     */
    type OnVoIPChatMembersChangedCallback = (
                result: OnVoIPChatMembersChangedListenerResult
            ) => void;
    /**
     * 实时语音通话成员通话状态变化事件的监听函数
     */
    type OnVoIPChatSpeakersChangedCallback = (
                result: OnVoIPChatSpeakersChangedListenerResult
            ) => void;
    /**
     * 房间状态变化事件的监听函数
     */
    type OnVoIPChatStateChangedCallback = (
                result: OnVoIPChatStateChangedListenerResult
            ) => void;
    /**
     * 实时语音通话成员视频状态变化事件的监听函数
     */
    type OnVoIPVideoMembersChangedCallback = (
                result: OnVoIPVideoMembersChangedListenerResult
            ) => void;

    /**
     * 需要打开的卡券列表
     */
    interface OpenCardRequestInfo {
        /**
         * 卡券 ID
         */
        cardId: string;
        /**
         * 由 [uni.addCard](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/card/wx.addCard.html) 的返回对象中的加密 code 通过解密后得到，解密请参照：[code 解码接口](https://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1499332673_Unm7V)
         */
        code: string;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type OpenCardCompleteCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用失败的回调函数
     */
    type OpenCardFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type OpenCardSuccessCallback = (res: GeneralCallbackResult) => void;

    interface OpenCardOption {
        /**
         * 需要打开的卡券列表
         */
        cardList: OpenCardRequestInfo[];
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: OpenCardCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: OpenCardFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: OpenCardSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type OpenChannelsActivityCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type OpenChannelsActivityFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type OpenChannelsActivitySuccessCallback = (
                res: GeneralCallbackResult
            ) => void;

    interface OpenChannelsActivityOption {
        /**
         * 视频 feedId
         */
        feedId: string;
        /**
         * 视频号 id，以“sph”开头的id，可在视频号助手获取
         */
        finderUserName: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: OpenChannelsActivityCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: OpenChannelsActivityFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: OpenChannelsActivitySuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type OpenChannelsEventCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type OpenChannelsEventFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type OpenChannelsEventSuccessCallback = (res: GeneralCallbackResult) => void;

    interface OpenChannelsEventOption {
        /**
         * 活动 id
         */
        eventId: string;
        /**
         * 视频号 id，以“sph”开头的id，可在视频号助手获取
         */
        finderUserName: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: OpenChannelsEventCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: OpenChannelsEventFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: OpenChannelsEventSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type OpenChannelsLiveCompleteCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用失败的回调函数
     */
    type OpenChannelsLiveFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type OpenChannelsLiveSuccessCallback = (res: GeneralCallbackResult) => void;

    interface OpenChannelsLiveOption {
        /**
         * 视频号 id，以“sph”开头的id，可在视频号助手获取
         */
        finderUserName: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: OpenChannelsLiveCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: OpenChannelsLiveFailCallback;
        /**
         * 直播 feedId，通过 getChannelsLiveInfo 接口获取（基础库 v2.19.2 之前的版本需要填写）
         */
        feedId?: string;
        /**
         * 直播 nonceId，通过 getChannelsLiveInfo 接口获取（基础库 v2.19.2 之前的版本需要填写）
         */
        nonceId?: string;
        /**
         * 接口调用成功的回调函数
         */
        success?: OpenChannelsLiveSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type OpenChannelsUserProfileCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type OpenChannelsUserProfileFailCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用成功的回调函数
     */
    type OpenChannelsUserProfileSuccessCallback = (
                res: GeneralCallbackResult
            ) => void;

    interface OpenChannelsUserProfileOption {
        /**
         * 视频号 id
         */
        finderUserName: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: OpenChannelsUserProfileCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: OpenChannelsUserProfileFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: OpenChannelsUserProfileSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type OpenChatToolCompleteCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用失败的回调函数
     */
    type OpenChatToolFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type OpenChatToolSuccessCallback = (res: GeneralCallbackResult) => void;

    interface OpenChatToolOption {
        /**
         * 聊天工具分包内的页面路径
         */
        url: string;
        /**
         * 群聊类型
         *
         * 可选值：
         * - 1: 微信联系人单聊;
         * - 2: 企业微信联系人单聊;
         * - 3: 普通微信群聊;
         * - 4: 企业微信互通群聊;
         */
        chatType?: 1 | 2 | 3 | 4;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: OpenChatToolCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: OpenChatToolFailCallback;
        /**
         * 聊天室 id，不传则拉起群选择框，可以传入多聊群的 opengid 值，或者单聊群的 open_single_roomid 值
         */
        roomid?: string;
        /**
         * 接口调用成功的回调函数
         */
        success?: OpenChatToolSuccessCallback;
    }

    /**
     * 客服信息
     */
    interface ExtInfoOption {
        /**
         * 客服链接
         */
        url: string;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type OpenCustomerServiceChatCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type OpenCustomerServiceChatFailCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用成功的回调函数
     */
    type OpenCustomerServiceChatSuccessCallback = (
                res: GeneralCallbackResult
            ) => void;

    interface OpenCustomerServiceChatOption {
        /**
         * 企业ID
         */
        corpId: string;
        /**
         * 客服信息
         */
        extInfo: ExtInfoOption;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: OpenCustomerServiceChatCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: OpenCustomerServiceChatFailCallback;
        /**
         * 气泡消息图片
         */
        sendMessageImg?: string;
        /**
         * 气泡消息小程序路径
         */
        sendMessagePath?: string;
        /**
         * 气泡消息标题
         */
        sendMessageTitle?: string;
        /**
         * 是否发送小程序气泡消息
         */
        showMessageCard?: boolean;
        /**
         * 接口调用成功的回调函数
         */
        success?: OpenCustomerServiceChatSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type OpenEmbeddedMiniProgramCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type OpenEmbeddedMiniProgramFailCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用成功的回调函数
     */
    type OpenEmbeddedMiniProgramSuccessCallback = (
                res: GeneralCallbackResult
            ) => void;

    interface OpenEmbeddedMiniProgramOption {
        /**
         * 要打开的小程序 appId
         */
        appId: string;
        /**
         * 需要基础库： `2.33.0`
         *
         * 打开的小程序是否支持全屏
         */
        allowFullScreen?: boolean;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: OpenEmbeddedMiniProgramCompleteCallback;
        /**
         * 要打开的小程序版本。仅在当前小程序为开发版或体验版时此参数有效。如果当前小程序是正式版，则打开的小程序必定是正式版。
         *
         * 可选值：
         * - 'develop': 开发版;
         * - 'trial': 体验版;
         * - 'release': 正式版;
         */
        envVersion?: "develop" | "trial" | "release";
        /**
         * 需要传递给目标小程序的数据，目标小程序可在 `App.onLaunch`，`App.onShow` 中获取到这份数据。如果跳转的是小游戏，可以在 [uni.onShow](#)、[uni.getLaunchOptionsSync](https://developers.weixin.qq.com/miniprogram/dev/api/base/app/life-cycle/wx.getLaunchOptionsSync.html) 中可以获取到这份数据数据。
         */
        extraData?: any;
        /**
         * 接口调用失败的回调函数
         */
        fail?: OpenEmbeddedMiniProgramFailCallback;
        /**
         * 需要基础库： `2.24.0`
         *
         * 不reLaunch目标小程序，直接打开目标跳转的小程序退后台时的页面，需满足以下条件：1. 目标跳转的小程序生命周期未被销毁；2. 且目标当次启动的path、query与上次启动相同，apiCategory以wx.getApiCategory接口的返回结果为准。
         */
        noRelaunchIfPathUnchanged?: boolean;
        /**
         * 打开的页面路径，如果为空则打开首页。path 中 ? 后面的部分会成为 query，在小程序的 `App.onLaunch`、`App.onShow` 和 `Page.onLoad` 的回调函数或小游戏的 [uni.onShow](#) 回调函数、[uni.getLaunchOptionsSync](https://developers.weixin.qq.com/miniprogram/dev/api/base/app/life-cycle/wx.getLaunchOptionsSync.html) 中可以获取到 query 数据。对于小游戏，可以只传入 query 部分，来实现传参效果，如：传入 "?foo=bar"。
         */
        path?: string;
        /**
         * 小程序链接，当传递该参数后，可以不传 appId 和 path。链接可以通过【小程序菜单】->【复制链接】获取。仅 verify=binding 支持。
         */
        shortLink?: string;
        /**
         * 接口调用成功的回调函数
         */
        success?: OpenEmbeddedMiniProgramSuccessCallback;
        /**
         * 需要基础库： `2.24.3`
         *
         * 校验方式。
         *
         * 可选值：
         * - 'binding': 校验小程序管理后台的绑定关系。;
         * - 'unionProduct': 校验目标打开链接是否为[小程序联盟](https://developers.weixin.qq.com/doc/ministore/union/brief-introduction.html)商品。;
         */
        verify?: "binding" | "unionProduct";
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type OpenHKOfflinePayViewCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type OpenHKOfflinePayViewFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type OpenHKOfflinePayViewSuccessCallback = (
                res: GeneralCallbackResult
            ) => void;

    interface OpenHKOfflinePayViewOption {
        /**
         * 随机字符串，长度为32个字符以下
         */
        nonceStr: string;
        /**
         * 业务数据包，开发者目前无需感知，直接传空字符串即可
         */
        package: string;
        /**
         * 签名，具体见微信支付文档
         */
        paySign: string;
        /**
         * 时间戳，从 1970 年 1 月 1 日 00:00:00 至今的秒数，即当前的时间
         */
        timeStamp: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: OpenHKOfflinePayViewCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: OpenHKOfflinePayViewFailCallback;
        /**
         * 签名算法，应与后台下单时的值一致，目前仅支持 SHA1
         *
         * 可选值：
         * - 'SHA1': SHA1签名算法;
         */
        signType?: "SHA1";
        /**
         * 接口调用成功的回调函数
         */
        success?: OpenHKOfflinePayViewSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type OpenOfficialAccountArticleCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;

    interface RequestVirtualPaymentFailCallbackErr {
        /**
         * 错误码
         */
        errCode: number;
        /**
         * 错误信息
         */
        errMsg: string;
    }

    /**
     * 接口调用失败的回调函数
     */
    type OpenOfficialAccountArticleFailCallback = (
                err: RequestVirtualPaymentFailCallbackErr
            ) => void;

    interface OpenOfficialAccountArticleSuccessCallbackResult {
        /**
         * 为 true 时，表示用户点击了取消（用于 Android 系统区分点击蒙层关闭还是点击取消按钮关闭）
         */
        cancel: boolean;
        /**
         * 为 true 时，表示用户点击了确定按钮
         */
        confirm: boolean;
        errMsg: string;
    }

    /**
     * 接口调用成功的回调函数
     */
    type OpenOfficialAccountArticleSuccessCallback = (
                result: OpenOfficialAccountArticleSuccessCallbackResult
            ) => void;

    interface OpenOfficialAccountArticleOption {
        /**
         * 需要打开的公众号地址
         */
        url: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: OpenOfficialAccountArticleCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: OpenOfficialAccountArticleFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: OpenOfficialAccountArticleSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type OpenOfficialAccountProfileCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type OpenOfficialAccountProfileFailCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用成功的回调函数
     */
    type OpenOfficialAccountProfileSuccessCallback = (
                res: GeneralCallbackResult
            ) => void;

    interface OpenOfficialAccountProfileOption {
        /**
         * 需要打开的公众号的微信号
         */
        username: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: OpenOfficialAccountProfileCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: OpenOfficialAccountProfileFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: OpenOfficialAccountProfileSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type OpenPrivacyContractCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type OpenPrivacyContractFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type OpenPrivacyContractSuccessCallback = (
                res: GeneralCallbackResult
            ) => void;

    interface OpenPrivacyContractOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: OpenPrivacyContractCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: OpenPrivacyContractFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: OpenPrivacyContractSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type OpenSingleStickerViewCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type OpenSingleStickerViewFailCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用成功的回调函数
     */
    type OpenSingleStickerViewSuccessCallback = (
                res: GeneralCallbackResult
            ) => void;

    interface OpenSingleStickerViewOption {
        /**
         * 表情链接，可前往[表情开放平台](https://sticker.weixin.qq.com/cgi-bin/mmemoticon-bin/loginpage?t=login/index)，在详情页中的「小程序跳转链接」入口复制
         */
        url: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: OpenSingleStickerViewCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: OpenSingleStickerViewFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: OpenSingleStickerViewSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type OpenStickerIPViewCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type OpenStickerIPViewFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type OpenStickerIPViewSuccessCallback = (res: GeneralCallbackResult) => void;

    interface OpenStickerIPViewOption {
        /**
         * 表情IP合辑链接，可前往[表情开放平台](https://sticker.weixin.qq.com/cgi-bin/mmemoticon-bin/loginpage?t=login/index)，在详情页中的「小程序跳转链接」入口复制
         */
        url: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: OpenStickerIPViewCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: OpenStickerIPViewFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: OpenStickerIPViewSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type OpenStickerSetViewCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type OpenStickerSetViewFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type OpenStickerSetViewSuccessCallback = (
                res: GeneralCallbackResult
            ) => void;

    interface OpenStickerSetViewOption {
        /**
         * 表情专辑链接，可前往[表情开放平台](https://sticker.weixin.qq.com/cgi-bin/mmemoticon-bin/loginpage?t=login/index)，在详情页中的「小程序跳转链接」入口复制
         */
        url: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: OpenStickerSetViewCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: OpenStickerSetViewFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: OpenStickerSetViewSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type OpenStoreOrderDetailCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;

    interface OpenStoreOrderDetailFailCallbackResult {
        /**
         * 错误码
         *
         * 可选值：
         * - -1: 系统失败;
         * - 0: 成功;
         * - 1001: 缺少必要参数;
         * - 1002: 网络错误;
         * - 817323001: 合作账号订单id不合法;
         * - 817323002: 无法获取该订单;
         * - 817323003: 当前小程序不是绑定的合作账号;
         */
        code: 0 | -1 | 1001 | 1002 | 817323001 | 817323002 | 817323003;
        /**
         * 错误信息
         */
        message: string;
    }

    /**
     * 接口调用失败的回调函数
     */
    type OpenStoreOrderDetailFailCallback = (
                result: OpenStoreOrderDetailFailCallbackResult
            ) => void;
    /**
     * 接口调用成功的回调函数
     */
    type OpenStoreOrderDetailSuccessCallback = (
                res: GeneralCallbackResult
            ) => void;

    interface OpenStoreOrderDetailOption {
        /**
         * 订单id，通过[回调事件](https://developers.weixin.qq.com/miniprogram/dev/platform-capabilities/business-capabilities/cooperation_shop/order_callback.html#%E4%BA%94%E3%80%81%E5%90%88%E4%BD%9C%E8%B4%A6%E5%8F%B7%E5%BA%97%E9%93%BA%E8%AE%A2%E5%8D%95%E9%80%9A%E7%9F%A5%E4%BA%8B%E4%BB%B6)获取
         */
        orderId: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: OpenStoreOrderDetailCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: OpenStoreOrderDetailFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: OpenStoreOrderDetailSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type OpenSystemBluetoothSettingCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type OpenSystemBluetoothSettingFailCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用成功的回调函数
     */
    type OpenSystemBluetoothSettingSuccessCallback = (
                res: GeneralCallbackResult
            ) => void;

    interface OpenSystemBluetoothSettingOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: OpenSystemBluetoothSettingCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: OpenSystemBluetoothSettingFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: OpenSystemBluetoothSettingSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type PauseBackgroundAudioCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type PauseBackgroundAudioFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type PauseBackgroundAudioSuccessCallback = (
                res: GeneralCallbackResult
            ) => void;

    interface PauseBackgroundAudioOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: PauseBackgroundAudioCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: PauseBackgroundAudioFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: PauseBackgroundAudioSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type PauseVoiceCompleteCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用失败的回调函数
     */
    type PauseVoiceFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type PauseVoiceSuccessCallback = (res: GeneralCallbackResult) => void;

    interface PauseVoiceOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: PauseVoiceCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: PauseVoiceFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: PauseVoiceSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type PlayBackgroundAudioCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type PlayBackgroundAudioFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type PlayBackgroundAudioSuccessCallback = (
                res: GeneralCallbackResult
            ) => void;

    interface PlayBackgroundAudioOption {
        /**
         * 音乐链接，目前支持的格式有 m4a, aac, mp3, wav
         */
        dataUrl: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: PlayBackgroundAudioCompleteCallback;
        /**
         * 封面URL
         */
        coverImgUrl?: string;
        /**
         * 接口调用失败的回调函数
         */
        fail?: PlayBackgroundAudioFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: PlayBackgroundAudioSuccessCallback;
        /**
         * 音乐标题
         */
        title?: string;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type PlayVoiceCompleteCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用失败的回调函数
     */
    type PlayVoiceFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type PlayVoiceSuccessCallback = (res: GeneralCallbackResult) => void;

    interface PlayVoiceOption {
        /**
         * 需要播放的语音文件的文件路径 (本地路径)
         */
        filePath: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: PlayVoiceCompleteCallback;
        /**
         * 需要基础库： `1.6.0`
         *
         * 指定播放时长，到达指定的播放时长后会自动停止播放，单位：秒
         */
        duration?: number;
        /**
         * 接口调用失败的回调函数
         */
        fail?: PlayVoiceFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: PlayVoiceSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type PluginLoginCompleteCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用失败的回调函数
     */
    type PluginLoginFailCallback = (res: GeneralCallbackResult) => void;

    interface PluginLoginSuccessCallbackResult {
        /**
         * 用于换取 openpid 的凭证（有效期五分钟）。插件开发者可以用此 code 在开发者服务器后台调用 [getPluginOpenPId](https://developers.weixin.qq.com/miniprogram/dev/OpenApiDoc/user-info/basic-info/getPluginOpenPId.html) 换取 openpid。
         */
        code: string;
        errMsg: string;
    }

    /**
     * 接口调用成功的回调函数
     */
    type PluginLoginSuccessCallback = (
                result: PluginLoginSuccessCallbackResult
            ) => void;

    interface PluginLoginOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: PluginLoginCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: PluginLoginFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: PluginLoginSuccessCallback;
    }

    interface PostMessageToReferrerMiniProgramOption {
        /**
         * 需要返回的数据
         */
        extraData?: any;
    }

    interface Asset {
        src: string;
        /**
         * 可选值：
         * - 'font': 字体;
         * - 'image': 图片;
         */
        type: "image" | "font";
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type PreloadAssetsCompleteCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用失败的回调函数
     */
    type PreloadAssetsFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type PreloadAssetsSuccessCallback = (res: GeneralCallbackResult) => void;

    interface PreloadAssetsOption {
        data: Asset[];
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: PreloadAssetsCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: PreloadAssetsFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: PreloadAssetsSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type PreloadSkylineViewCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type PreloadSkylineViewFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type PreloadSkylineViewSuccessCallback = (
                res: GeneralCallbackResult
            ) => void;

    interface PreloadSkylineViewOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: PreloadSkylineViewCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: PreloadSkylineViewFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: PreloadSkylineViewSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type PreloadWebviewCompleteCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用失败的回调函数
     */
    type PreloadWebviewFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type PreloadWebviewSuccessCallback = (res: GeneralCallbackResult) => void;

    interface PreloadWebviewOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: PreloadWebviewCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: PreloadWebviewFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: PreloadWebviewSuccessCallback;
    }

    /**
     * 需要预览的资源列表
     */
    interface MediaSource {
        /**
         * 图片或视频的地址
         */
        url: string;
        /**
         * 视频的封面图片
         */
        poster?: string;
        /**
         * 资源的类型，默认为图片
         *
         * 可选值：
         * - 'image': 图片;
         * - 'video': 视频;
         */
        type?: "video" | "image";
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type PreviewMediaCompleteCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用失败的回调函数
     */
    type PreviewMediaFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type PreviewMediaSuccessCallback = (res: GeneralCallbackResult) => void;

    interface PreviewMediaOption {
        /**
         * 需要预览的资源列表
         */
        sources: MediaSource[];
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: PreviewMediaCompleteCallback;
        /**
         * 当前显示的资源序号
         */
        current?: number;
        /**
         * 接口调用失败的回调函数
         */
        fail?: PreviewMediaFailCallback;
        /**
         * 需要基础库： `2.13.0`
         *
         * `origin`: 发送完整的referrer; `no-referrer`: 不发送。格式固定为 `https://servicewechat.com/{appid}/{version}/page-frame.html`，其中 {appid} 为小程序的 appid，{version} 为小程序的版本号，版本号为 0 表示为开发版、体验版以及审核版本，版本号为 devtools 表示为开发者工具，其余为正式版本；
         */
        referrerPolicy?: string;
        /**
         * 需要基础库： `2.13.0`
         *
         * 是否显示长按菜单。
         */
        showmenu?: boolean;
        /**
         * 接口调用成功的回调函数
         */
        success?: PreviewMediaSuccessCallback;
    }

    /**
     * 订单金额信息。
     */
    interface Amount {
        /**
         * 订单总需支付金额，也即是真正下单总金额，单位为分。示例值：1300
         */
        order_amount: number;
        /**
         * 货币类型。示例值：CNY
         *
         * 可选值：
         * - 'CNY': 人民币;
         */
        currency?: "CNY";
        /**
         * 订单总计优惠金额，单位为分。示例值：500
         */
        discount?: number;
        /**
         * 订单运费，单位为分。示例值：200
         */
        freight?: number;
        /**
         * 订单其他费用总金额，单位为分。示例值：600
         */
        other_fee?: number;
        /**
         * 订单所有商品的原价总和，单位为分。示例值：1000
         */
        product_amount?: number;
    }

    /**
     * 订单详细商品信息列表。
     */
    interface ProductInfo {
        /**
         * 商户侧该商品所属的类目。示例值：玩偶
         */
        category: string;
        /**
         * 商品主图的url，大小建议64*64。示例值：https://mp.weixin.qq.com/123
         */
        head_img: string;
        /**
         * 该商品原价，单位为分。示例值：5000
         */
        org_price: number;
        /**
         * 商户商品详请页小程序路径。示例值：pages/index
         */
        path: string;
        /**
         * 用户购买该商品的数量。示例值：5
         */
        quantity: number;
        /**
         * 该商品售价，单位为分。示例值：4000
         */
        sale_price: number;
        /**
         * 商户系统内该商品的sku属性。示例值：50cm
         */
        sku_attr: string;
        /**
         * 商户系统内该商品的skuid。示例值：sku123
         */
        sku_id: string;
        /**
         * 商户系统内该商品的spuid。示例值：spu123456
         */
        spu_id: string;
        /**
         * 商品标题。示例值：QQ长鹅
         */
        title: string;
    }

    /**
     * 具体支付参数见signData, 该参数需以string形式传递, 例如signData: '{"mchid":"1234567890","out_trade_no":"test1244","description":"测试测试","amount":{"order_amount":1,"currency":"CNY"},"attach":"test_attach","env":1}'
     */
    interface RequestCommonPaymentSignData {
        /**
         * 订单金额信息。
         */
        amount: Amount;
        /**
         * 商品描述。示例值：Image形象店-深圳腾大-QQ公仔
         */
        description: string;
        /**
         * 下单环境。示例值：0
         *
         * 可选值：
         * - 0: 生产环境/现网环境;
         * - 1: 沙箱环境/测试环境;
         */
        env: 0 | 1;
        /**
         * 由微信支付生成并下发的商户号。示例值：1230000109
         */
        mchid: string;
        /**
         * 商户系统内部订单号，只能是数字、大小写字母_-*且在同一个商户号下唯一，长度限制为[6,32]。示例值：1217752501201407033233368018
         */
        out_trade_no: string;
        /**
         * 附加数据，在查询API和支付通知中原样返回，可作为自定义参数使用，实际情况下只有支付完成状态才会返回该字段。示例值：test_attach
         */
        attach?: string;
        /**
         * 配送方式。示例值：2
         *
         * 可选值：
         * - 1: 同城配送;
         * - 2: 快递配送;
         * - 3: 门店自提;
         * - 4: 无需配送与提货;
         */
        delivery_type?: 1 | 2 | 3 | 4;
        /**
         * 订单详细商品信息列表。
         */
        product_info?: ProductInfo;
    }

    interface CommonPaymentError {
        /**
         * 错误信息
         *
         * | 错误码 | 错误信息 | 说明 |
         * | - | - | - |
         * | 1000 |  | 系统错误 |
         * | 1022 |  | 参数json格式非法 |
         * | 702001 |  | 参数错误，具体原因见errMsg |
         * | 702002 |  | 用户态签名错误 |
         * | 702003 |  | 支付签名错误 |
         * | 702004 |  | mode不合法 |
         * | 702005 |  | out_trade_no重复，请更换新单号重试 |
         * | 702006 |  | 二级商户进件未完成 |
         * | 702007 |  | 用户未授权给品牌 |
         * | 702008 |  | 正式版小程序只能用生产环境下单 |
         */
        errMsg: string;
        /**
         * 错误码
         *
         * | 错误码 | 错误信息 | 说明 |
         * | - | - | - |
         * | 1000 |  | 系统错误 |
         * | 1022 |  | 参数json格式非法 |
         * | 702001 |  | 参数错误，具体原因见errMsg |
         * | 702002 |  | 用户态签名错误 |
         * | 702003 |  | 支付签名错误 |
         * | 702004 |  | mode不合法 |
         * | 702005 |  | out_trade_no重复，请更换新单号重试 |
         * | 702006 |  | 二级商户进件未完成 |
         * | 702007 |  | 用户未授权给品牌 |
         * | 702008 |  | 正式版小程序只能用生产环境下单 |
         */
        errCode: number;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type RequestCommonPaymentCompleteCallback = (
                res: CommonPaymentError
            ) => void;

    interface RequestCommonPaymentFailCallbackErr {
        /**
         * 错误信息
         */
        errMsg: string;
        /**
         * 错误码
         */
        errno: number;
    }

    /**
     * 接口调用失败的回调函数
     */
    type RequestCommonPaymentFailCallback = (
                err: RequestCommonPaymentFailCallbackErr
            ) => void;

    interface RequestCommonPaymentSuccessCallbackResult {
        /**
         * 调用成功信息
         */
        errMsg: string;
    }

    /**
     * 接口调用成功的回调函数
     */
    type RequestCommonPaymentSuccessCallback = (
                result: RequestCommonPaymentSuccessCallbackResult
            ) => void;

    interface RequestCommonPaymentOption {
        /**
         * 支付的类型
         *
         * 可选值：
         * - 'retail_pay_goods': B2b支付;
         */
        mode: "retail_pay_goods";
        /**
         * 支付签名, 详见[《签名详解》](https://developers.weixin.qq.com/miniprogram/dev/platform-capabilities/industry/virtual-payment.html)
         */
        paySig: string;
        /**
         * 具体支付参数见signData, 该参数需以string形式传递, 例如signData: '{"mchid":"1234567890","out_trade_no":"test1244","description":"测试测试","amount":{"order_amount":1,"currency":"CNY"},"attach":"test_attach","env":1}'
         */
        signData: RequestCommonPaymentSignData;
        /**
         * 用户态签名, 详见[《签名详解》](https://developers.weixin.qq.com/miniprogram/dev/platform-capabilities/industry/virtual-payment.html)
         */
        signature: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: RequestCommonPaymentCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: RequestCommonPaymentFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: RequestCommonPaymentSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type RequestDeviceVoIPCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type RequestDeviceVoIPFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type RequestDeviceVoIPSuccessCallback = (res: GeneralCallbackResult) => void;

    interface RequestDeviceVoIPOption {
        /**
         * 设备名称，将显示在授权弹窗内（长度不超过13）。授权框中「设备名字」= 「deviceName」 + 「modelId 对应设备型号」。
         */
        deviceName: string;
        /**
         * 需要基础库： `2.30.4`
         *
         * 设备组的唯一标识 id 。isGroup 为 true 时只需要传该参数，isGroup 为 false 时不需要传该参数，但需要传 sn、snTicket、modelId、deviceName 。
         */
        groupId: string;
        /**
         * 设备型号 id。通过微信公众平台注册设备获得。
         */
        modelId: string;
        /**
         * 设备唯一序列号。由厂商分配，长度不能超过128字节。字符只接受数字，大小写字母，下划线（_）和连字符（-）。
         */
        sn: string;
        /**
         * [设备票据](https://developers.weixin.qq.com/miniprogram/dev/OpenApiDoc/hardware-device/getSnTicket.html)，5分钟内有效。
         */
        snTicket: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: RequestDeviceVoIPCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: RequestDeviceVoIPFailCallback;
        /**
         * 需要基础库： `2.30.4`
         *
         * 是否为授权设备组，默认 false 。
         */
        isGroup?: boolean;
        /**
         * 接口调用成功的回调函数
         */
        success?: RequestDeviceVoIPSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type RequestMerchantTransferCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type RequestMerchantTransferFailCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用成功的回调函数
     */
    type RequestMerchantTransferSuccessCallback = (
                res: GeneralCallbackResult
            ) => void;

    interface RequestMerchantTransferOption {
        /**
         * 商户号
         */
        mchId: string;
        /**
         * 商家转账付款单跳转收款页 pkg 信息,商家转账付款单受理成功时返回给商户
         */
        package: string;
        /**
         * 商户 appId，普通模式下必填，服务商模式下，appId 和 subAppId 二选一填写
         */
        appId?: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: RequestMerchantTransferCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: RequestMerchantTransferFailCallback;
        /**
         * 收款用户 openId， 对应传入的商户 appId 下，某用户的 openId
         */
        openId?: string;
        /**
         * 子商户 appId，服务商模式下，appId 和 subAppId 二选一填写
         */
        subAppId?: string;
        /**
         * 子商户号，服务商模式下必填
         */
        subMchId?: string;
        /**
         * 接口调用成功的回调函数
         */
        success?: RequestMerchantTransferSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type RequestOrderPaymentCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type RequestOrderPaymentFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type RequestOrderPaymentSuccessCallback = (
                res: GeneralCallbackResult
            ) => void;

    interface RequestOrderPaymentOption {
        /**
         * 随机字符串，长度为32个字符以下
         */
        nonceStr: string;
        /**
         * 统一下单接口返回的 prepay_id 参数值，提交格式如：prepay_id=***
         */
        package: string;
        /**
         * 签名，具体见微信支付文档
         */
        paySign: string;
        /**
         * 时间戳，从 1970 年 1 月 1 日 00:00:00 至今的秒数，即当前的时间
         */
        timeStamp: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: RequestOrderPaymentCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: RequestOrderPaymentFailCallback;
        /**
         * 签名算法，应与后台下单时的值一致
         *
         * 可选值：
         * - 'MD5': 仅在 v2 版本接口适用;
         * - 'HMAC-SHA256': 仅在 v2 版本接口适用;
         * - 'RSA': 仅在 v3 版本接口适用;
         */
        signType?: "MD5" | "HMAC-SHA256" | "RSA";
        /**
         * 接口调用成功的回调函数
         */
        success?: RequestOrderPaymentSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type RequestPluginPaymentCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type RequestPluginPaymentFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type RequestPluginPaymentSuccessCallback = (
                res: GeneralCallbackResult
            ) => void;

    interface RequestPluginPaymentOption {
        /**
         * 需要显示在页面中的金额，单位为分
         */
        fee: number;
        /**
         * 任意数据，传递给功能页中的响应函数
         */
        paymentArgs: any;
        /**
         * 插件版本
         *
         * 可选值：
         * - 'develop': 开发版;
         * - 'trial': 体验版;
         * - 'release': 正式版;
         */
        version: "develop" | "trial" | "release";
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: RequestPluginPaymentCompleteCallback;
        /**
         * 需要显示在页面中的货币符号的代码
         */
        currencyType?: string;
        /**
         * 接口调用失败的回调函数
         */
        fail?: RequestPluginPaymentFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: RequestPluginPaymentSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type RequestSubscribeDeviceMessageCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;

    interface RequestSubscribeDeviceMessageFailCallbackResult {
        /**
         * 接口调用失败错误码，有可能为空
         */
        errCode: number;
        /**
         * 接口调用失败错误信息
         */
        errMsg: string;
    }

    /**
     * 接口调用失败的回调函数
     */
    type RequestSubscribeDeviceMessageFailCallback = (
                result: RequestSubscribeDeviceMessageFailCallbackResult
            ) => void;

    interface RequestSubscribeDeviceMessageSuccessCallbackResult {
        /**
         * 接口调用成功时errMsg值为'requestSubscribeDeviceMessage:ok'
         */
        errMsg: string;
    }

    /**
     * 接口调用成功的回调函数
     */
    type RequestSubscribeDeviceMessageSuccessCallback = (
                result: RequestSubscribeDeviceMessageSuccessCallbackResult
            ) => void;

    interface RequestSubscribeDeviceMessageOption {
        /**
         * 设备型号 id 。通过微信公众平台注册设备获得。
         */
        modelId: string;
        /**
         * 设备唯一序列号。由厂商分配，长度不能超过128字节。字符只接受数字，大小写字母，下划线（_）和连字符（-）。
         */
        sn: string;
        /**
         * 设备票据，5分钟内有效。
         */
        snTicket: string;
        /**
         * 需要订阅的消息模板的 id 的集合，一次调用最多可订阅3条消息
         */
        tmplIds: any[];
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: RequestSubscribeDeviceMessageCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: RequestSubscribeDeviceMessageFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: RequestSubscribeDeviceMessageSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type RequestSubscribeMessageCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;

    interface RequestSubscribeMessageFailCallbackResult {
        /**
         * 接口调用失败错误码
         */
        errCode: number;
        /**
         * 接口调用失败错误信息
         */
        errMsg: string;
    }

    /**
     * 接口调用失败的回调函数
     */
    type RequestSubscribeMessageFailCallback = (
                result: RequestSubscribeMessageFailCallbackResult
            ) => void;

    interface RequestSubscribeMessageSuccessCallbackResult {
        /**
         * 接口调用成功时errMsg值为'requestSubscribeMessage:ok'
         */
        errMsg: string;
    }

    /**
     * 接口调用成功的回调函数
     */
    type RequestSubscribeMessageSuccessCallback = (
                result: RequestSubscribeMessageSuccessCallbackResult
            ) => void;

    interface RequestSubscribeMessageOption {
        /**
         * 需要订阅的消息模板的id的集合，一次调用最多可订阅3条消息（注意：iOS客户端7.0.6版本、Android客户端7.0.7版本之后的一次性订阅/长期订阅才支持多个模板消息，iOS客户端7.0.5版本、Android客户端7.0.6版本之前的一次订阅只支持一个模板消息）消息模板id在[微信公众平台(mp.weixin.qq.com)-功能-订阅消息]中配置。每个tmplId对应的模板标题需要不相同，否则会被过滤。
         */
        tmplIds: any[];
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: RequestSubscribeMessageCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: RequestSubscribeMessageFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: RequestSubscribeMessageSuccessCallback;
    }

    /**
     * 具体支付参数见signData, 该参数需以string形式传递, 例如signData: '{"offerId":"123","buyQuantity":1,"env":0,"currencyType":"CNY","productId":"testproductId","goodsPrice":10,"outTradeNo":"xxxxxx","attach":"testdata"}'
     */
    interface SignData {
        /**
         * 透传数据, 发货通知时会透传给开发者
         */
        attach: string;
        /**
         * 购买数量
         */
        buyQuantity: number;
        /**
         * 币种
         *
         * 可选值：
         * - 'CNY': 人民币;
         */
        currencyType: "CNY";
        /**
         * 在米大师侧申请的应用 id, mp-支付基础配置中的offerid
         */
        offerId: string;
        /**
         * 业务订单号, 每个订单号只能使用一次, 重复使用会失败(极端情况不保证唯一, 不建议业务强依赖唯一性).  要求8-32个字符内, 只能是数字、大小写字母、符号 _-|*@组成, 不能以下划线(_)开头
         */
        outTradeNo: string;
        /**
         * 环境配置, 0 米大师正式环境, 1 米大师沙箱环境, 默认为 0
         */
        env?: number;
        /**
         * 道具单价(分), **该字段仅mode=short_series_goods时需要必填**, 用来校验价格与后台道具价格是否一致, 避免用户在业务商城页看到的价格与实际价格不一致导致投诉
         */
        goodsPrice?: number;
        /**
         * 道具ID, **该字段仅mode=short_series_goods时需要必填**
         */
        productId?: string;
    }

    interface VirtualPaymentError {
        /**
         * 错误信息
         *
         * | 错误码 | 错误信息 | 说明 |
         * | - | - | - |
         * | 1001 |  | 参数错误 |
         * | -1 |  | 支付失败 |
         * | -2 |  | 支付取消 |
         * | -4 |  | 风控拦截 |
         * | -5 |  | 开通签约结果未知 |
         * | -15001 |  | 参数错误,具体原因见err_msg |
         * | -15002 |  | outTradeNo重复使用,请换新单号重试 |
         * | -15003 |  | 系统错误 |
         * | -15004 |  | currencyType错误,目前只能填CNY |
         * | -15005 |  | 用户态签名signature错误 |
         * | -15006 |  | 支付签名paySig错误 |
         * | -15007 |  | session_key过期 |
         * | -15008 |  | 二级商户进件未完成 |
         * | -15009 |  | 代币未发布 |
         * | -15010 |  | 道具productId未发布 |
         * | -15011 |  | 现网版本的env只能是0,不能填1(沙盒环境) |
         * | -15012 |  | 调用米大师失败导致关单,请换新单号重试 |
         * | -15013 |  | goodsPrice道具价格错误 |
         * | -15014 |  | 道具/代币发布未生效，禁止下单，大概10分钟后生效 |
         * | -15016 |  | signData格式有问题 |
         * | -15017 |  | 此商家涉嫌违规，收款功能已被限制，暂无法支付。商家可以登录微信商户平台/微信支付商家助手小程序查看原因和解决方案 |
         * | -15018 |  | 代币或者道具productId审核不通过 |
         * | -15019 |  | 调微信报商户受限,商家可以登录微信商户平台/微信支付商家助手小程序查看原因和解决方案 |
         * | -15020 |  | 操作过快，请稍候再试 |
         * | -15021 |  | 小程序被限频交易 |
         */
        errMsg: string;
        /**
         * 错误码
         *
         * | 错误码 | 错误信息 | 说明 |
         * | - | - | - |
         * | 1001 |  | 参数错误 |
         * | -1 |  | 支付失败 |
         * | -2 |  | 支付取消 |
         * | -4 |  | 风控拦截 |
         * | -5 |  | 开通签约结果未知 |
         * | -15001 |  | 参数错误,具体原因见err_msg |
         * | -15002 |  | outTradeNo重复使用,请换新单号重试 |
         * | -15003 |  | 系统错误 |
         * | -15004 |  | currencyType错误,目前只能填CNY |
         * | -15005 |  | 用户态签名signature错误 |
         * | -15006 |  | 支付签名paySig错误 |
         * | -15007 |  | session_key过期 |
         * | -15008 |  | 二级商户进件未完成 |
         * | -15009 |  | 代币未发布 |
         * | -15010 |  | 道具productId未发布 |
         * | -15011 |  | 现网版本的env只能是0,不能填1(沙盒环境) |
         * | -15012 |  | 调用米大师失败导致关单,请换新单号重试 |
         * | -15013 |  | goodsPrice道具价格错误 |
         * | -15014 |  | 道具/代币发布未生效，禁止下单，大概10分钟后生效 |
         * | -15016 |  | signData格式有问题 |
         * | -15017 |  | 此商家涉嫌违规，收款功能已被限制，暂无法支付。商家可以登录微信商户平台/微信支付商家助手小程序查看原因和解决方案 |
         * | -15018 |  | 代币或者道具productId审核不通过 |
         * | -15019 |  | 调微信报商户受限,商家可以登录微信商户平台/微信支付商家助手小程序查看原因和解决方案 |
         * | -15020 |  | 操作过快，请稍候再试 |
         * | -15021 |  | 小程序被限频交易 |
         */
        errCode: number;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type RequestVirtualPaymentCompleteCallback = (
                res: VirtualPaymentError
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type RequestVirtualPaymentFailCallback = (
                err: RequestVirtualPaymentFailCallbackErr
            ) => void;
    /**
     * 接口调用成功的回调函数
     */
    type RequestVirtualPaymentSuccessCallback = (
                result: RequestCommonPaymentSuccessCallbackResult
            ) => void;

    interface RequestVirtualPaymentOption {
        /**
         * 支付的类型, 不同的支付类型有各自额外要传的附加参数
         *
         * 可选值：
         * - 'short_series_goods': 道具直购;
         * - 'short_series_coin': 代币充值;
         */
        mode: "short_series_goods" | "short_series_coin";
        /**
         * 支付签名, 详见[《签名详解》](https://developers.weixin.qq.com/miniprogram/dev/platform-capabilities/industry/virtual-payment.html)
         */
        paySig: string;
        /**
         * 具体支付参数见signData, 该参数需以string形式传递, 例如signData: '{"offerId":"123","buyQuantity":1,"env":0,"currencyType":"CNY","productId":"testproductId","goodsPrice":10,"outTradeNo":"xxxxxx","attach":"testdata"}'
         */
        signData: SignData;
        /**
         * 用户态签名, 详见[《签名详解》](https://developers.weixin.qq.com/miniprogram/dev/platform-capabilities/industry/virtual-payment.html)
         */
        signature: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: RequestVirtualPaymentCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: RequestVirtualPaymentFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: RequestVirtualPaymentSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type RequirePrivacyAuthorizeCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type RequirePrivacyAuthorizeFailCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用成功的回调函数
     */
    type RequirePrivacyAuthorizeSuccessCallback = (
                res: GeneralCallbackResult
            ) => void;

    interface RequirePrivacyAuthorizeOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: RequirePrivacyAuthorizeCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: RequirePrivacyAuthorizeFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: RequirePrivacyAuthorizeSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type ReserveChannelsLiveCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type ReserveChannelsLiveFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type ReserveChannelsLiveSuccessCallback = (
                res: GeneralCallbackResult
            ) => void;

    interface ReserveChannelsLiveOption {
        /**
         * 预告 id，通过 getChannelsLiveNoticeInfo 接口获取
         */
        noticeId: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: ReserveChannelsLiveCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: ReserveChannelsLiveFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: ReserveChannelsLiveSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type RestartMiniProgramCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type RestartMiniProgramFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type RestartMiniProgramSuccessCallback = (
                res: GeneralCallbackResult
            ) => void;

    interface RestartMiniProgramOption {
        /**
         * 打开的页面路径，path 中 ? 后面的部分会成为 query
         */
        path: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: RestartMiniProgramCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: RestartMiniProgramFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: RestartMiniProgramSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type RewriteRouteCompleteCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用失败的回调函数
     */
    type RewriteRouteFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type RewriteRouteSuccessCallback = (res: GeneralCallbackResult) => void;

    interface RewriteRouteOption {
        /**
         * 重写目标页面的路径 (代码包路径), 路径后可以带参数。参数与路径之间使用 `?` 分隔，参数键与参数值用 `=` 相连，不同参数用 `&` 分隔；如 `'path?key=value&key2=value2'`
         */
        url: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: RewriteRouteCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: RewriteRouteFailCallback;
        /**
         * 是否直接保留当前路由事件的参数，默认为 `false`；开启时，`url` 里面传入的参数会被丢弃
         */
        preserveQuery?: boolean;
        /**
         * 接口调用成功的回调函数
         */
        success?: RewriteRouteSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type SaveFileToDiskCompleteCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用失败的回调函数
     */
    type SaveFileToDiskFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type SaveFileToDiskSuccessCallback = (res: GeneralCallbackResult) => void;

    interface SaveFileToDiskOption {
        /**
         * 待保存文件路径
         */
        filePath: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: SaveFileToDiskCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: SaveFileToDiskFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: SaveFileToDiskSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type SeekBackgroundAudioCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type SeekBackgroundAudioFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type SeekBackgroundAudioSuccessCallback = (
                res: GeneralCallbackResult
            ) => void;

    interface SeekBackgroundAudioOption {
        /**
         * 音乐位置，单位：秒
         */
        position: number;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: SeekBackgroundAudioCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: SeekBackgroundAudioFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: SeekBackgroundAudioSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type SelectGroupMembersCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type SelectGroupMembersFailCallback = (res: GeneralCallbackResult) => void;

    interface GroupMemberInfo {
        /**
         * 所选用户在此聊天室下的唯一标识，同一个用户在不同的聊天室下id不同
         */
        members: string[];
        errMsg: string;
    }

    /**
     * 接口调用成功的回调函数
     */
    type SelectGroupMembersSuccessCallback = (result: GroupMemberInfo) => void;

    interface SelectGroupMembersOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: SelectGroupMembersCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: SelectGroupMembersFailCallback;
        /**
         * 最多可选人数
         */
        maxSelectCount?: number;
        /**
         * 接口调用成功的回调函数
         */
        success?: SelectGroupMembersSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type SendHCEMessageCompleteCallback = (res: NFCError) => void;
    /**
     * 接口调用失败的回调函数
     */
    type SendHCEMessageFailCallback = (res: NFCError) => void;
    /**
     * 接口调用成功的回调函数
     */
    type SendHCEMessageSuccessCallback = (res: NFCError) => void;

    interface SendHCEMessageOption {
        /**
         * 二进制数据
         */
        data: ArrayBuffer;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: SendHCEMessageCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: SendHCEMessageFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: SendHCEMessageSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type SendSmsCompleteCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用失败的回调函数
     */
    type SendSmsFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type SendSmsSuccessCallback = (res: GeneralCallbackResult) => void;

    interface SendSmsOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: SendSmsCompleteCallback;
        /**
         * 预填到发送短信面板的内容
         */
        content?: string;
        /**
         * 接口调用失败的回调函数
         */
        fail?: SendSmsFailCallback;
        /**
         * 预填到发送短信面板的手机号
         */
        phoneNumber?: string;
        /**
         * 接口调用成功的回调函数
         */
        success?: SendSmsSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type SetBackgroundFetchTokenCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type SetBackgroundFetchTokenFailCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用成功的回调函数
     */
    type SetBackgroundFetchTokenSuccessCallback = (
                res: GeneralCallbackResult
            ) => void;

    interface SetBackgroundFetchTokenOption {
        /**
         * 自定义的登录态
         */
        token: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: SetBackgroundFetchTokenCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: SetBackgroundFetchTokenFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: SetBackgroundFetchTokenSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type SetEnable1v1ChatCompleteCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用失败的回调函数
     */
    type SetEnable1v1ChatFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type SetEnable1v1ChatSuccessCallback = (res: GeneralCallbackResult) => void;

    interface SetEnable1v1ChatOption {
        /**
         * 是否开启
         */
        enable: boolean;
        /**
         * 窗口背景色(音频通话背景以及小窗模式背景)
         *
         * 可选值：
         * - 0: #262930;
         * - 1: #FA5151;
         * - 2: #FA9D3B;
         * - 3: #3D7257;
         * - 4: #1485EE;
         * - 5: #6467F0;
         */
        backgroundType?: 0 | 1 | 2 | 3 | 4 | 5;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: SetEnable1v1ChatCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: SetEnable1v1ChatFailCallback;
        /**
         * 小窗样式
         */
        minWindowType?: number;
        /**
         * 接口调用成功的回调函数
         */
        success?: SetEnable1v1ChatSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type SetInnerAudioOptionCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type SetInnerAudioOptionFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type SetInnerAudioOptionSuccessCallback = (
                res: GeneralCallbackResult
            ) => void;

    interface SetInnerAudioOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: SetInnerAudioOptionCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: SetInnerAudioOptionFailCallback;
        /**
         * 是否与其他音频混播，设置为 true 之后，不会终止其他应用或微信内的音乐
         */
        mixWithOther?: boolean;
        /**
         * （仅在 iOS 生效）是否遵循静音开关，设置为 false 之后，即使是在静音模式下，也能播放声音
         */
        obeyMuteSwitch?: boolean;
        /**
         * true 代表用扬声器播放，false 代表听筒播放，默认值为 true。
         */
        speakerOn?: boolean;
        /**
         * 接口调用成功的回调函数
         */
        success?: SetInnerAudioOptionSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type SetTopBarTextCompleteCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用失败的回调函数
     */
    type SetTopBarTextFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type SetTopBarTextSuccessCallback = (res: GeneralCallbackResult) => void;

    interface SetTopBarTextOption {
        /**
         * 置顶栏文字
         */
        text: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: SetTopBarTextCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: SetTopBarTextFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: SetTopBarTextSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type SetVisualEffectOnCaptureCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type SetVisualEffectOnCaptureFailCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用成功的回调函数
     */
    type SetVisualEffectOnCaptureSuccessCallback = (
                res: GeneralCallbackResult
            ) => void;

    interface SetVisualEffectOnCaptureOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: SetVisualEffectOnCaptureCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: SetVisualEffectOnCaptureFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: SetVisualEffectOnCaptureSuccessCallback;
        /**
         * 截屏/录屏时的表现，仅支持 none / hidden，传入 hidden 则表示在截屏/录屏时隐藏屏幕
         */
        visualEffect?: string;
    }

    /**
     * 提供预设的 Wi-Fi 信息列表
     */
    interface WifiData {
        /**
         * Wi-Fi 的 BSSID
         */
        BSSID?: string;
        /**
         * Wi-Fi 的 SSID
         */
        SSID?: string;
        /**
         * Wi-Fi 设备密码
         */
        password?: string;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type SetWifiListCompleteCallback = (res: WifiError) => void;
    /**
     * 接口调用失败的回调函数
     */
    type SetWifiListFailCallback = (res: WifiError) => void;
    /**
     * 接口调用成功的回调函数
     */
    type SetWifiListSuccessCallback = (res: WifiError) => void;

    interface SetWifiListOption {
        /**
         * 提供预设的 Wi-Fi 信息列表
         */
        wifiList: WifiData[];
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: SetWifiListCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: SetWifiListFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: SetWifiListSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type SetWindowSizeCompleteCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用失败的回调函数
     */
    type SetWindowSizeFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type SetWindowSizeSuccessCallback = (res: GeneralCallbackResult) => void;

    interface SetWindowSizeOption {
        /**
         * 窗口高度，以像素为单位
         */
        height: number;
        /**
         * 窗口宽度，以像素为单位
         */
        width: number;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: SetWindowSizeCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: SetWindowSizeFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: SetWindowSizeSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type ShareAppMessageToGroupCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type ShareAppMessageToGroupFailCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用成功的回调函数
     */
    type ShareAppMessageToGroupSuccessCallback = (
                res: GeneralCallbackResult
            ) => void;

    interface ShareAppMessageToGroupOption {
        /**
         * 转发标题
         */
        title: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: ShareAppMessageToGroupCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: ShareAppMessageToGroupFailCallback;
        /**
         * 自定义图片路径，支持PNG及JPG，显示图片长宽比是 5:4，默认使用截图
         */
        imageUrl?: string;
        /**
         * 转发路径，必须是以 / 开头的完整路径，默认为当前页面
         */
        path?: string;
        /**
         * 接口调用成功的回调函数
         */
        success?: ShareAppMessageToGroupSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type ShareEmojiToGroupCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type ShareEmojiToGroupFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type ShareEmojiToGroupSuccessCallback = (res: GeneralCallbackResult) => void;

    interface ShareEmojiToGroupOption {
        /**
         * 要分享的表情地址，必须为本地路径或临时路径
         */
        imagePath: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: ShareEmojiToGroupCompleteCallback;
        /**
         * 从消息小程序入口打开小程序的路径，默认为聊天工具启动路径
         */
        entrancePath?: string;
        /**
         * 接口调用失败的回调函数
         */
        fail?: ShareEmojiToGroupFailCallback;
        /**
         * 分享的表情消息是否要带小程序入口
         */
        needShowEntrance?: boolean;
        /**
         * 接口调用成功的回调函数
         */
        success?: ShareEmojiToGroupSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type ShareFileMessageCompleteCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用失败的回调函数
     */
    type ShareFileMessageFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type ShareFileMessageSuccessCallback = (res: GeneralCallbackResult) => void;

    interface ShareFileMessageOption {
        /**
         * 要分享的文件地址，必须为本地路径或临时路径
         */
        filePath: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: ShareFileMessageCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: ShareFileMessageFailCallback;
        /**
         * 自定义文件名，若留空则使用filePath中的文件名
         */
        fileName?: string;
        /**
         * 接口调用成功的回调函数
         */
        success?: ShareFileMessageSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type ShareFileToGroupCompleteCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用失败的回调函数
     */
    type ShareFileToGroupFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type ShareFileToGroupSuccessCallback = (res: GeneralCallbackResult) => void;

    interface ShareFileToGroupOption {
        /**
         * 要分享的文件地址，必须为本地路径或临时路径
         */
        filePath: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: ShareFileToGroupCompleteCallback;
        /**
         * 从消息小程序入口打开小程序的路径，默认为聊天工具启动路径
         */
        entrancePath?: string;
        /**
         * 接口调用失败的回调函数
         */
        fail?: ShareFileToGroupFailCallback;
        /**
         * 自定义文件名，若留空则使用filePath中的文件名
         */
        fileName?: string;
        /**
         * 分享的图片消息是否要带小程序入口
         */
        needShowEntrance?: boolean;
        /**
         * 接口调用成功的回调函数
         */
        success?: ShareFileToGroupSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type ShareImageToGroupCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type ShareImageToGroupFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type ShareImageToGroupSuccessCallback = (res: GeneralCallbackResult) => void;

    interface ShareImageToGroupOption {
        /**
         * 要分享的图片地址，必须为本地路径或临时路径
         */
        imagePath: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: ShareImageToGroupCompleteCallback;
        /**
         * 从消息小程序入口打开小程序的路径，默认为聊天工具启动路径
         */
        entrancePath?: string;
        /**
         * 接口调用失败的回调函数
         */
        fail?: ShareImageToGroupFailCallback;
        /**
         * 分享的图片消息是否要带小程序入口
         */
        needShowEntrance?: boolean;
        /**
         * 接口调用成功的回调函数
         */
        success?: ShareImageToGroupSuccessCallback;
    }

    /**
     * 运动数据列表
     */
    interface WxaSportRecord {
        /**
         * 消耗卡路里
         */
        calorie: number;
        /**
         * 运动距离
         */
        distance: number;
        /**
         * 运动时长
         */
        time: number;
        /**
         * 运动项目id
         */
        typeId: number;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type ShareToWeRunCompleteCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用失败的回调函数
     */
    type ShareToWeRunFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type ShareToWeRunSuccessCallback = (res: GeneralCallbackResult) => void;

    interface ShareToWeRunOption {
        /**
         * 运动数据列表
         */
        recordList: WxaSportRecord[];
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: ShareToWeRunCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: ShareToWeRunFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: ShareToWeRunSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type ShareVideoMessageCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type ShareVideoMessageFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type ShareVideoMessageSuccessCallback = (res: GeneralCallbackResult) => void;

    interface ShareVideoMessageOption {
        /**
         * 要分享的视频地址，必须为本地路径或临时路径
         */
        videoPath: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: ShareVideoMessageCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: ShareVideoMessageFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: ShareVideoMessageSuccessCallback;
        /**
         * 缩略图路径，若留空则使用视频首帧
         */
        thumbPath?: string;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type ShareVideoToGroupCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type ShareVideoToGroupFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type ShareVideoToGroupSuccessCallback = (res: GeneralCallbackResult) => void;

    interface ShareVideoToGroupOption {
        /**
         * 要分享的视频地址，必须为本地路径或临时路径
         */
        videoPath: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: ShareVideoToGroupCompleteCallback;
        /**
         * 从消息小程序入口打开小程序的路径，默认为聊天工具启动路径
         */
        entrancePath?: string;
        /**
         * 接口调用失败的回调函数
         */
        fail?: ShareVideoToGroupFailCallback;
        /**
         * 分享的图片消息是否要带小程序入口
         */
        needShowEntrance?: boolean;
        /**
         * 接口调用成功的回调函数
         */
        success?: ShareVideoToGroupSuccessCallback;
        /**
         * 缩略图路径，若留空则使用视频首帧
         */
        thumbPath?: string;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type ShowRedPackageCompleteCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用失败的回调函数
     */
    type ShowRedPackageFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type ShowRedPackageSuccessCallback = (res: GeneralCallbackResult) => void;

    interface ShowRedPackageOption {
        /**
         * 封面地址
         */
        url: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: ShowRedPackageCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: ShowRedPackageFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: ShowRedPackageSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type ShowShareImageMenuCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type ShowShareImageMenuFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type ShowShareImageMenuSuccessCallback = (
                res: GeneralCallbackResult
            ) => void;

    interface ShowShareImageMenuOption {
        /**
         * 要分享的图片地址，必须为本地路径或临时路径
         */
        path: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: ShowShareImageMenuCompleteCallback;
        /**
         * 需要基础库： `3.2.0`
         *
         * 从消息小程序入口打开小程序的路径，如果当前页面允许分享给朋友，则默认为当前页面路径，否则默认为小程序首页
         */
        entrancePath?: string;
        /**
         * 接口调用失败的回调函数
         */
        fail?: ShowShareImageMenuFailCallback;
        /**
         * 需要基础库： `3.2.0`
         *
         * 分享的图片消息是否要带小程序入口
         */
        needShowEntrance?: boolean;
        /**
         * 接口调用成功的回调函数
         */
        success?: ShowShareImageMenuSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type StartDeviceMotionListeningCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type StartDeviceMotionListeningFailCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用成功的回调函数
     */
    type StartDeviceMotionListeningSuccessCallback = (
                res: GeneralCallbackResult
            ) => void;

    interface StartDeviceMotionListeningOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: StartDeviceMotionListeningCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: StartDeviceMotionListeningFailCallback;
        /**
         * 监听设备方向的变化回调函数的执行频率
         *
         * 可选值：
         * - 'game': 适用于更新游戏的回调频率，在 20ms/次 左右;
         * - 'ui': 适用于更新 UI 的回调频率，在 60ms/次 左右;
         * - 'normal': 普通的回调频率，在 200ms/次 左右;
         */
        interval?: "game" | "ui" | "normal";
        /**
         * 接口调用成功的回调函数
         */
        success?: StartDeviceMotionListeningSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type StartHCECompleteCallback = (res: NFCError) => void;
    /**
     * 接口调用失败的回调函数
     */
    type StartHCEFailCallback = (res: NFCError) => void;
    /**
     * 接口调用成功的回调函数
     */
    type StartHCESuccessCallback = (res: NFCError) => void;

    interface StartHCEOption {
        /**
         * 需要注册到系统的 AID 列表
         */
        aid_list: string[];
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: StartHCECompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: StartHCEFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: StartHCESuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type StartLocalServiceDiscoveryCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;

    interface StartLocalServiceDiscoveryFailCallbackResult {
        /**
         * 错误信息
         *
         * 可选值：
         * - 'invalid param': serviceType 为空;
         * - 'scan task already exist': 在当前 startLocalServiceDiscovery 发起的搜索未停止的情况下，再次调用 startLocalServiceDiscovery;
         */
        errMsg: string;
    }

    /**
     * 接口调用失败的回调函数
     */
    type StartLocalServiceDiscoveryFailCallback = (
                result: StartLocalServiceDiscoveryFailCallbackResult
            ) => void;
    /**
     * 接口调用成功的回调函数
     */
    type StartLocalServiceDiscoverySuccessCallback = (
                res: GeneralCallbackResult
            ) => void;

    interface StartLocalServiceDiscoveryOption {
        /**
         * 要搜索的服务类型
         */
        serviceType: string;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: StartLocalServiceDiscoveryCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: StartLocalServiceDiscoveryFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: StartLocalServiceDiscoverySuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type StartLocationUpdateBackgroundCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type StartLocationUpdateBackgroundFailCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用成功的回调函数
     */
    type StartLocationUpdateBackgroundSuccessCallback = (
                res: GeneralCallbackResult
            ) => void;

    interface StartLocationUpdateBackgroundOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: StartLocationUpdateBackgroundCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: StartLocationUpdateBackgroundFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: StartLocationUpdateBackgroundSuccessCallback;
        /**
         * wgs84 返回 gps 坐标，gcj02 返回可用于 wx.openLocation 的坐标
         */
        type?: string;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type StartRecordCompleteCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用失败的回调函数
     */
    type StartRecordFailCallback = (res: GeneralCallbackResult) => void;

    interface StartRecordSuccessCallbackResult {
        /**
         * 录音文件的临时路径 (本地路径)
         */
        tempFilePath: string;
        errMsg: string;
    }

    /**
     * 接口调用成功的回调函数
     */
    type WxStartRecordSuccessCallback = (
                result: StartRecordSuccessCallbackResult
            ) => void;

    interface WxStartRecordOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: StartRecordCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: StartRecordFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: WxStartRecordSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type StopBackgroundAudioCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type StopBackgroundAudioFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type StopBackgroundAudioSuccessCallback = (
                res: GeneralCallbackResult
            ) => void;

    interface StopBackgroundAudioOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: StopBackgroundAudioCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: StopBackgroundAudioFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: StopBackgroundAudioSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type StopDeviceMotionListeningCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type StopDeviceMotionListeningFailCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用成功的回调函数
     */
    type StopDeviceMotionListeningSuccessCallback = (
                res: GeneralCallbackResult
            ) => void;

    interface StopDeviceMotionListeningOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: StopDeviceMotionListeningCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: StopDeviceMotionListeningFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: StopDeviceMotionListeningSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type StopFaceDetectCompleteCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用失败的回调函数
     */
    type StopFaceDetectFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type StopFaceDetectSuccessCallback = (res: GeneralCallbackResult) => void;

    interface StopFaceDetectOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: StopFaceDetectCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: StopFaceDetectFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: StopFaceDetectSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type StopHCECompleteCallback = (res: NFCError) => void;
    /**
     * 接口调用失败的回调函数
     */
    type StopHCEFailCallback = (res: NFCError) => void;
    /**
     * 接口调用成功的回调函数
     */
    type StopHCESuccessCallback = (res: NFCError) => void;

    interface StopHCEOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: StopHCECompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: StopHCEFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: StopHCESuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type StopLocalServiceDiscoveryCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;

    interface StopLocalServiceDiscoveryFailCallbackResult {
        /**
         * 错误信息
         *
         * 可选值：
         * - 'task not found': 在当前没有处在搜索服务中的情况下调用 stopLocalServiceDiscovery;
         */
        errMsg: string;
    }

    /**
     * 接口调用失败的回调函数
     */
    type StopLocalServiceDiscoveryFailCallback = (
                result: StopLocalServiceDiscoveryFailCallbackResult
            ) => void;
    /**
     * 接口调用成功的回调函数
     */
    type StopLocalServiceDiscoverySuccessCallback = (
                res: GeneralCallbackResult
            ) => void;

    interface StopLocalServiceDiscoveryOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: StopLocalServiceDiscoveryCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: StopLocalServiceDiscoveryFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: StopLocalServiceDiscoverySuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type StopRecordCompleteCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用失败的回调函数
     */
    type StopRecordFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type WxStopRecordSuccessCallback = (res: GeneralCallbackResult) => void;

    interface WxStopRecordOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: StopRecordCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: StopRecordFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: WxStopRecordSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type StopVoiceCompleteCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用失败的回调函数
     */
    type StopVoiceFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type StopVoiceSuccessCallback = (res: GeneralCallbackResult) => void;

    interface StopVoiceOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: StopVoiceCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: StopVoiceFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: StopVoiceSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type SubscribeVoIPVideoMembersCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type SubscribeVoIPVideoMembersFailCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用成功的回调函数
     */
    type SubscribeVoIPVideoMembersSuccessCallback = (
                res: GeneralCallbackResult
            ) => void;

    interface SubscribeVoIPVideoMembersOption {
        /**
         * 订阅的成员列表
         */
        openIdList: string[];
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: SubscribeVoIPVideoMembersCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: SubscribeVoIPVideoMembersFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: SubscribeVoIPVideoMembersSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type UpdateShareMenuCompleteCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用失败的回调函数
     */
    type UpdateShareMenuFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type UpdateShareMenuSuccessCallback = (res: GeneralCallbackResult) => void;

    /**
     * 参数列表
     */
    interface UpdatableMessageFrontEndParameter {
        /**
         * 参数名
         */
        name: string;
        /**
         * 参数值
         */
        value: string;
    }

    /**
     * 需要基础库： `2.4.0`
     *
     * 动态消息的模板信息
     */
    interface UpdatableMessageFrontEndTemplateInfo {
        /**
         * 参数列表
         */
        parameterList: UpdatableMessageFrontEndParameter[];
        /**
         * 模板ID
         */
        templateId: string;
    }

    interface UpdateShareMenuOption {
        /**
         * 需要基础库： `2.4.0`
         *
         * 动态消息的 activityId。通过 [updatableMessage.createActivityId](#) 接口获取
         */
        activityId?: string;
        /**
         * 需要基础库： `3.7.8`
         *
         * 指定成员的方式
         */
        chooseType?: number;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: UpdateShareMenuCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: UpdateShareMenuFailCallback;
        /**
         * 需要基础库： `2.13.0`
         *
         * 是否是私密消息。详见 [小程序私密消息](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/share/private-message.html)
         */
        isPrivateMessage?: boolean;
        /**
         * 需要基础库： `2.4.0`
         *
         * 是否是动态消息，详见[动态消息](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/share/updatable-message.html)
         */
        isUpdatableMessage?: boolean;
        /**
         * 参与用户此聊天室下的 group_openid 列表
         */
        participant?: string[];
        /**
         * 接口调用成功的回调函数
         */
        success?: UpdateShareMenuSuccessCallback;
        /**
         * 需要基础库： `2.4.0`
         *
         * 动态消息的模板信息
         */
        templateInfo?: UpdatableMessageFrontEndTemplateInfo;
        /**
         * 需要基础库： `2.11.0`
         *
         * 群待办消息的id，通过toDoActivityId可以把多个群待办消息聚合为同一个。通过 [updatableMessage.createActivityId](#) 接口获取。详见[群待办消息](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/share.html)
         */
        toDoActivityId?: string;
        /**
         * 需要基础库： `3.7.8`
         *
         * 聊天工具模式特殊动态消息
         */
        useForChatTool?: boolean;
        /**
         * 是否使用带 shareTicket 的转发[详情](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/share.html)
         */
        withShareTicket?: boolean;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type UpdateVoIPChatMuteConfigCompleteCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用失败的回调函数
     */
    type UpdateVoIPChatMuteConfigFailCallback = (
                res: GeneralCallbackResult
            ) => void;
    /**
     * 接口调用成功的回调函数
     */
    type UpdateVoIPChatMuteConfigSuccessCallback = (
                res: GeneralCallbackResult
            ) => void;

    interface UpdateVoIPChatMuteConfigOption {
        /**
         * 静音设置
         */
        muteConfig: MuteConfig;
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: UpdateVoIPChatMuteConfigCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: UpdateVoIPChatMuteConfigFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: UpdateVoIPChatMuteConfigSuccessCallback;
    }

    /**
     * 接口调用结束的回调函数（调用成功、失败都会执行）
     */
    type UpdateWeChatAppCompleteCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用失败的回调函数
     */
    type UpdateWeChatAppFailCallback = (res: GeneralCallbackResult) => void;
    /**
     * 接口调用成功的回调函数
     */
    type UpdateWeChatAppSuccessCallback = (res: GeneralCallbackResult) => void;

    interface UpdateWeChatAppOption {
        /**
         * 接口调用结束的回调函数（调用成功、失败都会执行）
         */
        complete?: UpdateWeChatAppCompleteCallback;
        /**
         * 接口调用失败的回调函数
         */
        fail?: UpdateWeChatAppFailCallback;
        /**
         * 接口调用成功的回调函数
         */
        success?: UpdateWeChatAppSuccessCallback;
    }
}

interface Uni {
    /**
     *
     * 需要基础库： `2.25.0`
     *
     * 在插件中使用：不支持
     *
     * 从本地缓存中同步批量获取指定 key 的内容。
     *
     *
     * ****
     *
     * 对于多个key的读取, 批量读取在性能上优于多次getStorageSync读取
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/storage/wx.batchGetStorageSync.html](https://developers.weixin.qq.com/miniprogram/dev/api/storage/wx.batchGetStorageSync.html)
     */
    batchGetStorageSync(keyList: string[]): any[];
    /**
     *
     * 需要基础库： `2.2.2`
     *
     * 在插件中使用：需要基础库 `2.2.2`
     *
     * 获取当前账号信息。线上小程序版本号仅支持在正式版小程序中获取，开发版和体验版中无法获取。
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/open-api/account-info/wx.getAccountInfoSync.html](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/account-info/wx.getAccountInfoSync.html)
     */
    getAccountInfoSync(): UniNamespace.AccountInfo;
    /**
     *
     * 在插件中使用：需要基础库 `2.15.0`
     *
     * [uni.getBatteryInfo](https://developers.weixin.qq.com/miniprogram/dev/api/device/battery/wx.getBatteryInfo.html) 的同步版本
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/battery/wx.getBatteryInfoSync.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/battery/wx.getBatteryInfoSync.html)
     */
    getBatteryInfoSync(): UniNamespace.GetBatteryInfoSyncResult;
    /**
     *
     * 需要基础库： `2.17.0`
     *
     * 在插件中使用：不支持
     *
     * 给定实验参数数组，获取对应的实验参数值
     *
     * **提示**
     *
     * 假设实验参数有 `color`, `size`
     * 调用 wx.getExptInfoSync() 会返回 `{color:'#fff',size:20}` 类似的结果
     * 而 wx.getExptInfoSync(['color']) 则只会返回 `{color:'#fff'}`
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/data-analysis/wx.getExptInfoSync.html](https://developers.weixin.qq.com/miniprogram/dev/api/data-analysis/wx.getExptInfoSync.html)
     */
    getExptInfoSync(keys?: string[]): any;
    /**
     *
     * 需要基础库： `2.26.2`
     *
     * 在插件中使用：需要基础库 `2.26.2`
     *
     * 获取当前运行环境对于 [Skyline 渲染引擎](https://developers.weixin.qq.com/miniprogram/dev/framework/runtime/skyline/introduction.html) 的支持情况
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/system/wx.getSkylineInfoSync.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/system/wx.getSkylineInfoSync.html)
     */
    getSkylineInfoSync(): UniNamespace.SkylineInfo;
    /**
     *
     * 需要基础库： `2.26.3`
     *
     * 在插件中使用：需要基础库 `2.21.3`
     *
     * 获取 Webview 小程序的 UserAgent
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/system/wx.getRendererUserAgent.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/system/wx.getRendererUserAgent.html)
     */
    getRendererUserAgent(option?: UniNamespace.GetRendererUserAgentOption): Promise<string>;
    /**
     *
     * 在插件中使用：需要基础库 `1.9.6`
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/wx.createAudioContext.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/wx.createAudioContext.html)
     */
    createAudioContext(id: string, component?: any): UniNamespace.AudioContext;
    /**
     *
     * 需要基础库： `2.24.0`
     *
     * 在插件中使用：不支持
     *
     * 创建缓存管理器
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/storage/cachemanager/wx.createCacheManager.html](https://developers.weixin.qq.com/miniprogram/dev/api/storage/cachemanager/wx.createCacheManager.html)
     */
    createCacheManager(option: UniNamespace.CreateCacheManagerOption): UniNamespace.CacheManager;
    /**
     *
     * 需要基础库： `1.9.9`
     *
     * 在插件中使用：需要基础库 `2.19.2`
     *
     * 获取全局唯一的文件管理器
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/file/wx.getFileSystemManager.html](https://developers.weixin.qq.com/miniprogram/dev/api/file/wx.getFileSystemManager.html)
     */
    getFileSystemManager(): UniNamespace.FileSystemManager;
    /**
     *
     * 需要基础库： `2.30.0`
     *
     * 在插件中使用：需要基础库 `2.30.0`
     *
     * 创建 AI 推理 Session。使用前可参考[AI指南文档](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/inference/tutorial.html)
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/ai/inference/wx.createInferenceSession.html](https://developers.weixin.qq.com/miniprogram/dev/api/ai/inference/wx.createInferenceSession.html)
     */
    createInferenceSession(option: UniNamespace.CreateInferenceSessionOption): UniNamespace.InferenceSession;
    /**
     *
     * 需要基础库： `1.7.0`
     *
     * 在插件中使用：需要基础库 `1.9.6`
     *
     * 创建 [live-player](https://developers.weixin.qq.com/miniprogram/dev/component/live-player.html) 上下文 [LivePlayerContext](https://developers.weixin.qq.com/miniprogram/dev/api/media/live/LivePlayerContext.html) 对象。建议使用 [uni.createSelectorQuery](https://developers.weixin.qq.com/miniprogram/dev/api/wxml/wx.createSelectorQuery.html) 获取 context 对象。
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/live/wx.createLivePlayerContext.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/live/wx.createLivePlayerContext.html)
     */
    createLivePlayerContext(id: string, component?: any): UniNamespace.LivePlayerContext;
    /**
     *
     * 需要基础库： `2.1.0`
     *
     * 在插件中使用：不支持
     *
     * 获取日志管理器对象。
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/debug/wx.getLogManager.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/debug/wx.getLogManager.html)
     */
    getLogManager(option: UniNamespace.GetLogManagerOption): UniNamespace.LogManager;
    /**
     *
     * 需要基础库： `2.13.0`
     *
     * 在插件中使用：支持
     *
     * 创建媒体音频播放器对象 [MediaAudioPlayer](https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/MediaAudioPlayer.html) 对象，可用于播放视频解码器 [VideoDecoder](https://developers.weixin.qq.com/miniprogram/dev/api/media/video-decoder/VideoDecoder.html) 输出的音频。
     *
     *
     * **完整demo（小游戏）**
     *
     * - https://developers.weixin.qq.com/s/SF2duHmb7MjI
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/wx.createMediaAudioPlayer.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/wx.createMediaAudioPlayer.html)
     */
    createMediaAudioPlayer(): UniNamespace.MediaAudioPlayer;
    /**
     *
     * 需要基础库： `2.9.0`
     *
     * 在插件中使用：需要基础库 `2.10.0`
     *
     * 创建音视频处理容器，最终可将容器中的轨道合成一个视频
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/video-processing/wx.createMediaContainer.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/video-processing/wx.createMediaContainer.html)
     */
    createMediaContainer(): UniNamespace.MediaContainer;
    /**
     *
     * 需要基础库： `2.11.0`
     *
     * 在插件中使用：需要基础库 `2.11.0`
     *
     * 创建 WebGL 画面录制器，可逐帧录制在 WebGL 上渲染的画面并导出视频文件
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/media-recorder/wx.createMediaRecorder.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/media-recorder/wx.createMediaRecorder.html)
     */
    createMediaRecorder(canvas: any, options: UniNamespace.CreateMediaRecorderOption): UniNamespace.MediaRecorder;
    /**
     *
     * 需要基础库： `2.11.2`
     *
     * 在插件中使用：需要基础库 `2.11.2`
     *
     * 获取 NFC 实例
     *
     * **示例代码**
     *
     * [在微信开发者工具中查看示例](https://developers.weixin.qq.com/s/1WsbDwmb75ig)
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/wx.getNFCAdapter.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc/wx.getNFCAdapter.html)
     */
    getNFCAdapter(): UniNamespace.NFCAdapter;
    /**
     *
     * 需要基础库： `2.16.1`
     *
     * 在插件中使用：需要基础库 `2.16.1`
     *
     * 创建离屏 canvas 实例
     *
     * **离屏 Canvas 类型不可混用**
     *
     * 由于 webgl canvas 和 2d canvas 的底层实现方式不同，因此必须要在调用 `wx.createOffscreenCanvas` 时提前指定类型。
     *
     * 指定类型后，离屏 canvas `getContext(type)` 调用不允许混用，如不能对 webgl canvas 调用 `getContext('2d')`。
     *
     * 同样的，不同类型 canvas 调用 `createImage` 创建的图片对象也不支持混用，使用时请注意尽量使用 canvas 自身的 `createImage` 创建图片对象。
     *
     * **与 MediaRecorder 结合**
     *
     * 离屏 webgl canvas 支持作为参数传递给 [`wx.createMediaRecorder`](https://developers.weixin.qq.com/miniprogram/dev/api/media/media-recorder/wx.createMediaRecorder.html), 离屏 2d canvas 暂不支持。
     *
     * **旧版 createOffscreenCanvas**
     *
     * 旧版函数签名为 `wx.createOffscreenCanvas(width: number, height: number, this: object): OffscreenCanvas`，从基础库 2.7.0 开始支持
     *
     * 从基础库 2.16.1 开始改为 `wx.createOffscreenCanvas(options: object): OffscreenCanvas`，向下兼容旧版入参。
     * 但需注意旧版入参只能创建 webgl 类型，如需创建 2d 类型则必须使用新版。
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/canvas/wx.createOffscreenCanvas.html](https://developers.weixin.qq.com/miniprogram/dev/api/canvas/wx.createOffscreenCanvas.html)
     */
    createOffscreenCanvas(width: number, height: number, component?: any): UniNamespace.OffscreenCanvas;
    /**
     *
     * 需要基础库： `2.16.1`
     *
     * 在插件中使用：需要基础库 `2.16.1`
     *
     * 创建离屏 canvas 实例
     *
     * **离屏 Canvas 类型不可混用**
     *
     * 由于 webgl canvas 和 2d canvas 的底层实现方式不同，因此必须要在调用 `wx.createOffscreenCanvas` 时提前指定类型。
     *
     * 指定类型后，离屏 canvas `getContext(type)` 调用不允许混用，如不能对 webgl canvas 调用 `getContext('2d')`。
     *
     * 同样的，不同类型 canvas 调用 `createImage` 创建的图片对象也不支持混用，使用时请注意尽量使用 canvas 自身的 `createImage` 创建图片对象。
     *
     * **与 MediaRecorder 结合**
     *
     * 离屏 webgl canvas 支持作为参数传递给 [`wx.createMediaRecorder`](https://developers.weixin.qq.com/miniprogram/dev/api/media/media-recorder/wx.createMediaRecorder.html), 离屏 2d canvas 暂不支持。
     *
     * **旧版 createOffscreenCanvas**
     *
     * 旧版函数签名为 `wx.createOffscreenCanvas(width: number, height: number, this: object): OffscreenCanvas`，从基础库 2.7.0 开始支持
     *
     * 从基础库 2.16.1 开始改为 `wx.createOffscreenCanvas(options: object): OffscreenCanvas`，向下兼容旧版入参。
     * 但需注意旧版入参只能创建 webgl 类型，如需创建 2d 类型则必须使用新版。
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/canvas/wx.createOffscreenCanvas.html](https://developers.weixin.qq.com/miniprogram/dev/api/canvas/wx.createOffscreenCanvas.html)
     */
    createOffscreenCanvas(option: UniNamespace.CreateOffscreenCanvasOption): UniNamespace.OffscreenCanvas;
    /**
     *
     * 需要基础库： `2.11.0`
     *
     * 在插件中使用：支持
     *
     * 获取当前小程序性能相关的信息。关于小程序启动性能优化的更多内容，请参考[启动性能指南](https://developers.weixin.qq.com/miniprogram/dev/framework/performance/tips/start.html)。
     *
     * ****
     *
     * 目前支持获取以下几类性能指标，具体内容请参考 [PerformanceEntry](https://developers.weixin.qq.com/miniprogram/dev/api/base/performance/PerformanceEntry.html)：
     *
     * | 指标类型（entryType） | 指标名称          | 最低版本 ｜
     * | ------------------- | ---------------- | ------ |
     * | 路由（navigation）   | route: 路由性能 | |
     * | 路由（navigation）   | appLaunch: 小程序启动耗时 | |
     * | 渲染（render）       | firstRender: 页面首次渲染耗时 | |
     * | 渲染（render）       | firstPaint: 页面首次绘制 | <2.21.2> |
     * | 渲染（render）       | firstContentfulPaint: 页面首次内容绘制 |  <2.21.2> |
     * | 渲染（render）       | largestContentfulPaint: 页面最大内容绘制 | <2.23.1> |
     * | 脚本（script）       | evaluateScript: 注入脚本耗时  | |
     * | 包加载（loadPackage）| downloadPackage: 代码包下载耗时  | <2.24.0> |
     * | 资源（resource）     | resourceTiming: 视图层资源加载耗时  | <2.24.0> |
     *
     *
     * **注意**
     *
     * - 目前，当开启代码 [按需注入](https://developers.weixin.qq.com/miniprogram/dev/framework/ability/lazyload.html) 时，`evaluateScript` 将仅包含公有部分代码（2.21.2 开始会区分公共部分/页面和组件的部分），页面和组件的代码注入的时间会包含在 `firstRender` 中（因为页面和组件的代码注入过程成为了首次渲染过程的一部分）。因此开启按需注入后，脚本耗时降低，渲染时间提高属于正常现象，优化效果可以关注整体启动耗时（`appLaunch`）来评估。
     * - firstPaint 和 firstContentfulPaint 指标在开启 vConsole 的情况下，由于绘制 vConsole 面板，会导致数据提前。
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/performance/wx.getPerformance.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/performance/wx.getPerformance.html)
     */
    getPerformance(): UniNamespace.Performance;
    /**
     *
     * 需要基础库： `2.27.3`
     *
     * 在插件中使用：不支持
     *
     * 触发分包预下载。
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/subpackage/wx.preDownloadSubpackage.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/subpackage/wx.preDownloadSubpackage.html)
     */
    preDownloadSubpackage(option: UniNamespace.PreDownloadSubpackageOption): UniNamespace.PreDownloadSubpackageTask;
    /**
     *
     * 需要基础库： `2.7.1`
     *
     * 在插件中使用：需要基础库 `2.16.0`
     *
     * 获取实时日志管理器对象。
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/debug/wx.getRealtimeLogManager.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/debug/wx.getRealtimeLogManager.html)
     */
    getRealtimeLogManager(): UniNamespace.RealtimeLogManager;
    /**
     *
     * 需要基础库： `2.18.0`
     *
     * 在插件中使用：支持
     *
     * 创建一个 TCP Socket 实例。使用前请注意阅读[相关说明](https://developers.weixin.qq.com/miniprogram/dev/framework/ability/network.html)。
     *
     * **连接限制**
     *
     * - 允许与局域网内的非本机 IP 通信
     * - 允许与配置过的服务器域名通信，详见[相关说明](https://developers.weixin.qq.com/miniprogram/dev/framework/ability/network.html)
     * - 禁止与以下端口号连接：`1024 以下` `1099` `1433` `1521` `1719` `1720` `1723` `2049` `2375` `3128` `3306` `3389` `3659` `4045` `5060` `5061` `5432` `5984` `6379` `6000` `6566` `7001` `7002` `8000-8100` `8443` `8888` `9200` `9300` `10051` `10080` `11211` `27017` `27018` `27019`
     * - 每 5 分钟内最多创建 20 个 TCPSocket
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/network/tcp/wx.createTCPSocket.html](https://developers.weixin.qq.com/miniprogram/dev/api/network/tcp/wx.createTCPSocket.html)
     */
    createTCPSocket(option?: UniNamespace.CreateTCPSocketOption): UniNamespace.TCPSocket;
    /**
     *
     * 需要基础库： `2.7.0`
     *
     * 在插件中使用：需要基础库 `2.11.1`
     *
     * 创建一个 UDP Socket 实例。使用前请注意阅读[相关说明](https://developers.weixin.qq.com/miniprogram/dev/framework/ability/network.html)。
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/network/udp/wx.createUDPSocket.html](https://developers.weixin.qq.com/miniprogram/dev/api/network/udp/wx.createUDPSocket.html)
     */
    createUDPSocket(type?: string): UniNamespace.UDPSocket;
    /**
     *
     * 需要基础库： `2.17.3`
     *
     * 在插件中使用：不支持
     *
     * 获取用户加密模块
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/crypto/wx.getUserCryptoManager.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/crypto/wx.getUserCryptoManager.html)
     */
    getUserCryptoManager(): UniNamespace.UserCryptoManager;
    /**
     *
     * 需要基础库： `2.20.0`
     *
     * 在插件中使用：需要基础库 `2.20.0`
     *
     * 创建 vision kit 会话对象。详见[指南](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/visionkit/base.html)
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/wx.createVKSession.html](https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/wx.createVKSession.html)
     */
    createVKSession(option: UniNamespace.VKConfig): UniNamespace.VKSession;
    /**
     *
     * 需要基础库： `2.11.0`
     *
     * 在插件中使用：需要基础库 `2.11.0`
     *
     * 创建视频解码器，可逐帧获取解码后的数据
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/video-decoder/wx.createVideoDecoder.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/video-decoder/wx.createVideoDecoder.html)
     */
    createVideoDecoder(): UniNamespace.VideoDecoder;
    /**
     *
     * 需要基础库： `2.19.0`
     *
     * 在插件中使用：不支持
     *
     * 创建 WebAudio 上下文。
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/wx.createWebAudioContext.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/wx.createWebAudioContext.html)
     */
    createWebAudioContext(): UniNamespace.WebAudioContext;
    /**
     *
     * 需要基础库： `2.29.2`
     *
     * 在插件中使用：不支持
     *
     * 返回当前是否存在小窗播放（小窗在 video/live-player/live-pusher 下可用）
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/ui/window/wx.checkIsPictureInPictureActive.html](https://developers.weixin.qq.com/miniprogram/dev/api/ui/window/wx.checkIsPictureInPictureActive.html)
     */
    checkIsPictureInPictureActive(): boolean;
    /**
     *
     * 需要基础库： `2.22.0`
     *
     * 在插件中使用：需要基础库 `2.22.0`
     *
     * 判断支持版本
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/wx.isVKSupport.html](https://developers.weixin.qq.com/miniprogram/dev/api/ai/visionkit/wx.isVKSupport.html)
     */
    isVKSupport(version: "v1" | "v2"): boolean;
    /**
     *
     * 需要基础库： `2.14.0`
     *
     * 在插件中使用：不支持
     *
     * 根据传入的 buffer 创建一个唯一的 URL 存在内存中
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/storage/wx.createBufferURL.html](https://developers.weixin.qq.com/miniprogram/dev/api/storage/wx.createBufferURL.html)
     */
    createBufferURL(buffer: ArrayBuffer | Float32Array | Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float64Array): string;
    /**
     *
     * 需要基础库： `2.33.0`
     *
     * 在插件中使用：不支持
     *
     * 获取当前 API 类别
     *
     * **不同 apiCategory 场景下的 API 限制**
     *
     * `X` 表示 API 被限制无法使用；不在表格中的 API 不限制。
     *
     * |                                       | default | nativeFunctionalized | browseOnly | embedded | chatTool |
     * |-|-|-|-|-|--|
     * |openSetting                            |         |                      | `X`        |          |      |
     * |&lt;button open-type="share"&gt;       |         | `X`                  | `X`        | `X`      |  `X` |
     * |&lt;button open-type="feedback"&gt;    |         |                      | `X`        |          |      |
     * |&lt;button open-type="open-setting"&gt;|         |                      | `X`        |          |      |
     * |navigateToMiniProgram                  |         | `X`                  | `X`        |          |  `X` |
     * |openEmbeddedMiniProgram                |         | `X`                  | `X`        | `X`      |  `X` |
     * |openOfficialAccountArticle             |         |                      |            |          |  `X` |
     * |openChannelsUserProfile                |         |                      |            |          |  `X` |
     * |ad                                     |         |                      |            |          |  `X` |
     * |ad-custom                              |         |                      |            |          |  `X` |
     * |小程序菜单分享                            |         |                      |            |          |  `X` |
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/app/life-cycle/wx.getApiCategory.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/app/life-cycle/wx.getApiCategory.html)
     */
    getApiCategory(): string;
    /**
     *
     * 需要基础库： `1.1.0`
     *
     * 在插件中使用：不支持
     *
     * 批量添加卡券。只有通过 [认证](https://developers.weixin.qq.com/miniprogram/product/renzheng.html) 的小程序或文化互动类目的小游戏才能使用。更多文档请参考 [微信卡券接口文档](https://mp.weixin.qq.com/cgi-bin/announce?action=getannouncement&key=1490190158&version=1&lang=zh_CN&platform=2)。
     *
     * **cardExt 说明**
     *
     * cardExt 是卡券的扩展参数，其值是一个 JSON 字符串。
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/open-api/card/wx.addCard.html](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/card/wx.addCard.html)
     */
    addCard(option: UniNamespace.AddCardOption): void;
    /**
     *
     * 需要基础库： `2.16.1`
     *
     * 在插件中使用：不支持
     *
     * 收藏文件
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/open-api/favorites/wx.addFileToFavorites.html](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/favorites/wx.addFileToFavorites.html)
     */
    addFileToFavorites(option: UniNamespace.AddFileToFavoritesOption): void;
    /**
     *
     * 需要基础库： `2.15.0`
     *
     * 在插件中使用：不支持
     *
     * 向系统日历添加事件
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/calendar/wx.addPhoneCalendar.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/calendar/wx.addPhoneCalendar.html)
     */
    addPhoneCalendar(option: UniNamespace.AddPhoneCalendarOption): void;
    /**
     *
     * 需要基础库： `2.15.0`
     *
     * 在插件中使用：不支持
     *
     * 向系统日历添加重复事件
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/calendar/wx.addPhoneRepeatCalendar.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/calendar/wx.addPhoneRepeatCalendar.html)
     */
    addPhoneRepeatCalendar(option: UniNamespace.AddPhoneRepeatCalendarOption): void;
    /**
     *
     * 需要基础库： `2.16.1`
     *
     * 在插件中使用：不支持
     *
     * 收藏视频
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/open-api/favorites/wx.addVideoToFavorites.html](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/favorites/wx.addVideoToFavorites.html)
     */
    addVideoToFavorites(option: UniNamespace.AddVideoToFavoritesOption): void;
    /**
     *
     * 需要基础库： `2.13.0`
     *
     * 在插件中使用：不支持
     *
     * 验证私密消息。用法详情见 [小程序私密消息使用指南](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/share/private-message.html)
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/share/wx.authPrivateMessage.html](https://developers.weixin.qq.com/miniprogram/dev/api/share/wx.authPrivateMessage.html)
     */
    authPrivateMessage(option?: UniNamespace.AuthPrivateMessageOption): void;
    /**
     *
     * 需要基础库： `2.14.4`
     *
     * 在插件中使用：需要基础库 `2.14.4`
     *
     * **仅小程序插件中能调用该接口**，用法同 [uni.authorize](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/authorize/wx.authorize.html)。目前仅支持三种 scope（见下）
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/open-api/authorize/wx.authorizeForMiniProgram.html](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/authorize/wx.authorizeForMiniProgram.html)
     */
    authorizeForMiniProgram(option: UniNamespace.AuthorizeForMiniProgramOption): void;
    /**
     *
     * 需要基础库： `2.25.0`
     *
     * 在插件中使用：不支持
     *
     * 从本地缓存中异步批量获取指定 key 的内容。
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/storage/wx.batchGetStorage.html](https://developers.weixin.qq.com/miniprogram/dev/api/storage/wx.batchGetStorage.html)
     */
    batchGetStorage(option: UniNamespace.BatchGetStorageOption): void;
    /**
     *
     * 需要基础库： `2.25.0`
     *
     * 在插件中使用：不支持
     *
     * 将数据批量存储在本地缓存中指定的 key 中。会覆盖掉原来该 key 对应的内容。除非用户主动删除或因存储空间原因被系统清理，否则数据都一直可用。单个 key 允许存储的最大数据长度为 1MB，所有数据存储上限为 10MB。
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/storage/wx.batchSetStorage.html](https://developers.weixin.qq.com/miniprogram/dev/api/storage/wx.batchSetStorage.html)
     */
    batchSetStorage(option: UniNamespace.BatchSetStorageOption): void;
    /**
     *
     * 需要基础库： `2.25.0`
     *
     * 在插件中使用：不支持
     *
     * 将数据批量存储在本地缓存中指定的 key 中。会覆盖掉原来该 key 对应的内容。除非用户主动删除或因存储空间原因被系统清理，否则数据都一直可用。单个 key 允许存储的最大数据长度为 1MB，所有数据存储上限为 10MB。
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/storage/wx.batchSetStorageSync.html](https://developers.weixin.qq.com/miniprogram/dev/api/storage/wx.batchSetStorageSync.html)
     */
    batchSetStorageSync(kvList: UniNamespace.KvList[]): void;
    /**
     *
     * 在插件中使用：不支持
     *
     * 查询设备是否支持 H.265 编码
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/video/wx.checkDeviceSupportHevc.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/video/wx.checkDeviceSupportHevc.html)
     */
    checkDeviceSupportHevc(option?: UniNamespace.CheckDeviceSupportHevcOption): void;
    /**
     *
     * 需要基础库： `2.29.1`
     *
     * 在插件中使用：不支持
     *
     * 检查小程序是否被添加至 「我的小程序」
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/open-api/my-miniprogram/wx.checkIsAddedToMyMiniProgram.html](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/my-miniprogram/wx.checkIsAddedToMyMiniProgram.html)
     */
    checkIsAddedToMyMiniProgram(option: UniNamespace.CheckIsAddedToMyMiniProgramOption): void;
    /**
     *
     * 需要基础库： `2.13.0`
     *
     * 在插件中使用：不支持
     *
     * 检测是否开启视觉无障碍功能。
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/accessibility/wx.checkIsOpenAccessibility.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/accessibility/wx.checkIsOpenAccessibility.html)
     */
    checkIsOpenAccessibility(option?: UniNamespace.CheckIsOpenAccessibilityOption): void;
    /**
     *
     * 需要基础库： `2.8.0`
     *
     * 在插件中使用：不支持
     *
     * 拉起手机通讯录，选择联系人。
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/contact/wx.chooseContact.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/contact/wx.chooseContact.html)
     */
    chooseContact(option?: UniNamespace.ChooseContactOption): void;
    /**
     *
     * 需要基础库： `2.3.0`
     *
     * 在插件中使用：需要基础库 `2.16.1`
     *
     * 选择用户已有的发票。
     *
     * **通过 cardId 和 encryptCode 获得报销发票的信息**
     *
     * 请参考[微信电子发票文档](https://mp.weixin.qq.com/wiki?t=resource/res_main&id=21517918939oae3U)中，「查询报销发票信息」部分。
     * 其中 `access_token` 的获取请参考[auth.getAccessToken](#)文档
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/open-api/invoice/wx.chooseInvoice.html](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/invoice/wx.chooseInvoice.html)
     */
    chooseInvoice(option?: UniNamespace.ChooseInvoiceOption): void;
    /**
     *
     * 需要基础库： `2.19.0`
     *
     * 在插件中使用：不支持
     *
     * 选择车牌号
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/open-api/license-plate/wx.chooseLicensePlate.html](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/license-plate/wx.chooseLicensePlate.html)
     */
    chooseLicensePlate(option?: UniNamespace.ChooseLicensePlateOption): void;
    /**
     *
     * 需要基础库： `2.10.0`
     *
     * 在插件中使用：需要基础库 `2.11.1`
     *
     * 拍摄或从手机相册中选择图片或视频。
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/video/wx.chooseMedia.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/video/wx.chooseMedia.html)
     */
    chooseMedia(option: UniNamespace.ChooseMediaOption): void;
    /**
     *
     * 需要基础库： `2.5.0`
     *
     * 在插件中使用：不支持
     *
     * 从客户端会话选择文件。
     *
     * ****
     *
     * ```js
     * wx.chooseMessageFile({
     * count: 10,
     * type: 'image',
     * success (res) {
     * // tempFilePath可以作为img标签的src属性显示图片
     * const tempFilePaths = res.tempFiles
     * }
     * })
     * ```
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/image/wx.chooseMessageFile.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/image/wx.chooseMessageFile.html)
     */
    chooseMessageFile(option: UniNamespace.ChooseMessageFileOption): void;
    /**
     *
     * 在插件中使用：不支持
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/location/wx.choosePoi.html](https://developers.weixin.qq.com/miniprogram/dev/api/location/wx.choosePoi.html)
     */
    choosePoi(option: UniNamespace.ChoosePoiOption): void;
    /**
     *
     * 需要基础库： `2.10.3`
     *
     * 在插件中使用：需要基础库 `2.22.1`
     *
     * 建立本地作为蓝牙低功耗外围设备的服务端，可创建多个。
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth-peripheral/wx.createBLEPeripheralServer.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth-peripheral/wx.createBLEPeripheralServer.html)
     */
    createBLEPeripheralServer(option?: UniNamespace.CreateBLEPeripheralServerOption): void;
    /**
     *
     * 需要基础库： `2.26.0`
     *
     * 在插件中使用：不支持
     *
     * 裁剪图片接口
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/image/wx.cropImage.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/image/wx.cropImage.html)
     */
    cropImage(option: UniNamespace.CropImageOption): void;
    /**
     *
     * 需要基础库： `2.12.0`
     *
     * 在插件中使用：不支持
     *
     * 关闭小程序页面返回询问对话框。
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/ui/interaction/wx.disableAlertBeforeUnload.html](https://developers.weixin.qq.com/miniprogram/dev/api/ui/interaction/wx.disableAlertBeforeUnload.html)
     */
    disableAlertBeforeUnload(option?: UniNamespace.DisableAlertBeforeUnloadOption): void;
    /**
     *
     * 需要基础库： `2.22.0`
     *
     * 在插件中使用：不支持
     *
     * 编辑图片接口
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/image/wx.editImage.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/image/wx.editImage.html)
     */
    editImage(option: UniNamespace.EditImageOption): void;
    /**
     *
     * 需要基础库： `2.12.0`
     *
     * 在插件中使用：不支持
     *
     * 开启小程序页面返回询问对话框。
     *
     * ## 弹窗条件
     * * 当用户在小程序内非首页页面/最底层页
     * * 官方导航栏上的的返回
     * * 全屏模式下自绘返回键
     * * android 系统 back 键时
     *
     * ## 注意事项
     * * 手势滑动返回时不做拦截
     * * 在任何场景下，此功能都不应拦住用户退出小程序的行为
     *
     * **示例代码**
     *
     * [在微信开发者工具中查看示例](https://developers.weixin.qq.com/s/MTPm9Cmh7VfT)
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/ui/interaction/wx.enableAlertBeforeUnload.html](https://developers.weixin.qq.com/miniprogram/dev/api/ui/interaction/wx.enableAlertBeforeUnload.html)
     */
    enableAlertBeforeUnload(option: UniNamespace.EnableAlertBeforeUnloadOption): void;
    /**
     *
     * 需要基础库： `2.17.3`
     *
     * 在插件中使用：需要基础库 `2.30.1`
     *
     * 退出当前小程序
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/navigate/wx.exitMiniProgram.html](https://developers.weixin.qq.com/miniprogram/dev/api/navigate/wx.exitMiniProgram.html)
     */
    exitMiniProgram(option?: UniNamespace.ExitMiniProgramOption): void;
    /**
     *
     * 需要基础库： `2.7.0`
     *
     * 在插件中使用：需要基础库 `2.9.0`
     *
     * 退出（销毁）实时语音通话
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/voip/wx.exitVoIPChat.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/voip/wx.exitVoIPChat.html)
     */
    exitVoIPChat(option?: UniNamespace.ExitVoIPChatOption): void;
    /**
     *
     * 需要基础库： `2.18.0`
     *
     * 在插件中使用：需要基础库 `2.21.3`
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/ai/face/wx.faceDetect.html](https://developers.weixin.qq.com/miniprogram/dev/api/ai/face/wx.faceDetect.html)
     */
    faceDetect(option: UniNamespace.FaceDetectOption): void;
    /**
     *
     * 需要基础库： `2.1.0`
     *
     * 在插件中使用：需要基础库 `2.15.0`
     *
     * 获取当前支持的音频输入源
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/wx.getAvailableAudioSources.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/wx.getAvailableAudioSources.html)
     */
    getAvailableAudioSources(option?: UniNamespace.GetAvailableAudioSourcesOption): void;
    /**
     *
     * 需要基础库： `2.20.1`
     *
     * 在插件中使用：需要基础库 `2.20.1`
     *
     * 获取蓝牙低功耗的最大传输单元。需在 [uni.createBLEConnection](https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth-ble/wx.createBLEConnection.html) 调用成功后调用。
     *
     * **注意**
     *
     * - 小程序中 MTU 为 ATT_MTU，包含 Op-Code 和 Attribute Handle 的长度，实际可以传输的数据长度为 `ATT_MTU - 3`
     * - iOS 系统中 MTU 为固定值；安卓系统中，MTU 会在系统协商成功之后发生改变，建议使用 [uni.onBLEMTUChange](https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth-ble/wx.onBLEMTUChange.html) 监听。
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth-ble/wx.getBLEMTU.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth-ble/wx.getBLEMTU.html)
     */
    getBLEMTU(option: UniNamespace.GetBLEMTUOption): void;
    /**
     *
     * 在插件中使用：需要基础库 `1.9.6`
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/background-audio/wx.getBackgroundAudioPlayerState.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/background-audio/wx.getBackgroundAudioPlayerState.html)
     */
    getBackgroundAudioPlayerState(option?: UniNamespace.GetBackgroundAudioPlayerStateOption): void;
    /**
     *
     * 需要基础库： `2.8.0`
     *
     * 在插件中使用：不支持
     *
     * 拉取 backgroundFetch 客户端缓存数据。
     * 当调用接口时，若当次请求未结束，会先返回本地的旧数据（之前打开小程序时请求的），如果本地没有旧数据，安卓上会返回fail，不会等待请求完成，iOS上会返回success但fetchedData为空，也不会等待请求完成。建议和 [uni.onBackgroundFetchData](https://developers.weixin.qq.com/miniprogram/dev/api/storage/background-fetch/wx.onBackgroundFetchData.html) 配合使用。
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/storage/background-fetch/wx.getBackgroundFetchData.html](https://developers.weixin.qq.com/miniprogram/dev/api/storage/background-fetch/wx.getBackgroundFetchData.html)
     */
    getBackgroundFetchData(option: UniNamespace.GetBackgroundFetchDataOption): void;
    /**
     *
     * 需要基础库： `2.8.0`
     *
     * 在插件中使用：不支持
     *
     * 获取设置过的自定义登录态。若无，则返回 fail。
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/storage/background-fetch/wx.getBackgroundFetchToken.html](https://developers.weixin.qq.com/miniprogram/dev/api/storage/background-fetch/wx.getBackgroundFetchToken.html)
     */
    getBackgroundFetchToken(option?: UniNamespace.GetBackgroundFetchTokenOption): void;
    /**
     *
     * 需要基础库： `2.15.0`
     *
     * 在插件中使用：不支持
     *
     * 获取视频号直播信息
     *
     * **常见错误码说明**
     *
     * 100008  视频号需要认证
     * 40097 入参异常
     * 1416104  视频号获取到的数据为空
     * 1416100  非法的视频号id
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/open-api/channels/wx.getChannelsLiveInfo.html](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/channels/wx.getChannelsLiveInfo.html)
     */
    getChannelsLiveInfo(option: UniNamespace.GetChannelsLiveInfoOption): void;
    /**
     *
     * 需要基础库： `2.19.0`
     *
     * 在插件中使用：不支持
     *
     * 获取视频号直播预告信息
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/open-api/channels/wx.getChannelsLiveNoticeInfo.html](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/channels/wx.getChannelsLiveNoticeInfo.html)
     */
    getChannelsLiveNoticeInfo(option: UniNamespace.GetChannelsLiveNoticeInfoOption): void;
    /**
     *
     * 需要基础库： `2.22.1`
     *
     * 在插件中使用：不支持
     *
     * 获取视频号直播卡片/视频卡片的分享来源，仅当卡片携带了分享信息、同时用户已授权该小程序获取视频号分享信息且启动场景值为 1177、1184、1195、1208 时可用。
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/open-api/channels/wx.getChannelsShareKey.html](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/channels/wx.getChannelsShareKey.html)
     */
    getChannelsShareKey(option?: UniNamespace.GetChannelsShareKeyOption): void;
    /**
     *
     * 需要基础库： `3.7.8`
     *
     * 在插件中使用：不支持
     *
     * 获取聊天工具模式下的群聊信息。
     *
     * 需要注意的是，单聊群和多聊群下返回的群唯一标识是不同的。
     * 1. 多聊群下返回 opengid
     * 2. 单聊群下返回 open_single_roomid
     *
     * 同时将返回用户在群(含单聊)下的唯一标识 group_openid。
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/chattool/wx.getChatToolInfo.html](https://developers.weixin.qq.com/miniprogram/dev/api/chattool/wx.getChatToolInfo.html)
     */
    getChatToolInfo(option: UniNamespace.GetChatToolInfoOption): void;
    /**
     *
     * 需要基础库： `2.33.0`
     *
     * 在插件中使用：不支持
     *
     * 给定实验参数数组，获取对应的实验参数值。
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/data-analysis/wx.getCommonConfig.html](https://developers.weixin.qq.com/miniprogram/dev/api/data-analysis/wx.getCommonConfig.html)
     */
    getCommonConfig(option: UniNamespace.GetCommonConfigOption): void;
    /**
     *
     * 需要基础库： `3.4.5`
     *
     * 在插件中使用：不支持
     *
     * 获取设备性能得分和机型档位数据
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/system/wx.getDeviceBenchmarkInfo.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/system/wx.getDeviceBenchmarkInfo.html)
     */
    getDeviceBenchmarkInfo(option?: UniNamespace.GetDeviceBenchmarkInfoOption): void;
    /**
     *
     * 需要基础库： `2.30.3`
     *
     * 在插件中使用：不支持
     *
     * 查询当前用户授权的音视频通话设备（组）信息
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/open-api/device-voip/wx.getDeviceVoIPList.html](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/device-voip/wx.getDeviceVoIPList.html)
     */
    getDeviceVoIPList(option?: UniNamespace.GetDeviceVoIPListOption): void;
    /**
     *
     * 需要基础库： `2.25.0`
     *
     * 在插件中使用：支持
     *
     * 获取当前的模糊地理位置。
     * ## 使用方法
     * 自 2022 年 7 月 14 日后发布的小程序，若使用该接口，需要在 app.json 中进行声明，否则将无法正常使用该接口，2022年7月14日前发布的小程序不受影响。[具体规则见公告](https://developers.weixin.qq.com/community/develop/doc/000a02f2c5026891650e7f40351c01)
     * ## 申请开通
     * 暂只针对具备与地理位置强相关的使用场景的小程序开放，在小程序管理后台，「开发」-「开发管理」-「接口设置」中自助开通该接口权限。 从2022年7月14日开始在代码审核环节将检测该接口是否已完成开通，如未开通，将在代码提审环节进行拦截。
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/location/wx.getFuzzyLocation.html](https://developers.weixin.qq.com/miniprogram/dev/api/location/wx.getFuzzyLocation.html)
     */
    getFuzzyLocation(option: UniNamespace.GetFuzzyLocationOption): void;
    /**
     *
     * 需要基础库： `2.10.4`
     *
     * 在插件中使用：不支持
     *
     * 获取微信群聊场景下的小程序启动信息。群聊场景包括群聊小程序消息卡片、群待办、群工具。可用于获取当前群的 opengid。
     * ## 注意事项
     * - 基础库 v2.10.4 开始支持获取群工具小程序启动信息
     * - 基础库 v2.17.3 开始支持获取群聊小程序消息卡片、群待办小程序启动信息
     * - 基础库 v3.7.8 支持获取单聊群启动信息，获取的群(含单聊)唯一标识，可用于[聊天工具模式](https://developers.weixin.qq.com/miniprogram/dev/api/chattool/wx.openChatTool.html)。
     *
     *
     * **Tips**
     *
     * - 如需要展示群名称，小程序可以使用[开放数据组件](https://developers.weixin.qq.com/miniprogram/dev/component/open-ability/open-data.html)
     * - 小游戏可以通过 `wx.getGroupInfo` 接口获取群名称
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/open-api/group/wx.getGroupEnterInfo.html](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/group/wx.getGroupEnterInfo.html)
     */
    getGroupEnterInfo(option: UniNamespace.GetGroupEnterInfoOption): void;
    /**
     *
     * 需要基础库： `1.7.0`
     *
     * 在插件中使用：需要基础库 `2.1.0`
     *
     * 判断当前设备是否支持 HCE 能力。
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc-hce/wx.getHCEState.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc-hce/wx.getHCEState.html)
     */
    getHCEState(option?: UniNamespace.GetHCEStateOption): void;
    /**
     *
     * 需要基础库： `2.30.1`
     *
     * 在插件中使用：需要基础库 `2.30.1`
     *
     * 获取通用AI推理引擎版本。使用前可参考[AI指南文档](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/inference/tutorial.html)
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/ai/inference/wx.getInferenceEnvInfo.html](https://developers.weixin.qq.com/miniprogram/dev/api/ai/inference/wx.getInferenceEnvInfo.html)
     */
    getInferenceEnvInfo(option?: UniNamespace.GetInferenceEnvInfoOption): void;
    /**
     *
     * 需要基础库： `2.20.1`
     *
     * 在插件中使用：需要基础库 `2.21.3`
     *
     * 获取局域网IP地址
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/network/wx.getLocalIPAddress.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/network/wx.getLocalIPAddress.html)
     */
    getLocalIPAddress(option: UniNamespace.GetLocalIPAddressOption): void;
    /**
     *
     * 需要基础库： `2.32.3`
     *
     * 在插件中使用：不支持
     *
     * 查询隐私授权情况。隐私合规开发指南详情可见[《小程序隐私协议开发指南》](https://developers.weixin.qq.com/miniprogram/dev/framework/user-privacy/PrivacyAuthorize.html)
     *
     * ****
     *
     * ## 具体说明：
     *
     * 1. 一定要调用 wx.getPrivacySetting 接口吗？
     *
     * - 不是，wx.getPrivacySetting 只是一个辅助接口，可以根据实际情况选择使用。
     *
     *
     * **完整示例demo**
     *
     * demo1: 演示使用 `wx.getPrivacySetting` 和 `<button open-type="agreePrivacyAuthorization">` 在首页处理隐私弹窗逻辑
     * [https://developers.weixin.qq.com/s/gi71sGm67hK0](https://developers.weixin.qq.com/s/gi71sGm67hK0)
     *
     * demo2: 演示使用 `wx.onNeedPrivacyAuthorization` 和 `<button open-type="agreePrivacyAuthorization">` 在多个页面处理隐私弹窗逻辑，同时演示了如何处理多个隐私接口同时调用。
     * [https://developers.weixin.qq.com/s/hndZUOmA7gKn](https://developers.weixin.qq.com/s/hndZUOmA7gKn)
     *
     * demo3: 演示 `wx.onNeedPrivacyAuthorization`、`wx.requirePrivacyAuthorize`、`<button open-type="agreePrivacyAuthorization">` 和 `<input type="nickname">` 组件如何结合使用
     * [https://developers.weixin.qq.com/s/jX7xWGmA7UKa](https://developers.weixin.qq.com/s/jX7xWGmA7UKa)
     *
     * demo4: 演示使用 `wx.onNeedPrivacyAuthorization` 和 `<button open-type="agreePrivacyAuthorization">` 在多个 tabBar 页面处理隐私弹窗逻辑。
     * [https://developers.weixin.qq.com/s/g6BWZGmt7XK9](https://developers.weixin.qq.com/s/g6BWZGmt7XK9)
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/open-api/privacy/wx.getPrivacySetting.html](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/privacy/wx.getPrivacySetting.html)
     */
    getPrivacySetting(option: UniNamespace.GetPrivacySettingOption): void;
    /**
     *
     * 需要基础库： `2.15.0`
     *
     * 在插件中使用：不支持
     *
     * 获取密码学安全随机数
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/crypto/wx.getRandomValues.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/crypto/wx.getRandomValues.html)
     */
    getRandomValues(option: UniNamespace.GetRandomValuesOption): void;
    /**
     *
     * 需要基础库： `2.24.0`
     *
     * 在插件中使用：不支持
     *
     * 查询用户是否在录屏。
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/screen/wx.getScreenRecordingState.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/screen/wx.getScreenRecordingState.html)
     */
    getScreenRecordingState(option?: UniNamespace.GetScreenRecordingStateOption): void;
    /**
     *
     * 需要基础库： `1.1.0`
     *
     * 在插件中使用：需要基础库 `2.1.0`
     *
     * 在插件中使用时，只能在当前插件的页面中调用
     *
     * 获取转发详细信息（主要是获取群ID）。 从群聊内的小程序消息卡片打开小程序时，调用此接口才有效。从基础库 v2.17.3 开始，推荐用 [uni.getGroupEnterInfo](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/group/wx.getGroupEnterInfo.html) 替代此接口。
     *
     *
     * **Tips**
     *
     * - 如需要展示群名称，小程序可以使用 [开放数据组件](https://developers.weixin.qq.com/miniprogram/dev/component/open-ability/open-data.html)
     * - 小游戏可以通过 [`wx.getGroupInfo`](#) 接口获取群名称
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/share/wx.getShareInfo.html](https://developers.weixin.qq.com/miniprogram/dev/api/share/wx.getShareInfo.html)
     */
    getShareInfo(option: UniNamespace.GetShareInfoOption): void;
    /**
     *
     * 需要基础库： `3.7.8`
     *
     * 在插件中使用：需要基础库 `3.7.8`
     *
     * 获取封面广告组件展示状态。请通过 [uni.getSystemInfoSync()](https://developers.weixin.qq.com/miniprogram/dev/api/base/system/wx.getSystemInfoSync.html) 返回对象的 SDKVersion 判断基础库版本号后再使用该 API（小游戏端要求 >= 3.7.8， 小程序端要求 >= 3.7.8）。
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/ad/wx.getShowSplashAdStatus.html](https://developers.weixin.qq.com/miniprogram/dev/api/ad/wx.getShowSplashAdStatus.html)
     */
    getShowSplashAdStatus(option?: UniNamespace.GetShowSplashAdStatusOption): void;
    /**
     *
     * 需要基础库： `2.26.2`
     *
     * 在插件中使用：需要基础库 `2.26.2`
     *
     * 获取当前运行环境对于 [Skyline 渲染引擎](https://developers.weixin.qq.com/miniprogram/dev/framework/runtime/skyline/introduction.html) 的支持情况
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/system/wx.getSkylineInfo.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/system/wx.getSkylineInfo.html)
     */
    getSkylineInfo(option?: UniNamespace.GetSkylineInfoOption): void;
    /**
     *
     * 需要基础库： `2.14.1`
     *
     * 在插件中使用：不支持
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/system/wx.getSystemInfoAsync.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/system/wx.getSystemInfoAsync.html)
     */
    getSystemInfoAsync(option?: UniNamespace.GetSystemInfoAsyncOption): void;
    /**
     *
     * 需要基础库： `1.2.0`
     *
     * 在插件中使用：不支持
     *
     * 获取用户过去三十一天微信运动步数。需要先调用 [uni.login](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/login/wx.login.html) 接口。步数信息会在用户主动进入小程序时更新。
     *
     *
     * stepInfoList 中，每一项结构如下：
     *
     * | 属性 | 类型 | 说明 |
     * | --- | ---- | --- |
     * | timestamp | number | 时间戳，表示数据对应的时间 |
     * | step | number | 微信运动步数 |
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/open-api/werun/wx.getWeRunData.html](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/werun/wx.getWeRunData.html)
     */
    getWeRunData(option?: UniNamespace.GetWeRunDataOption): void;
    /**
     *
     * 需要基础库： `2.18.0`
     *
     * 在插件中使用：需要基础库 `2.21.3`
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/ai/face/wx.initFaceDetect.html](https://developers.weixin.qq.com/miniprogram/dev/api/ai/face/wx.initFaceDetect.html)
     */
    initFaceDetect(option?: UniNamespace.InitFaceDetectOption): void;
    /**
     *
     * 需要基础库： `2.20.1`
     *
     * 在插件中使用：需要基础库 `2.19.1`
     *
     * 查询蓝牙设备是否配对，仅安卓支持。
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth/wx.isBluetoothDevicePaired.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth/wx.isBluetoothDevicePaired.html)
     */
    isBluetoothDevicePaired(option: UniNamespace.IsBluetoothDevicePairedOption): void;
    /**
     *
     * 需要基础库： `2.20.1`
     *
     * 在插件中使用：不支持
     *
     * 加入（创建）双人通话。
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/voip/wx.join1v1Chat.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/voip/wx.join1v1Chat.html)
     */
    join1v1Chat(option: UniNamespace.Join1v1ChatOption): void;
    /**
     *
     * 需要基础库： `2.7.0`
     *
     * 在插件中使用：需要基础库 `2.9.0`
     *
     * 加入 (创建) 实时语音通话，更多信息可见 [实时语音指南](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/voip-chat.html)。调用前需要用户授权 `scope.record`，若房间类型为视频房间需要用户授权 `scope.camera`。
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/voip/wx.joinVoIPChat.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/voip/wx.joinVoIPChat.html)
     */
    joinVoIPChat(option: UniNamespace.JoinVoIPChatOption): void;
    /**
     *
     * 需要基础库： `3.7.9`
     *
     * 在插件中使用：需要基础库 `3.7.9`
     *
     * 加载内置字体。
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/ui/font/wx.loadBuiltInFontFace.html](https://developers.weixin.qq.com/miniprogram/dev/api/ui/font/wx.loadBuiltInFontFace.html)
     */
    loadBuiltInFontFace(option: UniNamespace.LoadBuiltInFontFaceOption): void;
    /**
     *
     * 需要基础库： `2.12.0`
     *
     * 在插件中使用：需要基础库 `2.12.0`
     *
     * 蓝牙配对接口，仅安卓支持。
     *
     * 通常情况下（需要指定 `pin` 码或者密码时）系统会接管配对流程，直接调用 [uni.createBLEConnection](https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth-ble/wx.createBLEConnection.html) 即可。该接口只应当在开发者不想让用户手动输入 `pin` 码且真机验证确认可以正常生效情况下用。
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth/wx.makeBluetoothPair.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth/wx.makeBluetoothPair.html)
     */
    makeBluetoothPair(option: UniNamespace.MakeBluetoothPairOption): void;
    /**
     *
     * 需要基础库： `3.7.8`
     *
     * 在插件中使用：不支持
     *
     * 提醒用户完成任务，标题长度不超过 30 个字符，支持中英文和数字，中文算2个字符。
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/chattool/wx.notifyGroupMembers.html](https://developers.weixin.qq.com/miniprogram/dev/api/chattool/wx.notifyGroupMembers.html)
     */
    notifyGroupMembers(option: UniNamespace.NotifyGroupMembersOption): void;
    /**
     *
     * 需要基础库： `3.5.5`
     *
     * 在插件中使用：需要基础库 `3.5.5`
     *
     * 移除路由事件的监听函数
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-route/wx.offAfterPageLoad.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-route/wx.offAfterPageLoad.html)
     */
    offAfterPageLoad(listener?: UniNamespace.OffAfterPageLoadCallback): void;
    /**
     *
     * 需要基础库： `3.5.5`
     *
     * 在插件中使用：需要基础库 `3.5.5`
     *
     * 移除路由事件的监听函数
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-route/wx.offAfterPageUnload.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-route/wx.offAfterPageUnload.html)
     */
    offAfterPageUnload(listener?: UniNamespace.OffAfterPageUnloadCallback): void;
    /**
     *
     * 需要基础库： `2.33.0`
     *
     * 在插件中使用：不支持
     *
     * 移除 API 类别变化事件的监听函数
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/app/life-cycle/wx.offApiCategoryChange.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/app/life-cycle/wx.offApiCategoryChange.html)
     */
    offApiCategoryChange(listener?: UniNamespace.OffApiCategoryChangeCallback): void;
    /**
     *
     * 需要基础库： `2.1.2`
     *
     * 在插件中使用：不支持
     *
     * 移除小程序切后台事件的监听函数
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-event/wx.offAppHide.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-event/wx.offAppHide.html)
     */
    offAppHide(listener?: UniNamespace.OffAppHideCallback): void;
    /**
     *
     * 需要基础库： `3.5.5`
     *
     * 在插件中使用：需要基础库 `3.5.5`
     *
     * 移除路由事件的监听函数
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-route/wx.offAppRoute.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-route/wx.offAppRoute.html)
     */
    offAppRoute(listener?: UniNamespace.OffAppRouteCallback): void;
    /**
     *
     * 需要基础库： `3.5.5`
     *
     * 在插件中使用：需要基础库 `3.5.5`
     *
     * 移除当前路由动画执行完成的事件的监听函数
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-route/wx.offAppRouteDone.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-route/wx.offAppRouteDone.html)
     */
    offAppRouteDone(listener?: UniNamespace.OffAppRouteDoneCallback): void;
    /**
     *
     * 需要基础库： `2.1.2`
     *
     * 在插件中使用：不支持
     *
     * 移除小程序切前台事件的监听函数
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-event/wx.offAppShow.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-event/wx.offAppShow.html)
     */
    offAppShow(listener?: UniNamespace.OffAppShowCallback): void;
    /**
     *
     * 需要基础库： `2.6.2`
     *
     * 在插件中使用：需要基础库 `2.15.0`
     *
     * 移除音频因为受到系统占用而被中断开始事件的监听函数
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-event/wx.offAudioInterruptionBegin.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-event/wx.offAudioInterruptionBegin.html)
     */
    offAudioInterruptionBegin(listener?: UniNamespace.OffAudioInterruptionBeginCallback): void;
    /**
     *
     * 需要基础库： `2.6.2`
     *
     * 在插件中使用：需要基础库 `2.15.0`
     *
     * 移除音频中断结束事件的监听函数
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-event/wx.offAudioInterruptionEnd.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-event/wx.offAudioInterruptionEnd.html)
     */
    offAudioInterruptionEnd(listener?: UniNamespace.OffAudioInterruptionEndCallback): void;
    /**
     *
     * 需要基础库： `2.9.0`
     *
     * 在插件中使用：需要基础库 `2.9.1`
     *
     * 移除蓝牙低功耗设备的特征值变化事件的全部监听函数
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth-ble/wx.offBLECharacteristicValueChange.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth-ble/wx.offBLECharacteristicValueChange.html)
     */
    offBLECharacteristicValueChange(): void;
    /**
     *
     * 需要基础库： `2.9.0`
     *
     * 在插件中使用：需要基础库 `2.9.1`
     *
     * 移除蓝牙低功耗连接状态改变事件的监听函数
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth-ble/wx.offBLEConnectionStateChange.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth-ble/wx.offBLEConnectionStateChange.html)
     */
    offBLEConnectionStateChange(listener?: UniNamespace.OffBLEConnectionStateChangeCallback): void;
    /**
     *
     * 需要基础库： `2.20.1`
     *
     * 在插件中使用：需要基础库 `2.20.1`
     *
     * 移除蓝牙低功耗的最大传输单元变化事件的监听函数
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth-ble/wx.offBLEMTUChange.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth-ble/wx.offBLEMTUChange.html)
     */
    offBLEMTUChange(listener?: UniNamespace.OffBLEMTUChangeCallback): void;
    /**
     *
     * 需要基础库： `2.10.3`
     *
     * 在插件中使用：需要基础库 `2.22.1`
     *
     * 移除当前外围设备被连接或断开连接事件的监听函数
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth-peripheral/wx.offBLEPeripheralConnectionStateChanged.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth-peripheral/wx.offBLEPeripheralConnectionStateChanged.html)
     */
    offBLEPeripheralConnectionStateChanged(listener?: UniNamespace.OffBLEPeripheralConnectionStateChangedCallback): void;
    /**
     *
     * 需要基础库： `3.5.0`
     *
     * 在插件中使用：不支持
     *
     * 移除电池信息变化事件的监听函数
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/battery/wx.offBatteryInfoChange.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/battery/wx.offBatteryInfoChange.html)
     */
    offBatteryInfoChange(listener?: UniNamespace.OffBatteryInfoChangeCallback): void;
    /**
     *
     * 需要基础库： `2.8.1`
     *
     * 在插件中使用：需要基础库 `2.9.1`
     *
     * 移除 Beacon 服务状态变化事件的全部监听函数
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/ibeacon/wx.offBeaconServiceChange.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/ibeacon/wx.offBeaconServiceChange.html)
     */
    offBeaconServiceChange(): void;
    /**
     *
     * 需要基础库： `2.8.1`
     *
     * 在插件中使用：需要基础库 `2.9.1`
     *
     * 移除 Beacon 设备更新事件的全部监听函数
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/ibeacon/wx.offBeaconUpdate.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/ibeacon/wx.offBeaconUpdate.html)
     */
    offBeaconUpdate(): void;
    /**
     *
     * 需要基础库： `3.5.5`
     *
     * 在插件中使用：需要基础库 `3.5.5`
     *
     * 移除路由事件的监听函数
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-route/wx.offBeforeAppRoute.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-route/wx.offBeforeAppRoute.html)
     */
    offBeforeAppRoute(listener?: UniNamespace.OffBeforeAppRouteCallback): void;
    /**
     *
     * 需要基础库： `3.5.5`
     *
     * 在插件中使用：需要基础库 `3.5.5`
     *
     * 移除路由事件的监听函数
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-route/wx.offBeforePageLoad.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-route/wx.offBeforePageLoad.html)
     */
    offBeforePageLoad(listener?: UniNamespace.OffBeforePageLoadCallback): void;
    /**
     *
     * 需要基础库： `3.5.5`
     *
     * 在插件中使用：需要基础库 `3.5.5`
     *
     * 移除路由事件的监听函数
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-route/wx.offBeforePageUnload.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-route/wx.offBeforePageUnload.html)
     */
    offBeforePageUnload(listener?: UniNamespace.OffBeforePageUnloadCallback): void;
    /**
     *
     * 需要基础库： `2.9.0`
     *
     * 在插件中使用：需要基础库 `2.9.1`
     *
     * 移除蓝牙适配器状态变化事件的全部监听函数
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth/wx.offBluetoothAdapterStateChange.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth/wx.offBluetoothAdapterStateChange.html)
     */
    offBluetoothAdapterStateChange(): void;
    /**
     *
     * 需要基础库： `2.9.0`
     *
     * 在插件中使用：需要基础库 `2.9.1`
     *
     * 移除搜索到新设备的事件的全部监听函数
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth/wx.offBluetoothDeviceFound.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth/wx.offBluetoothDeviceFound.html)
     */
    offBluetoothDeviceFound(): void;
    /**
     *
     * 需要基础库： `2.14.3`
     *
     * 在插件中使用：不支持
     *
     * 移除用户点击右上角菜单的「复制链接」按钮时触发的事件的全部监听函数
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/share/wx.offCopyUrl.html](https://developers.weixin.qq.com/miniprogram/dev/api/share/wx.offCopyUrl.html)
     */
    offCopyUrl(): void;
    /**
     *
     * 需要基础库： `2.9.3`
     *
     * 在插件中使用：需要基础库 `2.9.1`
     *
     * 移除设备方向变化事件的监听函数
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/motion/wx.offDeviceMotionChange.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/motion/wx.offDeviceMotionChange.html)
     */
    offDeviceMotionChange(listener?: UniNamespace.OffDeviceMotionChangeCallback): void;
    /**
     *
     * 需要基础库： `2.33.0`
     *
     * 在插件中使用：不支持
     *
     * 移除半屏小程序可视高度变化事件的监听函数
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/navigate/wx.offEmbeddedMiniProgramHeightChange.html](https://developers.weixin.qq.com/miniprogram/dev/api/navigate/wx.offEmbeddedMiniProgramHeightChange.html)
     */
    offEmbeddedMiniProgramHeightChange(listener?: UniNamespace.OffEmbeddedMiniProgramHeightChangeCallback): void;
    /**
     *
     * 需要基础库： `2.9.3`
     *
     * 在插件中使用：需要基础库 `2.9.1`
     *
     * 移除陀螺仪数据变化事件的监听函数
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/gyroscope/wx.offGyroscopeChange.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/gyroscope/wx.offGyroscopeChange.html)
     */
    offGyroscopeChange(listener?: UniNamespace.OffGyroscopeChangeCallback): void;
    /**
     *
     * 需要基础库： `2.8.1`
     *
     * 在插件中使用：需要基础库 `2.9.1`
     *
     * 移除接收 NFC 设备消息事件的监听函数
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc-hce/wx.offHCEMessage.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc-hce/wx.offHCEMessage.html)
     */
    offHCEMessage(listener?: UniNamespace.OffHCEMessageCallback): void;
    /**
     *
     * 需要基础库： `3.6.0`
     *
     * 在插件中使用：不支持
     *
     * 移除小程序全局键盘按键按下事件的监听函数
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/keyboard/wx.offKeyDown.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/keyboard/wx.offKeyDown.html)
     */
    offKeyDown(listener?: UniNamespace.OffKeyDownCallback): void;
    /**
     *
     * 需要基础库： `3.6.0`
     *
     * 在插件中使用：不支持
     *
     * 移除小程序全局键盘按键弹起事件的监听函数
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/keyboard/wx.offKeyUp.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/keyboard/wx.offKeyUp.html)
     */
    offKeyUp(listener?: UniNamespace.OffKeyUpCallback): void;
    /**
     *
     * 需要基础库： `2.24.3`
     *
     * 在插件中使用：不支持
     *
     * 移除小程序异步组件加载失败事件的监听函数
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-event/wx.offLazyLoadError.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-event/wx.offLazyLoadError.html)
     */
    offLazyLoadError(listener?: UniNamespace.OffLazyLoadErrorCallback): void;
    /**
     *
     * 需要基础库： `2.4.0`
     *
     * 在插件中使用：需要基础库 `2.15.0`
     *
     * 移除 mDNS 服务停止搜索的事件的监听函数
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/network/mdns/wx.offLocalServiceDiscoveryStop.html](https://developers.weixin.qq.com/miniprogram/dev/api/network/mdns/wx.offLocalServiceDiscoveryStop.html)
     */
    offLocalServiceDiscoveryStop(listener?: UniNamespace.OffLocalServiceDiscoveryStopCallback): void;
    /**
     *
     * 需要基础库： `2.4.0`
     *
     * 在插件中使用：需要基础库 `2.15.0`
     *
     * 移除 mDNS 服务发现的事件的监听函数
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/network/mdns/wx.offLocalServiceFound.html](https://developers.weixin.qq.com/miniprogram/dev/api/network/mdns/wx.offLocalServiceFound.html)
     */
    offLocalServiceFound(listener?: UniNamespace.OffLocalServiceFoundCallback): void;
    /**
     *
     * 需要基础库： `2.4.0`
     *
     * 在插件中使用：需要基础库 `2.15.0`
     *
     * 移除 mDNS 服务离开的事件的监听函数
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/network/mdns/wx.offLocalServiceLost.html](https://developers.weixin.qq.com/miniprogram/dev/api/network/mdns/wx.offLocalServiceLost.html)
     */
    offLocalServiceLost(listener?: UniNamespace.OffLocalServiceLostCallback): void;
    /**
     *
     * 需要基础库： `2.4.0`
     *
     * 在插件中使用：需要基础库 `2.15.0`
     *
     * 移除 mDNS 服务解析失败的事件的监听函数
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/network/mdns/wx.offLocalServiceResolveFail.html](https://developers.weixin.qq.com/miniprogram/dev/api/network/mdns/wx.offLocalServiceResolveFail.html)
     */
    offLocalServiceResolveFail(listener?: UniNamespace.OffLocalServiceResolveFailCallback): void;
    /**
     *
     * 需要基础库： `3.4.3`
     *
     * 在插件中使用：不支持
     *
     * 移除菜单按钮（右上角胶囊按钮）的布局位置信息变化事件的监听函数
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/ui/menu/wx.offMenuButtonBoundingClientRectWeightChange.html](https://developers.weixin.qq.com/miniprogram/dev/api/ui/menu/wx.offMenuButtonBoundingClientRectWeightChange.html)
     */
    offMenuButtonBoundingClientRectWeightChange(listener?: UniNamespace.OffMenuButtonBoundingClientRectWeightChangeCallback): void;
    /**
     *
     * 需要基础库： `2.21.0`
     *
     * 在插件中使用：不支持
     *
     * 移除弱网状态变化事件的监听函数
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/network/wx.offNetworkWeakChange.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/network/wx.offNetworkWeakChange.html)
     */
    offNetworkWeakChange(listener?: UniNamespace.OffNetworkWeakChangeCallback): void;
    /**
     *
     * 需要基础库： `3.7.9`
     *
     * 在插件中使用：不支持
     *
     * 移除用户触发小程序菜单中翻译功能的事件的监听函数
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/ui/menu/wx.offOnUserTriggerTranslation.html](https://developers.weixin.qq.com/miniprogram/dev/api/ui/menu/wx.offOnUserTriggerTranslation.html)
     */
    offOnUserTriggerTranslation(listener?: UniNamespace.OffOnUserTriggerTranslationCallback): void;
    /**
     *
     * 需要基础库： `2.1.2`
     *
     * 在插件中使用：不支持
     *
     * 移除小程序要打开的页面不存在事件的监听函数
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-event/wx.offPageNotFound.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-event/wx.offPageNotFound.html)
     */
    offPageNotFound(listener?: UniNamespace.OffPageNotFoundCallback): void;
    /**
     *
     * 需要基础库： `2.24.0`
     *
     * 在插件中使用：不支持
     *
     * 移除用户录屏事件的监听函数
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/screen/wx.offScreenRecordingStateChanged.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/screen/wx.offScreenRecordingStateChanged.html)
     */
    offScreenRecordingStateChanged(listener?: UniNamespace.OffScreenRecordingStateChangedCallback): void;
    /**
     *
     * 需要基础库： `2.9.0`
     *
     * 在插件中使用：需要基础库 `2.9.1`
     *
     * 移除被动断开实时语音通话事件的监听函数
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/voip/wx.offVoIPChatInterrupted.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/voip/wx.offVoIPChatInterrupted.html)
     */
    offVoIPChatInterrupted(listener?: UniNamespace.OffVoIPChatInterruptedCallback): void;
    /**
     *
     * 需要基础库： `2.9.0`
     *
     * 在插件中使用：需要基础库 `2.9.1`
     *
     * 移除实时语音通话成员在线状态变化事件的监听函数
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/voip/wx.offVoIPChatMembersChanged.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/voip/wx.offVoIPChatMembersChanged.html)
     */
    offVoIPChatMembersChanged(listener?: UniNamespace.OffVoIPChatMembersChangedCallback): void;
    /**
     *
     * 需要基础库： `2.9.0`
     *
     * 在插件中使用：需要基础库 `2.9.1`
     *
     * 移除实时语音通话成员通话状态变化事件的监听函数
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/voip/wx.offVoIPChatSpeakersChanged.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/voip/wx.offVoIPChatSpeakersChanged.html)
     */
    offVoIPChatSpeakersChanged(listener?: UniNamespace.OffVoIPChatSpeakersChangedCallback): void;
    /**
     *
     * 需要基础库： `2.16.0`
     *
     * 在插件中使用：不支持
     *
     * 移除房间状态变化事件的监听函数
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/voip/wx.offVoIPChatStateChanged.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/voip/wx.offVoIPChatStateChanged.html)
     */
    offVoIPChatStateChanged(listener?: UniNamespace.OffVoIPChatStateChangedCallback): void;
    /**
     *
     * 需要基础库： `2.11.0`
     *
     * 在插件中使用：不支持
     *
     * 移除实时语音通话成员视频状态变化事件的监听函数
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/voip/wx.offVoIPVideoMembersChanged.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/voip/wx.offVoIPVideoMembersChanged.html)
     */
    offVoIPVideoMembersChanged(listener?: UniNamespace.OffVoIPVideoMembersChangedCallback): void;
    /**
     *
     * 需要基础库： `3.5.5`
     *
     * 在插件中使用：需要基础库 `3.5.5`
     *
     * 监听路由事件引起新的页面实例化时，页面实例化完成的事件监听，详见 [页面路由监听](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/route-event-listener.html)。
     *
     * ****
     *
     * > 新旧版本小程序组件框架的说明详见：[glass-easel：新版微信小程序组件框架](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/glass-easel/introduction.html)
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-route/wx.onAfterPageLoad.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-route/wx.onAfterPageLoad.html)
     */
    onAfterPageLoad(listener: UniNamespace.OnAfterPageLoadCallback): void;
    /**
     *
     * 需要基础库： `3.5.5`
     *
     * 在插件中使用：需要基础库 `3.5.5`
     *
     * 监听路由事件引起现有页面实例销毁时，页面实例销毁后的事件监听，详见 [页面路由监听](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/route-event-listener.html)。
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-route/wx.onAfterPageUnload.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-route/wx.onAfterPageUnload.html)
     */
    onAfterPageUnload(listener: UniNamespace.OnAfterPageUnloadCallback): void;
    /**
     *
     * 需要基础库： `2.33.0`
     *
     * 在插件中使用：不支持
     *
     * 监听 API 类别变化事件
     *
     * **不同 apiCategory 场景下的 API 限制**
     *
     * `X` 表示 API 被限制无法使用；不在表格中的 API 不限制。
     *
     * |                                       | default | nativeFunctionalized | browseOnly | embedded | chatTool |
     * |-|-|-|-|-|--|
     * |openSetting                            |         |                      | `X`        |          |      |
     * |&lt;button open-type="share"&gt;       |         | `X`                  | `X`        | `X`      |  `X` |
     * |&lt;button open-type="feedback"&gt;    |         |                      | `X`        |          |      |
     * |&lt;button open-type="open-setting"&gt;|         |                      | `X`        |          |      |
     * |navigateToMiniProgram                  |         | `X`                  | `X`        |          |  `X` |
     * |openEmbeddedMiniProgram                |         | `X`                  | `X`        | `X`      |  `X` |
     * |openOfficialAccountArticle             |         |                      |            |          |  `X` |
     * |openChannelsUserProfile                |         |                      |            |          |  `X` |
     * |ad                                     |         |                      |            |          |  `X` |
     * |ad-custom                              |         |                      |            |          |  `X` |
     * |小程序菜单分享                            |         |                      |            |          |  `X` |
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/app/life-cycle/wx.onApiCategoryChange.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/app/life-cycle/wx.onApiCategoryChange.html)
     */
    onApiCategoryChange(listener: UniNamespace.OnApiCategoryChangeCallback): void;
    /**
     *
     * 需要基础库： `2.1.2`
     *
     * 在插件中使用：不支持
     *
     * 监听小程序切后台事件。该事件与 [`App.onHide`](https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html#onhide) 的回调参数一致。
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-event/wx.onAppHide.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-event/wx.onAppHide.html)
     */
    onAppHide(listener: UniNamespace.OnAppHideCallback): void;
    /**
     *
     * 需要基础库： `3.5.5`
     *
     * 在插件中使用：需要基础库 `3.5.5`
     *
     * 监听路由事件下发后，执行路由逻辑后的事件监听，详见 [页面路由监听](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/route-event-listener.html)。
     *
     * ****
     *
     * > Skyline 渲染引擎相关说明：[详情](https://developers.weixin.qq.com/miniprogram/dev/framework/runtime/skyline/introduction.html)
     * > xr-frame 解决方案相关说明：[详情](#)
     *
     * **注意**
     *
     * 在低于 3.5.5 版本的基础库中也存在此接口，但参数可能与当前文档不同，请注意。
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-route/wx.onAppRoute.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-route/wx.onAppRoute.html)
     */
    onAppRoute(listener: UniNamespace.OnAppRouteCallback): void;
    /**
     *
     * 需要基础库： `3.5.5`
     *
     * 在插件中使用：需要基础库 `3.5.5`
     *
     * 监听当前路由动画执行完成的事件监听，详见 [页面路由监听](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/route-event-listener.html)。
     *
     * **注意**
     *
     * 在低于 3.5.5 版本的基础库中也存在此接口，但参数可能与当前文档不同，请注意。
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-route/wx.onAppRouteDone.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-route/wx.onAppRouteDone.html)
     */
    onAppRouteDone(listener: UniNamespace.OnAppRouteDoneCallback): void;
    /**
     *
     * 需要基础库： `2.1.2`
     *
     * 在插件中使用：不支持
     *
     * 监听小程序切前台事件。该事件与 [`App.onShow`](https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html#onshowobject-object) 的回调参数一致。
     *
     * **返回有效 referrerInfo 的场景**
     *
     * | 场景值 | 场景                            | appId含义  |
     * | ------ | ------------------------------- | ---------- |
     * | 1020   | 公众号 profile 页相关小程序列表 | 来源公众号 |
     * | 1035   | 公众号自定义菜单                | 来源公众号 |
     * | 1036   | App 分享消息卡片                | 来源App    |
     * | 1037   | 小程序打开小程序                | 来源小程序 |
     * | 1038   | 从另一个小程序返回              | 来源小程序 |
     * | 1043   | 公众号模板消息                  | 来源公众号 |
     *
     * **不同 apiCategory 场景下的 API 限制**
     *
     * `X` 表示 API 被限制无法使用；不在表格中的 API 不限制。
     *
     * |                                       | default | nativeFunctionalized | browseOnly | embedded | chatTool |
     * |-|-|-|-|-|--|
     * |openSetting                            |         |                      | `X`        |          |      |
     * |&lt;button open-type="share"&gt;       |         | `X`                  | `X`        | `X`      |  `X` |
     * |&lt;button open-type="feedback"&gt;    |         |                      | `X`        |          |      |
     * |&lt;button open-type="open-setting"&gt;|         |                      | `X`        |          |      |
     * |navigateToMiniProgram                  |         | `X`                  | `X`        |          |  `X` |
     * |openEmbeddedMiniProgram                |         | `X`                  | `X`        | `X`      |  `X` |
     * |openOfficialAccountArticle             |         |                      |            |          |  `X` |
     * |openChannelsUserProfile                |         |                      |            |          |  `X` |
     * |ad                                     |         |                      |            |          |  `X` |
     * |ad-custom                              |         |                      |            |          |  `X` |
     * |小程序菜单分享                            |         |                      |            |          |  `X` |
     *
     * **注意**
     *
     * 部分版本在无`referrerInfo`的时候会返回 `undefined`，建议使用 `options.referrerInfo && options.referrerInfo.appId` 进行判断。
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-event/wx.onAppShow.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-event/wx.onAppShow.html)
     */
    onAppShow(listener: UniNamespace.OnAppShowCallback): void;
    /**
     *
     * 需要基础库： `2.6.2`
     *
     * 在插件中使用：需要基础库 `2.15.0`
     *
     * 监听音频因为受到系统占用而被中断开始事件。以下场景会触发此事件：闹钟、电话、FaceTime 通话、微信语音聊天、微信视频聊天、有声广告开始播放、实名认证页面弹出等。此事件触发后，小程序内所有音频会暂停。
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-event/wx.onAudioInterruptionBegin.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-event/wx.onAudioInterruptionBegin.html)
     */
    onAudioInterruptionBegin(listener: UniNamespace.OnAudioInterruptionBeginCallback): void;
    /**
     *
     * 需要基础库： `2.6.2`
     *
     * 在插件中使用：需要基础库 `2.15.0`
     *
     * 监听音频中断结束事件。在收到 onAudioInterruptionBegin 事件之后，小程序内所有音频会暂停，收到此事件之后才可再次播放成功
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-event/wx.onAudioInterruptionEnd.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-event/wx.onAudioInterruptionEnd.html)
     */
    onAudioInterruptionEnd(listener: UniNamespace.OnAudioInterruptionEndCallback): void;
    /**
     *
     * 需要基础库： `2.20.1`
     *
     * 在插件中使用：需要基础库 `2.20.1`
     *
     * 监听蓝牙低功耗的最大传输单元变化事件（仅安卓触发）。
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth-ble/wx.onBLEMTUChange.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth-ble/wx.onBLEMTUChange.html)
     */
    onBLEMTUChange(listener: UniNamespace.OnBLEMTUChangeCallback): void;
    /**
     *
     * 需要基础库： `2.10.3`
     *
     * 在插件中使用：需要基础库 `2.22.1`
     *
     * 监听当前外围设备被连接或断开连接事件
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth-peripheral/wx.onBLEPeripheralConnectionStateChanged.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth-peripheral/wx.onBLEPeripheralConnectionStateChanged.html)
     */
    onBLEPeripheralConnectionStateChanged(listener: UniNamespace.OnBLEPeripheralConnectionStateChangedCallback): void;
    /**
     *
     * 在插件中使用：不支持
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/background-audio/wx.onBackgroundAudioPause.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/background-audio/wx.onBackgroundAudioPause.html)
     */
    onBackgroundAudioPause(listener: UniNamespace.OnBackgroundAudioPauseCallback): void;
    /**
     *
     * 在插件中使用：不支持
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/background-audio/wx.onBackgroundAudioPlay.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/background-audio/wx.onBackgroundAudioPlay.html)
     */
    onBackgroundAudioPlay(listener: UniNamespace.OnBackgroundAudioPlayCallback): void;
    /**
     *
     * 在插件中使用：不支持
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/background-audio/wx.onBackgroundAudioStop.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/background-audio/wx.onBackgroundAudioStop.html)
     */
    onBackgroundAudioStop(listener: UniNamespace.OnBackgroundAudioStopCallback): void;
    /**
     *
     * 需要基础库： `2.8.0`
     *
     * 在插件中使用：不支持
     *
     * 监听收到 backgroundFetch 数据事件。如果监听时请求已经完成，则事件不会触发。建议和 [uni.getBackgroundFetchData](https://developers.weixin.qq.com/miniprogram/dev/api/storage/background-fetch/wx.getBackgroundFetchData.html) 配合使用
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/storage/background-fetch/wx.onBackgroundFetchData.html](https://developers.weixin.qq.com/miniprogram/dev/api/storage/background-fetch/wx.onBackgroundFetchData.html)
     */
    onBackgroundFetchData(listener: UniNamespace.OnBackgroundFetchDataCallback): void;
    /**
     *
     * 需要基础库： `3.5.0`
     *
     * 在插件中使用：不支持
     *
     * 监听电池信息变化事件，目前只支持监听省电模式的切换
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/battery/wx.onBatteryInfoChange.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/battery/wx.onBatteryInfoChange.html)
     */
    onBatteryInfoChange(listener: UniNamespace.OnBatteryInfoChangeCallback): void;
    /**
     *
     * 需要基础库： `3.5.5`
     *
     * 在插件中使用：需要基础库 `3.5.5`
     *
     * 监听路由事件下发后，执行路由逻辑前的事件监听，详见 [页面路由监听](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/route-event-listener.html)。
     *
     * ****
     *
     * > Skyline 渲染引擎相关说明：[详情](https://developers.weixin.qq.com/miniprogram/dev/framework/runtime/skyline/introduction.html)
     * > xr-frame 解决方案相关说明：[详情](#)
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-route/wx.onBeforeAppRoute.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-route/wx.onBeforeAppRoute.html)
     */
    onBeforeAppRoute(listener: UniNamespace.OnBeforeAppRouteCallback): void;
    /**
     *
     * 需要基础库： `3.5.5`
     *
     * 在插件中使用：需要基础库 `3.5.5`
     *
     * 监听路由事件引起新的页面实例化时，页面实例化前的事件监听，详见 [页面路由监听](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/route-event-listener.html)。
     *
     * ****
     *
     * > 新旧版本小程序组件框架的说明详见：[glass-easel：新版微信小程序组件框架](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/glass-easel/introduction.html)
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-route/wx.onBeforePageLoad.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-route/wx.onBeforePageLoad.html)
     */
    onBeforePageLoad(listener: UniNamespace.OnBeforePageLoadCallback): void;
    /**
     *
     * 需要基础库： `3.5.5`
     *
     * 在插件中使用：需要基础库 `3.5.5`
     *
     * 监听路由事件引起现有页面实例销毁时，页面实例销毁前的事件监听，详见 [页面路由监听](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/route-event-listener.html)。
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-route/wx.onBeforePageUnload.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-route/wx.onBeforePageUnload.html)
     */
    onBeforePageUnload(listener: UniNamespace.OnBeforePageUnloadCallback): void;
    /**
     *
     * 需要基础库： `2.14.3`
     *
     * 在插件中使用：不支持
     *
     * 监听用户点击右上角菜单的「复制链接」按钮时触发的事件。本接口为 Beta 版本，暂只在 Android 平台支持。
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/share/wx.onCopyUrl.html](https://developers.weixin.qq.com/miniprogram/dev/api/share/wx.onCopyUrl.html)
     */
    onCopyUrl(listener: UniNamespace.OnCopyUrlCallback): void;
    /**
     *
     * 需要基础库： `2.3.0`
     *
     * 在插件中使用：不支持
     *
     * 监听设备方向变化事件。频率根据 [uni.startDeviceMotionListening()](https://developers.weixin.qq.com/miniprogram/dev/api/device/motion/wx.startDeviceMotionListening.html) 的 interval 参数。可以使用 [uni.stopDeviceMotionListening()](https://developers.weixin.qq.com/miniprogram/dev/api/device/motion/wx.stopDeviceMotionListening.html) 停止监听。
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/motion/wx.onDeviceMotionChange.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/motion/wx.onDeviceMotionChange.html)
     */
    onDeviceMotionChange(listener: UniNamespace.OnDeviceMotionChangeCallback): void;
    /**
     *
     * 需要基础库： `2.33.0`
     *
     * 在插件中使用：不支持
     *
     * 监听半屏小程序可视高度变化事件
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/navigate/wx.onEmbeddedMiniProgramHeightChange.html](https://developers.weixin.qq.com/miniprogram/dev/api/navigate/wx.onEmbeddedMiniProgramHeightChange.html)
     */
    onEmbeddedMiniProgramHeightChange(listener: UniNamespace.OnEmbeddedMiniProgramHeightChangeCallback): void;
    /**
     *
     * 需要基础库： `1.7.0`
     *
     * 在插件中使用：需要基础库 `2.9.1`
     *
     * 监听接收 NFC 设备消息事件。仅能注册一个监听
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc-hce/wx.onHCEMessage.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc-hce/wx.onHCEMessage.html)
     */
    onHCEMessage(listener: UniNamespace.OnHCEMessageCallback): void;
    /**
     *
     * 需要基础库： `3.6.0`
     *
     * 在插件中使用：不支持
     *
     * 监听小程序全局键盘按键按下事件。仅适用于 PC 平台
     *
     * **注意事项**
     *
     * 1. 必须在小程序窗口处于前台且曾有过用户操作（例如点击等）后才会触发。
     * 2. 如某个快捷键组合已经被系统定义（例如 alt+F4、全屏时按 esc 退出等），则会优先响应系统操作，是否发送此事件取决于系统规则。
     * 3. 如当前焦点正聚焦在 `input`、`textarea`、`editor` 组件，则不会发送此事件。
     * 4. 如当前焦点在 webview 组件中，则不会发送此事件。
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/keyboard/wx.onKeyDown.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/keyboard/wx.onKeyDown.html)
     */
    onKeyDown(listener: UniNamespace.OnKeyDownCallback): void;
    /**
     *
     * 需要基础库： `3.6.0`
     *
     * 在插件中使用：不支持
     *
     * 监听小程序全局键盘按键弹起事件。仅适用于 PC 平台
     *
     * **注意事项**
     *
     * 1. 必须在小程序窗口处于前台且曾有过用户操作（例如点击等）后才会触发。
     * 2. 如某个快捷键组合已经被系统定义（例如 alt+F4、全屏时按 esc 退出等），则会优先响应系统操作，是否发送此事件取决于系统规则。
     * 3. 如当前焦点正聚焦在 `input`、`textarea`、`editor`  组件，则不会发送此事件。
     * 4. 如当前焦点在 webview 组件中，则不会发送此事件。
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/keyboard/wx.onKeyUp.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/keyboard/wx.onKeyUp.html)
     */
    onKeyUp(listener: UniNamespace.OnKeyUpCallback): void;
    /**
     *
     * 需要基础库： `2.24.3`
     *
     * 在插件中使用：不支持
     *
     * 监听小程序异步组件加载失败事件。
     *
     * **注意**
     *
     * - 加载异步组件通常需要下载分包，若分包下载超时，则会触发 errMsg 为 "loadSubpackage: timeout" 的回调，默认超时等待时间为 10 秒。
     * - 可以通过第二个参数指定超时时间（单位：ms），该设置全局有效，多次指定超时时间则覆盖前面。
     * - 分包确认下载失败时，会再次触发 errMsg 为 "loadSubpackage: fail" 的回调。
     * - 若在页面中使用该接口进行监听，请确保在必要时手动调用 offLazyLoadError 取消监听，以避免非预期的内存泄漏。
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-event/wx.onLazyLoadError.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-event/wx.onLazyLoadError.html)
     */
    onLazyLoadError(listener: UniNamespace.OnLazyLoadErrorCallback): void;
    /**
     *
     * 需要基础库： `2.4.0`
     *
     * 在插件中使用：需要基础库 `2.15.0`
     *
     * 监听 mDNS 服务停止搜索的事件
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/network/mdns/wx.onLocalServiceDiscoveryStop.html](https://developers.weixin.qq.com/miniprogram/dev/api/network/mdns/wx.onLocalServiceDiscoveryStop.html)
     */
    onLocalServiceDiscoveryStop(listener: UniNamespace.OnLocalServiceDiscoveryStopCallback): void;
    /**
     *
     * 需要基础库： `2.4.0`
     *
     * 在插件中使用：需要基础库 `2.15.0`
     *
     * 监听 mDNS 服务发现的事件
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/network/mdns/wx.onLocalServiceFound.html](https://developers.weixin.qq.com/miniprogram/dev/api/network/mdns/wx.onLocalServiceFound.html)
     */
    onLocalServiceFound(listener: UniNamespace.OnLocalServiceFoundCallback): void;
    /**
     *
     * 需要基础库： `2.4.0`
     *
     * 在插件中使用：需要基础库 `2.15.0`
     *
     * 监听 mDNS 服务离开的事件
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/network/mdns/wx.onLocalServiceLost.html](https://developers.weixin.qq.com/miniprogram/dev/api/network/mdns/wx.onLocalServiceLost.html)
     */
    onLocalServiceLost(listener: UniNamespace.OnLocalServiceLostCallback): void;
    /**
     *
     * 需要基础库： `2.4.0`
     *
     * 在插件中使用：需要基础库 `2.15.0`
     *
     * 监听 mDNS 服务解析失败的事件
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/network/mdns/wx.onLocalServiceResolveFail.html](https://developers.weixin.qq.com/miniprogram/dev/api/network/mdns/wx.onLocalServiceResolveFail.html)
     */
    onLocalServiceResolveFail(listener: UniNamespace.OnLocalServiceResolveFailCallback): void;
    /**
     *
     * 需要基础库： `3.4.3`
     *
     * 在插件中使用：不支持
     *
     * 监听菜单按钮（右上角胶囊按钮）的布局位置信息变化事件
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/ui/menu/wx.onMenuButtonBoundingClientRectWeightChange.html](https://developers.weixin.qq.com/miniprogram/dev/api/ui/menu/wx.onMenuButtonBoundingClientRectWeightChange.html)
     */
    onMenuButtonBoundingClientRectWeightChange(listener: UniNamespace.OnMenuButtonBoundingClientRectWeightChangeCallback): void;
    /**
     *
     * 需要基础库： `2.32.3`
     *
     * 在插件中使用：不支持
     *
     * 监听隐私接口需要用户授权事件。当需要用户进行隐私授权时会触发。触发该事件时，开发者需要弹出隐私协议说明，并在用户同意或拒绝授权后调用回调接口 resolve 触发原隐私接口或组件继续执行。隐私合规开发指南详情可见[《小程序隐私协议开发指南》](https://developers.weixin.qq.com/miniprogram/dev/framework/user-privacy/PrivacyAuthorize.html)
     *
     * ****
     *
     * ## 回调参数
     *
     * ### function resolve
     *
     * resolve 是 onNeedPrivacyAuthorization 的首个回调参数，是一个接口函数。
     *
     * 当触发 onNeedPrivacyAuthorization 事件时，触发该事件的隐私接口或组件会处于 pending 状态。
     *
     * 如果调用 resolve({ buttonId: 'agree-btn'， event:'agree' })，则触发当前 onNeedPrivacyAuthorization 事件的原隐私接口或组件会继续执行。其中 buttonId 为隐私同意授权按钮的id，为确保用户有同意的操作，基础库会检查对应的同意按钮是否被点击过。(Tips: 需要在`<button open-type="agreePrivacyAuthorization">` 组件的 bindagreeprivacyauthorization 事件触发后再调用 `resolve({ buttonId: 'agree-btn'， event:'agree' })`)
     *
     * 如果调用 resolve({ event: 'disagree' })，则触发当前 onNeedPrivacyAuthorization 事件的原隐私接口或组件会失败并返回 `API:fail privacy permission is not authorized` 的错误信息。
     *
     * 在调用 resolve({ event: 'agree'/'disagree' }) 之前，开发者可以调用 resolve({ event: 'exposureAuthorization' }) 把隐私弹窗曝光告知平台。
     *
     * ### Object eventInfo
     *
     * eventInfo 是 onNeedPrivacyAuthorization 的第二个回调参数，表示触发本次 onNeedPrivacyAuthorization 事件的关联信息
     *
     * | 属性 | 类型 | 说明 |
     * | ---- | ---- | ---- |
     * | referrer | string | 触发本次 onNeedPrivacyAuthorization 事件的接口或组件名（例如："getUserProfile", "button.getPhoneNumber"） |
     *
     * ****
     *
     * ## resolve 接口参数
     *
     * | 属性 | 类型 | 是否必填 | 说明 |
     * | ---- | ---- | ---- | ---- |
     * | event | string |  是 | 用户操作类型 |
     * | buttonId | string | 是 | 同意授权按钮的id （仅event=agree时必填） |
     *
     * ### event 合法值
     *
     * | event | 说明 |
     * | ---- | ---- |
     * | exposureAuthorization | 自定义隐私弹窗曝光 |
     * | agree | 用户同意隐私授权 |
     * | disagree | 用户拒绝隐私授权 |
     *
     * ****
     *
     * ## 具体说明：
     *
     * - 1. 什么时候会触发 onNeedPrivacyAuthorization 事件？
     * - 1. 调用隐私相关接口（比如 wx.getUserProfile、wx.getClipboardData）和组件（比如 `<button open-type="getPhoneNumber"></button>`），并且用户还未同意过隐私协议时
     * - 2. 调用 wx.requirePrivacyAuthorize 接口来模拟隐私接口调用，并且用户还未同意过隐私协议时
     * - 3. 如果用户已经同意过隐私协议，则不会再触发 onNeedPrivacyAuthorization 事件
     * - 2. 当触发 onNeedPrivacyAuthorization 事件时，触发该事件的隐私接口或组件会处于 pending 状态，等待用户授权后才会继续执行，此时开发者需要弹出自定义隐私弹窗，并在用户点击同意/拒绝后调用回调接口 resolve ，触发该事件的隐私接口或组件才会继续执行。
     * - 3. wx.onNeedPrivacyAuthorization 是覆盖式注册监听，若重复注册监听，则只有最后一次注册会生效。
     * - 4. 一定要注册 wx.onNeedPrivacyAuthorization 监听以及调用 resolve 吗？
     * - 1. 不是的，如果能保证在调用隐私接口之前，用户已经轻触过了 `<button open-type="agreePrivacyAuthorization">` 按钮，那就不需要 wx.onNeedPrivacyAuthorization。
     * - 2. 但如果注册了 wx.onNeedPrivacyAuthorization 监听，则一定要调用 resolve 接口。
     *
     *
     * **完整示例demo**
     *
     * demo1: 演示使用 `wx.getPrivacySetting` 和 `<button open-type="agreePrivacyAuthorization">` 在首页处理隐私弹窗逻辑
     * [https://developers.weixin.qq.com/s/gi71sGm67hK0](https://developers.weixin.qq.com/s/gi71sGm67hK0)
     *
     * demo2: 演示使用 `wx.onNeedPrivacyAuthorization` 和 `<button open-type="agreePrivacyAuthorization">` 在多个页面处理隐私弹窗逻辑，同时演示了如何处理多个隐私接口同时调用。
     * [https://developers.weixin.qq.com/s/hndZUOmA7gKn](https://developers.weixin.qq.com/s/hndZUOmA7gKn)
     *
     * demo3: 演示 `wx.onNeedPrivacyAuthorization`、`wx.requirePrivacyAuthorize`、`<button open-type="agreePrivacyAuthorization">` 和 `<input type="nickname">` 组件如何结合使用
     * [https://developers.weixin.qq.com/s/jX7xWGmA7UKa](https://developers.weixin.qq.com/s/jX7xWGmA7UKa)
     *
     * demo4: 演示使用 `wx.onNeedPrivacyAuthorization` 和 `<button open-type="agreePrivacyAuthorization">` 在多个 tabBar 页面处理隐私弹窗逻辑。
     * [https://developers.weixin.qq.com/s/g6BWZGmt7XK9](https://developers.weixin.qq.com/s/g6BWZGmt7XK9)
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/open-api/privacy/wx.onNeedPrivacyAuthorization.html](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/privacy/wx.onNeedPrivacyAuthorization.html)
     */
    onNeedPrivacyAuthorization(listener: UniNamespace.OnNeedPrivacyAuthorizationCallback): void;
    /**
     *
     * 需要基础库： `2.21.0`
     *
     * 在插件中使用：不支持
     *
     * 监听弱网状态变化事件
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/network/wx.onNetworkWeakChange.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/network/wx.onNetworkWeakChange.html)
     */
    onNetworkWeakChange(listener: UniNamespace.OnNetworkWeakChangeCallback): void;
    /**
     *
     * 需要基础库： `3.7.9`
     *
     * 在插件中使用：不支持
     *
     * 监听用户触发小程序菜单中翻译功能的事件
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/ui/menu/wx.onOnUserTriggerTranslation.html](https://developers.weixin.qq.com/miniprogram/dev/api/ui/menu/wx.onOnUserTriggerTranslation.html)
     */
    onOnUserTriggerTranslation(listener: UniNamespace.OnOnUserTriggerTranslationCallback): void;
    /**
     *
     * 需要基础库： `2.1.2`
     *
     * 在插件中使用：不支持
     *
     * 监听小程序要打开的页面不存在事件。该事件与 [`App.onPageNotFound`](https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html#onpagenotfoundobject-object) 的回调时机一致。
     *
     * **注意**
     *
     * - 开发者可以在回调中进行页面重定向，但必须在回调中**同步**处理，异步处理（例如 `setTimeout` 异步执行）无效。
     * - 若开发者没有调用 [uni.onPageNotFound](https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-event/wx.onPageNotFound.html) 绑定监听，也没有声明 `App.onPageNotFound`，当跳转页面不存在时，将推入微信客户端原生的页面不存在提示页面。
     * - 如果回调中又重定向到另一个不存在的页面，将推入微信客户端原生的页面不存在提示页面，并且不再第二次回调。
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-event/wx.onPageNotFound.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-event/wx.onPageNotFound.html)
     */
    onPageNotFound(listener: UniNamespace.OnPageNotFoundCallback): void;
    /**
     *
     * 需要基础库： `2.24.0`
     *
     * 在插件中使用：不支持
     *
     * 监听用户录屏事件。
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/screen/wx.onScreenRecordingStateChanged.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/screen/wx.onScreenRecordingStateChanged.html)
     */
    onScreenRecordingStateChanged(listener: UniNamespace.OnScreenRecordingStateChangedCallback): void;
    /**
     *
     * 需要基础库： `2.7.0`
     *
     * 在插件中使用：需要基础库 `2.9.1`
     *
     * 监听被动断开实时语音通话事件。包括小游戏切入后端时断开
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/voip/wx.onVoIPChatInterrupted.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/voip/wx.onVoIPChatInterrupted.html)
     */
    onVoIPChatInterrupted(listener: UniNamespace.OnVoIPChatInterruptedCallback): void;
    /**
     *
     * 需要基础库： `2.7.0`
     *
     * 在插件中使用：需要基础库 `2.9.1`
     *
     * 监听实时语音通话成员在线状态变化事件。有成员加入/退出通话时触发回调
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/voip/wx.onVoIPChatMembersChanged.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/voip/wx.onVoIPChatMembersChanged.html)
     */
    onVoIPChatMembersChanged(listener: UniNamespace.OnVoIPChatMembersChangedCallback): void;
    /**
     *
     * 需要基础库： `2.7.0`
     *
     * 在插件中使用：需要基础库 `2.9.1`
     *
     * 监听实时语音通话成员通话状态变化事件。有成员开始/停止说话时触发回调
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/voip/wx.onVoIPChatSpeakersChanged.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/voip/wx.onVoIPChatSpeakersChanged.html)
     */
    onVoIPChatSpeakersChanged(listener: UniNamespace.OnVoIPChatSpeakersChangedCallback): void;
    /**
     *
     * 需要基础库： `2.16.0`
     *
     * 在插件中使用：不支持
     *
     * 监听房间状态变化事件。
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/voip/wx.onVoIPChatStateChanged.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/voip/wx.onVoIPChatStateChanged.html)
     */
    onVoIPChatStateChanged(listener: UniNamespace.OnVoIPChatStateChangedCallback): void;
    /**
     *
     * 需要基础库： `2.11.0`
     *
     * 在插件中使用：不支持
     *
     * 监听实时语音通话成员视频状态变化事件。
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/voip/wx.onVoIPVideoMembersChanged.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/voip/wx.onVoIPVideoMembersChanged.html)
     */
    onVoIPVideoMembersChanged(listener: UniNamespace.OnVoIPVideoMembersChangedCallback): void;
    /**
     *
     * 需要基础库： `1.1.0`
     *
     * 在插件中使用：不支持
     *
     * 查看微信卡包中的卡券。只有通过 [认证](https://developers.weixin.qq.com/miniprogram/product/renzheng.html) 的小程序或文化互动类目的小游戏才能使用。更多文档请参考 [微信卡券接口文档](https://mp.weixin.qq.com/cgi-bin/announce?action=getannouncement&key=1490190158&version=1&lang=zh_CN&platform=2)。
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/open-api/card/wx.openCard.html](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/card/wx.openCard.html)
     */
    openCard(option: UniNamespace.OpenCardOption): void;
    /**
     *
     * 需要基础库： `2.19.2`
     *
     * 在插件中使用：不支持
     *
     * 打开视频号视频
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/open-api/channels/wx.openChannelsActivity.html](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/channels/wx.openChannelsActivity.html)
     */
    openChannelsActivity(option: UniNamespace.OpenChannelsActivityOption): void;
    /**
     *
     * 需要基础库： `2.21.0`
     *
     * 在插件中使用：需要基础库 `3.7.11`
     *
     * 打开视频号活动页
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/open-api/channels/wx.openChannelsEvent.html](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/channels/wx.openChannelsEvent.html)
     */
    openChannelsEvent(option: UniNamespace.OpenChannelsEventOption): void;
    /**
     *
     * 需要基础库： `2.15.0`
     *
     * 在插件中使用：不支持
     *
     * 打开视频号直播
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/open-api/channels/wx.openChannelsLive.html](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/channels/wx.openChannelsLive.html)
     */
    openChannelsLive(option: UniNamespace.OpenChannelsLiveOption): void;
    /**
     *
     * 需要基础库： `2.21.2`
     *
     * 在插件中使用：支持
     *
     * 打开视频号主页。若为插件环境，只允许在插件页面中调用。
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/open-api/channels/wx.openChannelsUserProfile.html](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/channels/wx.openChannelsUserProfile.html)
     */
    openChannelsUserProfile(option: UniNamespace.OpenChannelsUserProfileOption): void;
    /**
     *
     * 需要基础库： `3.7.8`
     *
     * 在插件中使用：不支持
     *
     * 进入聊天工具模式。
     *
     *  1. 不传入聊天室id时，微信会拉起聊天列表让用户选择，用户选择后绑定聊天室进入聊天工具模式。
     *  2. 传入聊天室id时（群聊为opengid，单聊为open_single_roomid），会直接绑定该聊天室进入，此时必须传入对应的 chatType。
     *  3. 聊天室类型可从 [[getGroupEnterInfo]](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/group/wx.getGroupEnterInfo.html) 返回值中获取。
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/chattool/wx.openChatTool.html](https://developers.weixin.qq.com/miniprogram/dev/api/chattool/wx.openChatTool.html)
     */
    openChatTool(option: UniNamespace.OpenChatToolOption): void;
    /**
     *
     * 需要基础库： `2.19.0`
     *
     * 在插件中使用：不支持
     *
     * 打开微信客服，页面产生点击事件后才可调用。了解更多信息，可以参考[微信客服介绍](https://work.weixin.qq.com/kf/)。
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/open-api/service-chat/wx.openCustomerServiceChat.html](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/service-chat/wx.openCustomerServiceChat.html)
     */
    openCustomerServiceChat(option: UniNamespace.OpenCustomerServiceChatOption): void;
    /**
     *
     * 需要基础库： `2.20.1`
     *
     * 在插件中使用：需要基础库 `2.26.2`
     *
     * 打开半屏小程序。接入指引请参考 [半屏小程序能力](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/openEmbeddedMiniProgram.html)。
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/navigate/wx.openEmbeddedMiniProgram.html](https://developers.weixin.qq.com/miniprogram/dev/api/navigate/wx.openEmbeddedMiniProgram.html)
     */
    openEmbeddedMiniProgram(option: UniNamespace.OpenEmbeddedMiniProgramOption): void;
    /**
     *
     * 需要基础库： `3.4.4`
     *
     * 在插件中使用：不支持
     *
     * 拉起WeChat Pay HK付款码。
     *
     * 接入步骤：
     * 1. 商户需已经开通微信港币钱包WeChat Pay HK的支付权限，
     * 2.请用商户在微信支付入驻时预留的邮箱，发起邮件申请接入权限：
     * - 【收件人】hkpayment@wechat.com
     * - 【邮件主题】申请接入拉起WeChat Pay HK付款码+商户名称：***+商户号：***
     * - 【邮件内容】因XXX原因（原因请按商户实际情况填写，不合理会驳回），需申请拉起WeChat Pay HK付款码，申请材料如下：
     * - 商户名称
     * - 商户号
     * - 商户资质材料扫描件或照片（CI，BR任一），所有材料均需清晰，且有盖章
     * - 拉起WeChat Pay HK付款码的场景说明：需有文字和示意图说明
     * - 商户联系方式：邮件***，联系电话***
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/payment/wx.openHKOfflinePayView.html](https://developers.weixin.qq.com/miniprogram/dev/api/payment/wx.openHKOfflinePayView.html)
     */
    openHKOfflinePayView(option: UniNamespace.OpenHKOfflinePayViewOption): void;
    /**
     *
     * 需要基础库： `3.4.8`
     *
     * 在插件中使用：不支持
     *
     * 通过小程序打开任意公众号文章（不包括临时链接等异常状态下的公众号文章），必须有点击行为才能调用成功。
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/navigate/wx.openOfficialAccountArticle.html](https://developers.weixin.qq.com/miniprogram/dev/api/navigate/wx.openOfficialAccountArticle.html)
     */
    openOfficialAccountArticle(option: UniNamespace.OpenOfficialAccountArticleOption): void;
    /**
     *
     * 需要基础库： `3.7.10`
     *
     * 在插件中使用：不支持
     *
     * 通过小程序打开任意公众号主页
     *
     *
     * **Tips**
     *
     * 1. 跳转的公众号需与小程序为同主体或关联主体
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/navigate/wx.openOfficialAccountProfile.html](https://developers.weixin.qq.com/miniprogram/dev/api/navigate/wx.openOfficialAccountProfile.html)
     */
    openOfficialAccountProfile(option: UniNamespace.OpenOfficialAccountProfileOption): void;
    /**
     *
     * 需要基础库： `2.32.3`
     *
     * 在插件中使用：不支持
     *
     * 跳转至隐私协议页面。隐私合规开发指南详情可见[《小程序隐私协议开发指南》](https://developers.weixin.qq.com/miniprogram/dev/framework/user-privacy/PrivacyAuthorize.html)
     *
     * ****
     *
     * ## 具体说明：
     *
     * - 1. 一定要调用 wx.openPrivacyContract 接口吗？
     *
     * - 不是。开发者也可以选择在小程序页面内自行展示完整的隐私协议。但推荐使用该接口。
     *
     *
     * **完整示例demo**
     *
     * demo1: 演示使用 `wx.getPrivacySetting` 和 `<button open-type="agreePrivacyAuthorization">` 在首页处理隐私弹窗逻辑
     * [https://developers.weixin.qq.com/s/gi71sGm67hK0](https://developers.weixin.qq.com/s/gi71sGm67hK0)
     *
     * demo2: 演示使用 `wx.onNeedPrivacyAuthorization` 和 `<button open-type="agreePrivacyAuthorization">` 在多个页面处理隐私弹窗逻辑，同时演示了如何处理多个隐私接口同时调用。
     * [https://developers.weixin.qq.com/s/hndZUOmA7gKn](https://developers.weixin.qq.com/s/hndZUOmA7gKn)
     *
     * demo3: 演示 `wx.onNeedPrivacyAuthorization`、`wx.requirePrivacyAuthorize`、`<button open-type="agreePrivacyAuthorization">` 和 `<input type="nickname">` 组件如何结合使用
     * [https://developers.weixin.qq.com/s/jX7xWGmA7UKa](https://developers.weixin.qq.com/s/jX7xWGmA7UKa)
     *
     * demo4: 演示使用 `wx.onNeedPrivacyAuthorization` 和 `<button open-type="agreePrivacyAuthorization">` 在多个 tabBar 页面处理隐私弹窗逻辑。
     * [https://developers.weixin.qq.com/s/g6BWZGmt7XK9](https://developers.weixin.qq.com/s/g6BWZGmt7XK9)
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/open-api/privacy/wx.openPrivacyContract.html](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/privacy/wx.openPrivacyContract.html)
     */
    openPrivacyContract(option: UniNamespace.OpenPrivacyContractOption): void;
    /**
     *
     * 需要基础库： `3.0.1`
     *
     * 在插件中使用：不支持
     *
     * 打开单个表情
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/open-api/sticker/wx.openSingleStickerView.html](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/sticker/wx.openSingleStickerView.html)
     */
    openSingleStickerView(option: UniNamespace.OpenSingleStickerViewOption): void;
    /**
     *
     * 需要基础库： `3.0.1`
     *
     * 在插件中使用：不支持
     *
     * 打开表情IP合辑
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/open-api/sticker/wx.openStickerIPView.html](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/sticker/wx.openStickerIPView.html)
     */
    openStickerIPView(option: UniNamespace.OpenStickerIPViewOption): void;
    /**
     *
     * 需要基础库： `3.0.1`
     *
     * 在插件中使用：不支持
     *
     * 打开表情专辑
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/open-api/sticker/wx.openStickerSetView.html](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/sticker/wx.openStickerSetView.html)
     */
    openStickerSetView(option: UniNamespace.OpenStickerSetViewOption): void;
    /**
     *
     * 需要基础库： `3.7.1`
     *
     * 在插件中使用：不支持
     *
     * 打开微信小店订单详情页
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/open-api/store/wx.openStoreOrderDetail.html](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/store/wx.openStoreOrderDetail.html)
     */
    openStoreOrderDetail(option: UniNamespace.OpenStoreOrderDetailOption): void;
    /**
     *
     * 需要基础库： `2.20.1`
     *
     * 在插件中使用：需要基础库 `2.21.3`
     *
     * 跳转系统蓝牙设置页。仅支持安卓。
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/system/wx.openSystemBluetoothSetting.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/system/wx.openSystemBluetoothSetting.html)
     */
    openSystemBluetoothSetting(option?: UniNamespace.OpenSystemBluetoothSettingOption): void;
    /**
     *
     * 在插件中使用：需要基础库 `1.9.6`
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/background-audio/wx.pauseBackgroundAudio.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/background-audio/wx.pauseBackgroundAudio.html)
     */
    pauseBackgroundAudio(option?: UniNamespace.PauseBackgroundAudioOption): void;
    /**
     *
     * 在插件中使用：需要基础库 `1.9.6`
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/wx.pauseVoice.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/wx.pauseVoice.html)
     */
    pauseVoice(option?: UniNamespace.PauseVoiceOption): void;
    /**
     *
     * 在插件中使用：需要基础库 `1.9.6`
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/background-audio/wx.playBackgroundAudio.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/background-audio/wx.playBackgroundAudio.html)
     */
    playBackgroundAudio(option: UniNamespace.PlayBackgroundAudioOption): void;
    /**
     *
     * 在插件中使用：需要基础库 `1.9.6`
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/wx.playVoice.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/wx.playVoice.html)
     */
    playVoice(option: UniNamespace.PlayVoiceOption): void;
    /**
     *
     * 需要基础库： `2.20.1`
     *
     * 在插件中使用：需要基础库 `2.20.1`
     *
     * __该接口仅在小程序插件中可调用__，调用接口获得插件用户标志凭证（code）。插件可以此凭证换取用于识别用户的标识 openpid。用户不同、宿主小程序不同或插件不同的情况下，该标识均不相同，即当且仅当同一个用户在同一个宿主小程序中使用同一个插件时，openpid 才会相同。
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/open-api/login/wx.pluginLogin.html](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/login/wx.pluginLogin.html)
     */
    pluginLogin(args?: UniNamespace.PluginLoginOption): void;
    /**
     *
     * 需要基础库： `3.2.1`
     *
     * 在插件中使用：不支持
     *
     * 向跳转的源小程序发送消息，源小程序可在 [uni.onShow](#) 或 [uni.getEnterOptionsSync](https://developers.weixin.qq.com/miniprogram/dev/api/base/app/life-cycle/wx.getEnterOptionsSync.html) 中通过 extraData 接收消息。
     *
     * ****
     *
     * 多次调用会覆盖之前传递的消息，通过 [uni.navigateBackMiniProgram](https://developers.weixin.qq.com/miniprogram/dev/api/navigate/wx.navigateBackMiniProgram.html) 传递 extraData 也会覆盖消息。
     *
     * ****
     *
     * 在触发返回后传递的消息不会被收到。
     *
     * ****
     *
     * 如果没有源小程序能够收到消息，会抛出 no referrer 错误。
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-event/wx.postMessageToReferrerMiniProgram.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-event/wx.postMessageToReferrerMiniProgram.html)
     */
    postMessageToReferrerMiniProgram(option: UniNamespace.PostMessageToReferrerMiniProgramOption): void;
    /**
     *
     * 需要基础库： `3.7.2`
     *
     * 在插件中使用：不支持
     *
     * 向跳转的源页面发送消息。
     *
     * ****
     *
     * 多次调用会覆盖之前传递的消息，通过 [uni.navigateBackMiniProgram](https://developers.weixin.qq.com/miniprogram/dev/api/navigate/wx.navigateBackMiniProgram.html) 传递 extraData 也会覆盖消息。
     *
     * ****
     *
     * 在触发返回后传递的消息不会被收到。
     *
     * ****
     *
     * 如果没有源页面能够收到消息，会抛出 no referrer 错误。
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-event/wx.postMessageToReferrerPage.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-event/wx.postMessageToReferrerPage.html)
     */
    postMessageToReferrerPage(option: UniNamespace.PostMessageToReferrerMiniProgramOption): void;
    /**
     *
     * 需要基础库： `2.22.1`
     *
     * 在插件中使用：不支持
     *
     * 为视图层预加载媒体资源文件, 目前支持：font，image
     *
     *
     * ****
     *
     * - 开发过程中，可在开发者工具network面板查看预加载情况。
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/performance/wx.preloadAssets.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/performance/wx.preloadAssets.html)
     */
    preloadAssets(option: UniNamespace.PreloadAssetsOption): void;
    /**
     *
     * 需要基础库： `2.24.7`
     *
     * 在插件中使用：需要基础库 `2.24.7`
     *
     * 预加载下个页面所需要的 [Skyline](https://developers.weixin.qq.com/miniprogram/dev/framework/runtime/skyline/introduction.html) 运行环境。
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/performance/wx.preloadSkylineView.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/performance/wx.preloadSkylineView.html)
     */
    preloadSkylineView(option?: UniNamespace.PreloadSkylineViewOption): void;
    /**
     *
     * 需要基础库： `2.15.0`
     *
     * 在插件中使用：需要基础库 `2.15.0`
     *
     * 预加载下个页面的 WebView。参见[预加载下个页面的时机](https://developers.weixin.qq.com/miniprogram/dev/framework/performance/tips/runtime_nav.html#_2-4-控制预加载下个页面的时机)
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/performance/wx.preloadWebview.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/performance/wx.preloadWebview.html)
     */
    preloadWebview(option?: UniNamespace.PreloadWebviewOption): void;
    /**
     *
     * 需要基础库： `2.12.0`
     *
     * 在插件中使用：需要基础库 `2.15.0`
     *
     * 预览图片和视频。
     *
     * **支持长按识别的码**
     *
     * | 类型 | 说明 | 最低版本 |
     * |------|------| -------|
     * | 小程序码 |    |
     * | 微信个人码 | 不支持小游戏   | [2.18.0](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) |
     * | 企业微信个人码 | 不支持小游戏   | [2.18.0](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) |
     * | 普通群码 | 指仅包含微信用户的群，不支持小游戏   | [2.18.0](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) |
     * | 互通群码 |  指既有微信用户也有企业微信用户的群，不支持小游戏  | [2.18.0](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) |
     * | 公众号二维码 | 不支持小游戏  | [2.18.0](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) |
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/image/wx.previewMedia.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/image/wx.previewMedia.html)
     */
    previewMedia(option: UniNamespace.PreviewMediaOption): void;
    /**
     *
     * 在插件中使用：需要基础库 `1.9.6`
     *
     * 在插件中使用时，可以被正常调用，但目前不会进行统计展示
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/data-analysis/wx.reportAnalytics.html](https://developers.weixin.qq.com/miniprogram/dev/api/data-analysis/wx.reportAnalytics.html)
     */
    reportAnalytics(eventName: string, data: any): void;
    /**
     *
     * 需要基础库： `2.14.4`
     *
     * 在插件中使用：不支持
     *
     * 事件上报
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/data-analysis/wx.reportEvent.html](https://developers.weixin.qq.com/miniprogram/dev/api/data-analysis/wx.reportEvent.html)
     */
    reportEvent(eventId: string, data?: any): void;
    /**
     *
     * 需要基础库： `2.0.1`
     *
     * 在插件中使用：不支持
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/data-analysis/wx.reportMonitor.html](https://developers.weixin.qq.com/miniprogram/dev/api/data-analysis/wx.reportMonitor.html)
     */
    reportMonitor(name: string, value: number): void;
    /**
     *
     * 需要基础库： `2.9.2`
     *
     * 在插件中使用：需要基础库 `2.9.3`
     *
     * 小程序测速上报。使用前，需要在小程序管理后台配置。
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/performance/wx.reportPerformance.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/performance/wx.reportPerformance.html)
     */
    reportPerformance(id: number, value: number, dimensions?: string | any[]): void;
    /**
     *
     * 需要基础库： `2.19.2`
     *
     * 在插件中使用：不支持
     *
     * 发起通用支付。目前该接口仅支持 B2b 支付类型。
     *
     * ****
     *
     * ## 注意事项：
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/payment/wx.requestCommonPayment.html](https://developers.weixin.qq.com/miniprogram/dev/api/payment/wx.requestCommonPayment.html)
     */
    requestCommonPayment(option: UniNamespace.RequestCommonPaymentOption): void;
    /**
     *
     * 需要基础库： `2.27.3`
     *
     * 在插件中使用：不支持
     *
     * 请求用户授权与设备（组）间进行音视频通话。
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/open-api/device-voip/wx.requestDeviceVoIP.html](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/device-voip/wx.requestDeviceVoIP.html)
     */
    requestDeviceVoIP(option: UniNamespace.RequestDeviceVoIPOption): void;
    /**
     *
     * 需要基础库： `3.3.0`
     *
     * 在插件中使用：不支持
     *
     * 商家转账用户确认模式下，在微信客户端通过小程序拉起页面请求用户确认收款。调用前需在微信支付商户平台/合作伙伴平台-产品中心，申请开通商家转账。
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/payment/wx.requestMerchantTransfer.html](https://developers.weixin.qq.com/miniprogram/dev/api/payment/wx.requestMerchantTransfer.html)
     */
    requestMerchantTransfer(option: UniNamespace.RequestMerchantTransferOption): void;
    /**
     *
     * 需要基础库： `2.16.0`
     *
     * 在插件中使用：不支持
     *
     * 仅接入了[自定义版交易组件](https://developers.weixin.qq.com/miniprogram/dev/framework/ministore/minishopopencomponent2/Introduction2)的小程序需要使用，普通小程序可直接使用 [`wx.requestPayment`](https://developers.weixin.qq.com/miniprogram/dev/api/payment/wx.requestPayment.html)。
     *
     * **前置检查**
     *
     * 接入自定义版交易组件之后，若要发起微信支付，请先查询[需要校验的场景](https://developers.weixin.qq.com/miniprogram/dev/framework/ministore/minishopopencomponent2/API/order/check_scene)。
     * 在需要校验的场景中，发起微信支付时，必须使用该接口，需要按照要求传入相关的[订单信息](https://developers.weixin.qq.com/miniprogram/dev/framework/ministore/minishopopencomponent2/API/order/add_order)进行校验，校验通过后用户才可以完成当前订单的支付，非需要校验的场景则可以按照商家要求自行选择传入订单信息或不传入。
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/payment/wx.requestOrderPayment.html](https://developers.weixin.qq.com/miniprogram/dev/api/payment/wx.requestOrderPayment.html)
     */
    requestOrderPayment(args: UniNamespace.RequestOrderPaymentOption): void;
    /**
     *
     * 需要基础库： `2.22.1`
     *
     * 在插件中使用：需要基础库 `2.22.1`
     *
     * 插件中发起支付。
     *
     * **Tip**
     *
     * 1. `tip`: 小程序与插件绑定在同一个open平台账号上且小程序与插件均为open账号的同主体/关联主体时，调用此接口将直接拉起支付收银台。
     * 1. `tip`: 这个接口本身可以在开发者工具中使用，但功能页的跳转目前不支持在开发者工具中调试，请在真机上测试。
     * 1. `tip`: 跳转支付功能页需要在 `app.json` 中配置 `"functionalPages": true`
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/payment/wx.requestPluginPayment.html](https://developers.weixin.qq.com/miniprogram/dev/api/payment/wx.requestPluginPayment.html)
     */
    requestPluginPayment(option: UniNamespace.RequestPluginPaymentOption): void;
    /**
     *
     * 需要基础库： `2.20.0`
     *
     * 在插件中使用：需要基础库 `3.4.1`
     *
     * 订阅设备消息接口，调用后弹出授权框，用户同意后会允许开发者给用户发送订阅模版消息。当用户点击“允许”按钮时，模板消息会被添加到用户的小程序设置页，通过 wx.getSetting 接口可获取用户对相关模板消息的订阅状态。
     *
     * **错误码**
     *
     * | errCode | errMsg                                                 | 说明                                                           |
     * | ------- | ------------------------------------------------------ | -------------------------------------------------------------- |
     * | 10001   | TmplIds can't be empty                                 | tmplIds 为空                                                  |
     * | 10004   | Invalid template id                                    | tmplId 参数类型错误                                            |
     * | 20001   | No template data return, verify the template id exist  | tmplId 为空                                                  |
     * | 20003   | Templates count out of max bounds                      | tmplId 数量超过上限                                           |
     * | 19720726   | check sn_ticket fail                                | snTicket 不合法                                              |
     * | 19720727   | sn_ticket expire                                    | snTicket 过期                                               |
     * | 19720728   | err_not_found_tid                                    | tmplId 不存在                                              |
     * | 19720736   | template_id do not match model_id                   | modelId 类型与 tmplId 类型不符                               |
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/open-api/subscribe-message/wx.requestSubscribeDeviceMessage.html](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/subscribe-message/wx.requestSubscribeDeviceMessage.html)
     */
    requestSubscribeDeviceMessage(option: UniNamespace.RequestSubscribeDeviceMessageOption): void;
    /**
     *
     * 需要基础库： `2.4.4`
     *
     * 在插件中使用：需要基础库 `3.4.1`
     *
     * 调起客户端小程序订阅消息界面，返回用户订阅消息的操作结果。当用户勾选了订阅面板中的“总是保持以上选择，不再询问”时，模板消息会被添加到用户的小程序设置页，通过 [uni.getSetting](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/setting/wx.getSetting.html) 接口可获取用户对相关模板消息的订阅状态。
     *
     * ## 注意事项
     * - 一次性模板 id 和永久模板 id 不可同时使用。
     * - 低版本基础库2.4.4~2.8.3 已支持订阅消息接口调用，仅支持传入一个一次性 tmplId / 永久 tmplId。
     * - [2.8.2](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) 版本开始，用户发生点击行为或者发起支付回调后，才可以调起订阅消息界面。
     * - [2.10.0](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) 版本开始，开发版和体验版小程序将禁止使用模板消息 formId。
     * - 一次授权调用里，每个tmplId对应的模板标题不能存在相同的，若出现相同的，只保留一个。
     * - [2.10.0](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) 版本开始，支持订阅语音消息提醒，[详情](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/subscribe-message.html)
     *
     * **错误码**
     *
     * | errCode | errMsg                                                 | 说明                                                           |
     * | ------- | ------------------------------------------------------ | -------------------------------------------------------------- |
     * | 10001   | TmplIds can't be empty                                 | 参数传空了                                                     |
     * | 10002   | Request list fail                                       | 网络问题，请求消息列表失败                                     |
     * | 10003   | Request subscribe fail                                 | 网络问题，订阅请求发送失败                                     |
     * | 10004   | Invalid template id                                    | 参数类型错误                                                   |
     * | 10005   | Cannot show subscribe message UI                       | 无法展示 UI，一般是小程序这个时候退后台了导致的                |
     * | 20001   | No template data return, verify the template id exist  | 没有模板数据，一般是模板 ID 不存在 或者和模板类型不对应 导致的 |
     * | 20002   | Templates type must be same                            | 模板消息类型 既有一次性的又有永久的                            |
     * | 20003   | Templates count out of max bounds                      | 模板消息数量超过上限                                           |
     * | 20004   | The main switch is switched off                        | 用户关闭了主开关，无法进行订阅                                 |
     * | 20005   | This mini program was banned from subscribing messages | 小程序被禁封                                                   |
     * | 20013   | Reject DeviceMsg Template                              | 不允许通过该接口订阅设备消息                                      |
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/open-api/subscribe-message/wx.requestSubscribeMessage.html](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/subscribe-message/wx.requestSubscribeMessage.html)
     */
    requestSubscribeMessage(option: UniNamespace.RequestSubscribeMessageOption): void;
    /**
     *
     * 需要基础库： `2.19.2`
     *
     * 在插件中使用：不支持
     *
     * 发起米大师虚拟支付
     *
     * ****
     *
     * ## 注意事项：
     *
     * - 1. 目前只有 >= v2.19.2 的基础库支持该接口，后续将对更多低版本基础库支持该接口。因此建议开发者这样判断：当前用户的基础库版本 >= v2.19.2 时可以直接用 wx.requestVirtualPayment，小于 v2.19.2 时，用 wx.canIUse('requestVirtualPayment') 来判断接口是否可用。具体判断方法可参考示例代码。
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/payment/wx.requestVirtualPayment.html](https://developers.weixin.qq.com/miniprogram/dev/api/payment/wx.requestVirtualPayment.html)
     */
    requestVirtualPayment(option: UniNamespace.RequestVirtualPaymentOption): void;
    /**
     *
     * 需要基础库： `2.32.3`
     *
     * 在插件中使用：不支持
     *
     * 模拟隐私接口调用，并触发隐私弹窗逻辑。隐私合规开发指南详情可见[《小程序隐私协议开发指南》](https://developers.weixin.qq.com/miniprogram/dev/framework/user-privacy/PrivacyAuthorize.html)
     *
     * ****
     *
     * ## 具体说明：
     *
     * 1. 调用 wx.requirePrivacyAuthorize() 时：
     *
     * - 1. 如果用户之前已经同意过隐私授权，会立即返回success回调，不会触发 wx.onNeedPrivacyAuthorization 事件。
     * - 2. 如果用户之前没有授权过，并且开发者注册了 [uni.onNeedPrivacyAuthorization()](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/privacy/wx.onNeedPrivacyAuthorization.html) 事件监听，就会立即触发 wx.onNeedPrivacyAuthorization 事件，然后开发者在 onNeedPrivacyAuthorization 回调中弹出自定义隐私授权弹窗，用户点了同意后开发者调用 wx.onNeedPrivacyAuthorization 的回调接口 resolve({ event: 'agree', buttonId: 'agree-btn' })，会触发 requirePrivacyAuthorize 的 success 回调。开发者调用 wx.onNeedPrivacyAuthorization 的回调接口 resolve({ event: 'disagree' }) 的话，会触发 requirePrivacyAuthorize 的 fail 回调。
     * - 3. 基于上述特性，开发者可以在调用任何真实隐私接口之前调用 wx.requirePrivacyAuthorize 接口来模拟隐私接口调用，并触发隐私弹窗逻辑。
     *
     * 2. 一定要调用 wx.requirePrivacyAuthorize 接口吗？
     *
     * - 不是，wx.requirePrivacyAuthorize 只是一个辅助接口，可以根据实际情况选择使用。
     *
     *
     * **完整示例demo**
     *
     * demo1: 演示使用 `wx.getPrivacySetting` 和 `<button open-type="agreePrivacyAuthorization">` 在首页处理隐私弹窗逻辑
     * [https://developers.weixin.qq.com/s/gi71sGm67hK0](https://developers.weixin.qq.com/s/gi71sGm67hK0)
     *
     * demo2: 演示使用 `wx.onNeedPrivacyAuthorization` 和 `<button open-type="agreePrivacyAuthorization">` 在多个页面处理隐私弹窗逻辑，同时演示了如何处理多个隐私接口同时调用。
     * [https://developers.weixin.qq.com/s/hndZUOmA7gKn](https://developers.weixin.qq.com/s/hndZUOmA7gKn)
     *
     * demo3: 演示 `wx.onNeedPrivacyAuthorization`、`wx.requirePrivacyAuthorize`、`<button open-type="agreePrivacyAuthorization">` 和 `<input type="nickname">` 组件如何结合使用
     * [https://developers.weixin.qq.com/s/jX7xWGmA7UKa](https://developers.weixin.qq.com/s/jX7xWGmA7UKa)
     *
     * demo4: 演示使用 `wx.onNeedPrivacyAuthorization` 和 `<button open-type="agreePrivacyAuthorization">` 在多个 tabBar 页面处理隐私弹窗逻辑。
     * [https://developers.weixin.qq.com/s/g6BWZGmt7XK9](https://developers.weixin.qq.com/s/g6BWZGmt7XK9)
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/open-api/privacy/wx.requirePrivacyAuthorize.html](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/privacy/wx.requirePrivacyAuthorize.html)
     */
    requirePrivacyAuthorize(option: UniNamespace.RequirePrivacyAuthorizeOption): void;
    /**
     *
     * 需要基础库： `2.19.0`
     *
     * 在插件中使用：不支持
     *
     * 预约视频号直播
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/open-api/channels/wx.reserveChannelsLive.html](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/channels/wx.reserveChannelsLive.html)
     */
    reserveChannelsLive(option: UniNamespace.ReserveChannelsLiveOption): void;
    /**
     *
     * 需要基础库： `3.0.1`
     *
     * 在插件中使用：不支持
     *
     * 重启当前小程序
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/navigate/wx.restartMiniProgram.html](https://developers.weixin.qq.com/miniprogram/dev/api/navigate/wx.restartMiniProgram.html)
     */
    restartMiniProgram(option: UniNamespace.RestartMiniProgramOption): void;
    /**
     *
     * 需要基础库： `2.14.0`
     *
     * 在插件中使用：不支持
     *
     * 根据 URL 销毁存在内存中的数据
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/storage/wx.revokeBufferURL.html](https://developers.weixin.qq.com/miniprogram/dev/api/storage/wx.revokeBufferURL.html)
     */
    revokeBufferURL(url: string): void;
    /**
     *
     * 需要基础库： `3.8.0`
     *
     * 在插件中使用：支持
     *
     * 在插件中使用时，只能重写目标为当前插件的页面的路由事件
     *
     * 重写正在进行中的路由事件，详见 [路由重写](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/route-rewrite.html)
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.rewriteRoute.html](https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.rewriteRoute.html)
     */
    rewriteRoute(option: UniNamespace.RewriteRouteOption): void;
    /**
     *
     * 需要基础库： `2.11.0`
     *
     * 在插件中使用：需要基础库 `2.15.0`
     *
     * 保存文件系统的文件到用户磁盘，仅在 PC 端支持
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/file/wx.saveFileToDisk.html](https://developers.weixin.qq.com/miniprogram/dev/api/file/wx.saveFileToDisk.html)
     */
    saveFileToDisk(option: UniNamespace.SaveFileToDiskOption): void;
    /**
     *
     * 在插件中使用：需要基础库 `1.9.6`
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/background-audio/wx.seekBackgroundAudio.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/background-audio/wx.seekBackgroundAudio.html)
     */
    seekBackgroundAudio(option: UniNamespace.SeekBackgroundAudioOption): void;
    /**
     *
     * 需要基础库： `3.7.8`
     *
     * 在插件中使用：不支持
     *
     * 选择聊天室的成员，并返回选择成员的 group_openid。若当前为群聊，则会拉起成员选择器；若当前为单聊，则直接返回双方的 group_openid。
     *
     * ****
     *
     * ```js
     * wx.selectGroupMembers({
     * maxSelectCount: 3,
     * success(res) {
     * // res.members
     * }
     * })
     * ```
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/chattool/wx.selectGroupMembers.html](https://developers.weixin.qq.com/miniprogram/dev/api/chattool/wx.selectGroupMembers.html)
     */
    selectGroupMembers(option: UniNamespace.SelectGroupMembersOption): void;
    /**
     *
     * 需要基础库： `1.7.0`
     *
     * 在插件中使用：需要基础库 `2.1.0`
     *
     * 发送 NFC 消息。仅在安卓系统下有效。
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc-hce/wx.sendHCEMessage.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc-hce/wx.sendHCEMessage.html)
     */
    sendHCEMessage(option: UniNamespace.SendHCEMessageOption): void;
    /**
     *
     * 需要基础库： `2.25.0`
     *
     * 在插件中使用：不支持
     *
     * 拉起手机发送短信界面。
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/sms/wx.sendSms.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/sms/wx.sendSms.html)
     */
    sendSms(option: UniNamespace.SendSmsOption): void;
    /**
     *
     * 需要基础库： `2.8.0`
     *
     * 在插件中使用：不支持
     *
     * 设置自定义登录态，在周期性拉取数据时带上，便于第三方服务器验证请求合法性
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/storage/background-fetch/wx.setBackgroundFetchToken.html](https://developers.weixin.qq.com/miniprogram/dev/api/storage/background-fetch/wx.setBackgroundFetchToken.html)
     */
    setBackgroundFetchToken(option: UniNamespace.SetBackgroundFetchTokenOption): void;
    /**
     *
     * 需要基础库： `2.20.1`
     *
     * 在插件中使用：不支持
     *
     * 开启双人通话。设置 `enable` 为 `false` 时，无法接听呼叫。
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/voip/wx.setEnable1v1Chat.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/voip/wx.setEnable1v1Chat.html)
     */
    setEnable1v1Chat(option: UniNamespace.SetEnable1v1ChatOption): void;
    /**
     *
     * 需要基础库： `2.3.0`
     *
     * 在插件中使用：需要基础库 `2.10.0`
     *
     * 设置 [InnerAudioContext](https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/InnerAudioContext.html) 的播放选项。设置之后对当前小程序全局生效。
     *
     * ****
     *
     * ## 注意事项
     * - 为保证微信整体体验，speakerOn 为 true 时，客户端会忽略 mixWithOther 参数的内容，强制与其它音频互斥
     * - 不支持在播放音频的过程中切换为扬声器播放，开发者如需切换可以先暂停当前播放的音频并记录下当前暂停的时间点，然后切换后重新从原来暂停的时间点开始播放音频
     * - 目前 wx.setInnerAudioOption 接口不兼容 wx.createWebAudioContext 接口，也不兼容 wx.createInnerAudioContext 开启 useWebAudioImplement 的情况，将在后续版本中支持
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/wx.setInnerAudioOption.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/wx.setInnerAudioOption.html)
     */
    setInnerAudioOption(option: UniNamespace.SetInnerAudioOption): void;
    /**
     *
     * 需要基础库： `1.4.3`
     *
     * 在插件中使用：不支持
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/ui/sticky/wx.setTopBarText.html](https://developers.weixin.qq.com/miniprogram/dev/api/ui/sticky/wx.setTopBarText.html)
     */
    setTopBarText(option: UniNamespace.SetTopBarTextOption): void;
    /**
     *
     * 需要基础库： `2.20.1`
     *
     * 在插件中使用：需要基础库 `2.21.3`
     *
     * 设置截屏/录屏时屏幕表现
     *
     * **Bug & Tip**
     *
     * 1. `tip`：iOS 要求基础库版本为 3.3.0 以上，且系统版本为 iOS 16 以上
     * 2. `tip`：iOS 目前只支持处理录屏时的表现
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/screen/wx.setVisualEffectOnCapture.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/screen/wx.setVisualEffectOnCapture.html)
     */
    setVisualEffectOnCapture(option: UniNamespace.SetVisualEffectOnCaptureOption): void;
    /**
     *
     * 需要基础库： `1.6.0`
     *
     * 在插件中使用：需要基础库 `2.9.1`
     *
     * 设置 `wifiList` 中 AP 的相关信息。在 `onGetWifiList` 回调后调用，**iOS特有接口**。
     *
     * **注意**
     *
     * - 该接口只能在 `onGetWifiList` 回调之后才能调用。
     * - 此时客户端会挂起，等待小程序设置 Wi-Fi 信息，请务必尽快调用该接口，若无数据请传入一个空数组。
     * - 有可能随着周边 Wi-Fi 列表的刷新，单个流程内收到多次带有存在重复的 Wi-Fi 列表的回调。
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/wifi/wx.setWifiList.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/wifi/wx.setWifiList.html)
     */
    setWifiList(option: UniNamespace.SetWifiListOption): void;
    /**
     *
     * 需要基础库： `2.10.1`
     *
     * 在插件中使用：不支持
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/ui/window/wx.setWindowSize.html](https://developers.weixin.qq.com/miniprogram/dev/api/ui/window/wx.setWindowSize.html)
     */
    setWindowSize(option: UniNamespace.SetWindowSizeOption): void;
    /**
     *
     * 需要基础库： `3.7.8`
     *
     * 在插件中使用：不支持
     *
     * 转发小程序卡片到聊天
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/chattool/wx.shareAppMessageToGroup.html](https://developers.weixin.qq.com/miniprogram/dev/api/chattool/wx.shareAppMessageToGroup.html)
     */
    shareAppMessageToGroup(option: UniNamespace.ShareAppMessageToGroupOption): void;
    /**
     *
     * 需要基础库： `3.7.8`
     *
     * 在插件中使用：不支持
     *
     * 转发表情到聊天
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/chattool/wx.shareEmojiToGroup.html](https://developers.weixin.qq.com/miniprogram/dev/api/chattool/wx.shareEmojiToGroup.html)
     */
    shareEmojiToGroup(option: UniNamespace.ShareEmojiToGroupOption): void;
    /**
     *
     * 需要基础库： `2.16.1`
     *
     * 在插件中使用：不支持
     *
     * 转发文件到聊天
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/share/wx.shareFileMessage.html](https://developers.weixin.qq.com/miniprogram/dev/api/share/wx.shareFileMessage.html)
     */
    shareFileMessage(option: UniNamespace.ShareFileMessageOption): void;
    /**
     *
     * 需要基础库： `3.7.8`
     *
     * 在插件中使用：不支持
     *
     * 转发文件到聊天
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/chattool/wx.shareFileToGroup.html](https://developers.weixin.qq.com/miniprogram/dev/api/chattool/wx.shareFileToGroup.html)
     */
    shareFileToGroup(option: UniNamespace.ShareFileToGroupOption): void;
    /**
     *
     * 需要基础库： `3.7.8`
     *
     * 在插件中使用：不支持
     *
     * 转发图片到聊天
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/chattool/wx.shareImageToGroup.html](https://developers.weixin.qq.com/miniprogram/dev/api/chattool/wx.shareImageToGroup.html)
     */
    shareImageToGroup(option: UniNamespace.ShareImageToGroupOption): void;
    /**
     *
     * 在插件中使用：不支持
     *
     * 分享数据到微信运动。
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/open-api/werun/wx.shareToWeRun.html](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/werun/wx.shareToWeRun.html)
     */
    shareToWeRun(option: UniNamespace.ShareToWeRunOption): void;
    /**
     *
     * 需要基础库： `2.16.1`
     *
     * 在插件中使用：不支持
     *
     * 转发视频到聊天
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/share/wx.shareVideoMessage.html](https://developers.weixin.qq.com/miniprogram/dev/api/share/wx.shareVideoMessage.html)
     */
    shareVideoMessage(option: UniNamespace.ShareVideoMessageOption): void;
    /**
     *
     * 需要基础库： `3.8.8`
     *
     * 在插件中使用：不支持
     *
     * 转发视频到聊天
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/chattool/wx.shareVideoToGroup.html](https://developers.weixin.qq.com/miniprogram/dev/api/chattool/wx.shareVideoToGroup.html)
     */
    shareVideoToGroup(option: UniNamespace.ShareVideoToGroupOption): void;
    /**
     *
     * 需要基础库： `2.10.0`
     *
     * 在插件中使用：不支持
     *
     * 拉取h5领取红包封面页。获取参考红包封面地址参考 [微信红包封面开发平台](https://cover.weixin.qq.com/cgi-bin/mmcover-bin/readtemplate?t=page/index#/doc?page=introduce)。
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/open-api/redpackage/wx.showRedPackage.html](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/redpackage/wx.showRedPackage.html)
     */
    showRedPackage(option: UniNamespace.ShowRedPackageOption): void;
    /**
     *
     * 需要基础库： `2.14.3`
     *
     * 在插件中使用：需要基础库 `2.16.0`
     *
     * 打开分享图片弹窗，可以将图片发送给朋友、收藏或下载
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/share/wx.showShareImageMenu.html](https://developers.weixin.qq.com/miniprogram/dev/api/share/wx.showShareImageMenu.html)
     */
    showShareImageMenu(option: UniNamespace.ShowShareImageMenuOption): void;
    /**
     *
     * 需要基础库： `2.3.0`
     *
     * 在插件中使用：需要基础库 `2.9.1`
     *
     * 开始监听设备方向的变化。
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/motion/wx.startDeviceMotionListening.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/motion/wx.startDeviceMotionListening.html)
     */
    startDeviceMotionListening(option?: UniNamespace.StartDeviceMotionListeningOption): void;
    /**
     *
     * 需要基础库： `1.7.0`
     *
     * 在插件中使用：需要基础库 `2.1.0`
     *
     * 初始化 NFC 模块。（HCE 模式仅安卓支持）
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc-hce/wx.startHCE.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc-hce/wx.startHCE.html)
     */
    startHCE(option: UniNamespace.StartHCEOption): void;
    /**
     *
     * 需要基础库： `2.4.0`
     *
     * 在插件中使用：需要基础库 `2.15.0`
     *
     * 开始搜索局域网下的 mDNS 服务。搜索的结果会通过 wx.onLocalService* 事件返回。
     *
     * **注意**
     *
     * 1. 由于操作系统相关能力变更，iOS 微信客户端 7.0.18 及以上版本无法使用 mDNS 相关接口，安卓版本不受影响
     * 2. wx.startLocalServiceDiscovery 是一个消耗性能的行为，开始 30 秒后会自动 stop 并执行 wx.onLocalServiceDiscoveryStop 注册的回调函数。
     * 3. 在调用 wx.startLocalServiceDiscovery 后，在这次搜索行为停止后才能发起下次 wx.startLocalServiceDiscovery。停止本次搜索行为的操作包括调用 wx.stopLocalServiceDiscovery 和 30 秒后系统自动 stop 本次搜索。
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/network/mdns/wx.startLocalServiceDiscovery.html](https://developers.weixin.qq.com/miniprogram/dev/api/network/mdns/wx.startLocalServiceDiscovery.html)
     */
    startLocalServiceDiscovery(option: UniNamespace.StartLocalServiceDiscoveryOption): void;
    /**
     *
     * 需要基础库： `2.8.0`
     *
     * 在插件中使用：不支持
     *
     * 开启小程序在前后台时均可接收位置消息，后台包括离开小程序后继续使用微信（微信仍在前台）、离开微信（微信在后台）两个场景，需引导用户开启[授权](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/authorize.html#后台定位)。授权以后，小程序在运行中或进入后台均可接受位置消息变化。
     *  ## 使用方法
     * 自 2022 年 7 月 14 日后发布的小程序，若使用该接口，需要在 app.json 中进行声明，否则将无法正常使用该接口，2022年7月14日前发布的小程序不受影响。[具体规则见公告](https://developers.weixin.qq.com/community/develop/doc/000a02f2c5026891650e7f40351c01)
     *
     *  ## 申请开通
     *  暂只针对如下类目的小程序开放，需要先通过类目审核，再在小程序管理后台，「开发」-「开发管理」-「接口设置」中自助开通该接口权限。从2022年7月14日开始，在代码审核环节将检测该接口是否已完成开通，如未开通，将在代码提审环节进行拦截。
     *
     *  ### 国内主体开放类目
     *
     *  | 一级类目/主体类型	| 二级类目	| 应用场景 |
     *  | -------------- | -------| -------- |
     *  | 电商平台 |	/	| 在小程序内提供线下商超导览、导航服务 |
     *  | 商家自营 |	/	| 在小程序内提供线下商超导览、导航服务 |
     *  | 交通服务 |	/	| 代驾服务、打车出行、城市共享交通、实时导航服务等 |
     *  | 生活服务 |	跑腿、共享服务	| 含有B端小程序配送服务，基于地理位置共享工具类服务  |
     *  | 物流服务 |	收件/派件、查件、邮政、装卸搬运、快递柜、货物运输	 |	提供B端小程序快递/货物收发服务 |
     *  | 餐饮服务 | 	点餐平台、外卖平台	| 提供B端小程序餐饮配送服务、线下门店实时导航 |
     *  | 工具	| 健康管理 |	基于实时地理位置提供身体管理记录等服务 |
     *  | 旅游 | 景区服务、住宿服务 | 在小程序内提供景区导航、导览服务、酒店导航服务 |
     *  | 政务民生 |	/	 | 提供政务单位相关业务 |
     *  | 政府主体账号 |	/	| 提供政务单位相关业务 |
     *
     *  ### 海外主体开放类目
     *  | 一级类目/主体类型	| 二级类目	| 应用场景 |
     *  | -------------- | -------| -------- |
     *  | 交通服务	 | /	 | 代驾服务、打车出行、城市共享交通、实时导航服务等 |
     *  | 生活服务	 | 家政、外送	 | 含有B端小程序配送服务，基于地理位置导航上门服务 |
     *  | 快递业与邮政	 | /	 | 提供B端小程序快递/货物收发服务 |
     *  | 餐饮服务	 | 外卖点餐	 | 提供B端小程序餐饮配送服务、线下门店实时导航 |
     *  | 跨境电商	 | /	 | 在小程序内提供线下商超导览、导航服务 |
     *  | 本地服务	 | 电商平台、服装/鞋/箱包、玩具、家电/数码/手机、美妆/洗护、珠宝/饰品/眼镜/钟表、运动/户外/乐器、鲜花/园艺/工艺品、家居/家饰/家纺、办公/文具、机械/电子器件、酒、食品、百货/超市/便利店、宠物食品/用品	 | 在小程序内提供线下商超导览、导航服务 |
     *
     * **注意**
     *
     * - 安卓微信7.0.6版本，iOS 7.0.5版本起支持该接口
     * - 需在app.json中配置requiredBackgroundModes: ['location']后使用
     * - 获取位置信息需配置[地理位置用途说明](https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#permission)。
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/location/wx.startLocationUpdateBackground.html](https://developers.weixin.qq.com/miniprogram/dev/api/location/wx.startLocationUpdateBackground.html)
     */
    startLocationUpdateBackground(option: UniNamespace.StartLocationUpdateBackgroundOption): void;
    /**
     *
     * 在插件中使用：需要基础库 `1.9.6`
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/recorder/wx.startRecord.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/recorder/wx.startRecord.html)
     */
    startRecord(option?: UniNamespace.WxStartRecordOption): void;
    /**
     *
     * 在插件中使用：需要基础库 `1.9.6`
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/background-audio/wx.stopBackgroundAudio.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/background-audio/wx.stopBackgroundAudio.html)
     */
    stopBackgroundAudio(option?: UniNamespace.StopBackgroundAudioOption): void;
    /**
     *
     * 需要基础库： `2.3.0`
     *
     * 在插件中使用：需要基础库 `2.9.1`
     *
     * 停止监听设备方向的变化。
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/motion/wx.stopDeviceMotionListening.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/motion/wx.stopDeviceMotionListening.html)
     */
    stopDeviceMotionListening(option?: UniNamespace.StopDeviceMotionListeningOption): void;
    /**
     *
     * 需要基础库： `2.18.0`
     *
     * 在插件中使用：需要基础库 `2.21.3`
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/ai/face/wx.stopFaceDetect.html](https://developers.weixin.qq.com/miniprogram/dev/api/ai/face/wx.stopFaceDetect.html)
     */
    stopFaceDetect(option?: UniNamespace.StopFaceDetectOption): void;
    /**
     *
     * 需要基础库： `1.7.0`
     *
     * 在插件中使用：需要基础库 `2.1.0`
     *
     * 关闭 NFC 模块。仅在安卓系统下有效。
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc-hce/wx.stopHCE.html](https://developers.weixin.qq.com/miniprogram/dev/api/device/nfc-hce/wx.stopHCE.html)
     */
    stopHCE(option?: UniNamespace.StopHCEOption): void;
    /**
     *
     * 需要基础库： `2.4.0`
     *
     * 在插件中使用：需要基础库 `2.15.0`
     *
     * 停止搜索 mDNS 服务
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/network/mdns/wx.stopLocalServiceDiscovery.html](https://developers.weixin.qq.com/miniprogram/dev/api/network/mdns/wx.stopLocalServiceDiscovery.html)
     */
    stopLocalServiceDiscovery(option?: UniNamespace.StopLocalServiceDiscoveryOption): void;
    /**
     *
     * 在插件中使用：需要基础库 `1.9.6`
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/recorder/wx.stopRecord.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/recorder/wx.stopRecord.html)
     */
    stopRecord(option?: UniNamespace.WxStopRecordOption): void;
    /**
     *
     * 在插件中使用：需要基础库 `1.9.6`
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/wx.stopVoice.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/audio/wx.stopVoice.html)
     */
    stopVoice(option?: UniNamespace.StopVoiceOption): void;
    /**
     *
     * 需要基础库： `2.11.0`
     *
     * 在插件中使用：需要基础库 `2.11.0`
     *
     * 订阅视频画面成员。对于视频房间，当成员超过两人时需进行订阅，否则只能看到最先加入房间的两人画面。
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/voip/wx.subscribeVoIPVideoMembers.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/voip/wx.subscribeVoIPVideoMembers.html)
     */
    subscribeVoIPVideoMembers(option: UniNamespace.SubscribeVoIPVideoMembersOption): void;
    /**
     *
     * 需要基础库： `1.2.0`
     *
     * 在插件中使用：需要基础库 `2.1.0`
     *
     * 在插件中使用时，只能在当前插件的页面中调用
     *
     * 更新转发属性
     *
     * ****
     *
     * ## 注意事项
     * - bug：在iOS上，如果 withShareTicket 传了 true ，同时 isUpdatableMessage 传了 false，会导致 withShareTicket 失效。解决办法：当 withShareTicket 传了 true 的时候，isUpdatableMessage 传 true 或者不传都可以，但不要传 false。如果需要关掉动态消息设置，则另外单独调用一次 wx.updateShareMenu({ isUpdatableMessage: false }) 即可。
     *
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/share/wx.updateShareMenu.html](https://developers.weixin.qq.com/miniprogram/dev/api/share/wx.updateShareMenu.html)
     */
    updateShareMenu(option: UniNamespace.UpdateShareMenuOption): void;
    /**
     *
     * 需要基础库： `2.7.0`
     *
     * 在插件中使用：需要基础库 `2.9.0`
     *
     * 更新实时语音静音设置
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/media/voip/wx.updateVoIPChatMuteConfig.html](https://developers.weixin.qq.com/miniprogram/dev/api/media/voip/wx.updateVoIPChatMuteConfig.html)
     */
    updateVoIPChatMuteConfig(option: UniNamespace.UpdateVoIPChatMuteConfigOption): void;
    /**
     *
     * 需要基础库： `2.12.0`
     *
     * 在插件中使用：需要基础库 `2.12.0`
     *
     * 更新客户端版本。当判断用户小程序所在客户端版本过低时，可使用该接口跳转到更新微信页面。
     *
     * 文档: [https://developers.weixin.qq.com/miniprogram/dev/api/base/update/wx.updateWeChatApp.html](https://developers.weixin.qq.com/miniprogram/dev/api/base/update/wx.updateWeChatApp.html)
     */
    updateWeChatApp(option?: UniNamespace.UpdateWeChatAppOption): void;
    /**
     * 获得 xr-frame 接口系统
     */
    // @ts-expect-error
    getXrFrameSystem(): import("XrFrame").IXrFrameSystem;
}
